#script 1.0
#license MITLicense
#pclass Goedel.ASN Generate
#% DateTime GenerateTime = DateTime.UtcNow;
#% string Namespace = "Goedel.ASN";

#method GenerateCS ASN2 ASN2
#% ASN2.Complete ();

using System;
using System.Collections.Generic;
using System.Text;
using Goedel.ASN;

// This is the generated code Don't edit.


// Generate OID declarations

namespace Goedel.ASN {  // default namespace

#foreach (_Choice Toplevel in ASN2.Top)
#switchcast ASN2Type Toplevel
#casecast Namespace Cast
#% Namespace = Cast.Name.ToString();
	}
namespace #{Cast.Name} {

#casecast ROOT ROOT
    /// <summary>
    /// #{ROOT.Name} = #!
#foreach (Entry Entry in ROOT.Entries)
 #{Entry.Name}(#{Entry.Value}) #!
#end foreach

    /// </summary>
	public partial class Constants {
		/// <summary>
		/// #{ROOT.Name} as integer sequence
		/// </summary>
		public readonly static int [] OID__#{ROOT.Name} = new int [] { #!
#% MakeConst(ROOT.Binary) ;	
};
		/// <summary>
		/// #{ROOT.Name} as string
		/// </summary>
		public const string OIDS__#{ROOT.Name} = "#!
#% MakeString(ROOT.Binary) ;	
";

#% MakeChildren (ROOT);
		}
#end switchcast
#end foreach
	}


// Generate Classes
namespace Goedel.ASN {  // default namespace

#foreach (_Choice Toplevel in ASN2.Top)
#switchcast ASN2Type Toplevel
#casecast Namespace Cast
#% Namespace = Cast.Name.ToString();
	}
namespace #{Cast.Name} {
#casecast Class Class
    /// <summary>
	/// #{Class.Name} 
    /// </summary>
	public partial class #{Class.Name} : Goedel.ASN.Root {

#foreach (Member Member in Class.Entries)
#% EntryDeclaration (Member);
#end foreach

		/// <summary>
		/// Encode ASN.1 class members to specified buffer. 
		///
		/// NB Assinine ASN.1 DER encoding rules requires members be added in reverse order.
		/// </summary>
		/// <param name="Buffer">Output buffer</param>
        public override void Encode (Goedel.ASN.Buffer Buffer) {
			int Position = Buffer.Encode__Sequence_Start ();
#foreach (Member Member in Class.Entries)
#! Encode (Member.Name.ToString(), Member.Spec, Member.Flags, Member.Code);
#% Encode (Member);
			Buffer.Debug ("#{Member.Name}");
#end foreach
			Buffer.Encode__Sequence_End (Position);
            }

		}
#casecast Object Object
    /// <summary>
	/// #{Object.Name} 
    /// </summary>
	public partial class #{Object.Name} : Goedel.ASN.Root {
		/// <summary>
		/// The OID value
		/// </summary>
		public override int [] OID { 
			get { return Constants.OID__#{Object.OID}; } }  

#% 
#foreach (Member Member in Object.Entries)
#% EntryDeclaration (Member);
#end foreach
		/// <summary>
		/// Encode ASN.1 class members to specified buffer. 
		///
		/// NB Assinine ASN.1 DER encoding rules requires members be added in reverse order.
		/// </summary>
		/// <param name="Buffer">Output buffer</param>
        public override void Encode (Goedel.ASN.Buffer Buffer) {
			int Position = Buffer.Encode__Sequence_Start ();
#foreach (Member Member in Object.Entries)
#! Encode (Member.Name.ToString(), Member.Spec, Member.Flags, Member.Code);
#% Encode (Member);
#end foreach
			Buffer.Encode__Sequence_End (Position);
            }
		}

#casecast SingularObject SingularObject

	// Singular, no sequence boundaries
    /// <summary>
	/// #{SingularObject.Name} 
    /// </summary>
	public partial class #{SingularObject.Name} : Goedel.ASN.Root {
		/// <summary>
		/// The OID value
		/// </summary>
		public override int [] OID { 
			get { return Constants.OID__#{SingularObject.OID}; } }  

#foreach (Member Member in SingularObject.Entries)
#% EntryDeclaration (Member);
#end foreach
		/// <summary>
		/// Encode ASN.1 class members to specified buffer. 
		///
		/// NB Assinine ASN.1 DER encoding rules requires members be added in reverse order.
		/// </summary>
		/// <param name="Buffer">Output buffer</param>
        public override void Encode (Goedel.ASN.Buffer Buffer) {
#foreach (Member Member in SingularObject.Entries)
#! Encode (Member.Name.ToString(), Member.Spec, Member.Flags, Member.Code);
#% Encode (Member);
#end foreach
            }
		}

#end switchcast
#end foreach
	}

#end method

#method EntryDeclaration Member Member
#switchcast ASN2Type Member.Spec
#casecast Choice Cast
#foreach (Member Entry in Cast.Entries)
#% EntryDeclaration (Entry);
#end foreach
#%  break; } default : {
		/// <summary>
		/// ASN.1 member #{Member.Name} 
		/// </summary>
		public #!
#% TypeDeclaration (Member.Spec);
#{Member.Name} ;
#end switchcast
#end method


#method TypeDeclaration _Choice Type
#switchcast ASN2Type Type
#casecast OIDRef Cast
int []  #!
#casecast Any Cast
byte []  #!
#casecast Integer Cast
int  #!
#casecast BigInteger Cast
byte []  #!
#casecast Boolean Cast
bool  #!
#casecast Time Cast
DateTime  #!
#casecast Bits Cast
byte []  #!
#casecast VBits Cast
byte []  #!
#casecast Octets Cast
byte []  #!
#casecast IA5String Cast
string #!
#casecast BMPString Cast
string #!
#casecast UTF8String Cast
string #!
#casecast PrintableString Cast
string #!
#casecast _Label Case
#{Namespace}.#{Case.Label} #!
#casecast List Cast
List <#!
#% TypeDeclaration (Cast.Spec);
> #!
#casecast Set Cast
List <#!
#% TypeDeclaration (Cast.Spec);
> #!
#casecast Choice Cast
// Choice declare all the type parts
#end switchcast
#end method

#method Encode Member Member
#%  Encode (Member.Name.ToString(), Member.Default, Member.Spec, Member.Flags, Member.Code);
#end method
#block
#%  public void Encode (String Name, _Choice Spec, int Flags, int Code) {
#%		Encode (Name, null, Spec, Flags, Code);
#%		}
#%  public void Encode (String Name, String Default, _Choice Spec, int Flags, int Code) {

#% bool Call = false;
#switchcast ASN2Type Spec
#casecast OIDRef Cast
			Buffer.Encode__OIDRef #!
#% Call = true;
#casecast Any Cast
			Buffer.Encode__Any #!
#% Call = true;
#casecast Integer Cast
#if (Default != null)
			// Default is #{Default}
			if (#{Name} != #{Default}) {
				Buffer.Encode__Integer (#{Name}, #{Flags}, #{Code});
				}
#else 
			Buffer.Encode__Integer #!
#% Call = true;
#end if
#casecast BigInteger Cast
			Buffer.Encode__BigInteger #!
#% Call = true;
#casecast Boolean Cast
#if (Default != null)
			// Default is #{Default}
			if (#{Name} != #{Default}) {
				Buffer.Encode__Boolean (#{Name}, #{Flags}, #{Code});
				}
#else 
			Buffer.Encode__Boolean #!
#% Call = true;
#end if
#casecast Time Cast
			Buffer.Encode__Time #!
#% Call = true;
#casecast Bits Cast
			Buffer.Encode__Bits #!
#% Call = true;
#casecast VBits Cast
			Buffer.Encode__VBits #!
#% Call = true;
#casecast Octets Cast
			Buffer.Encode__Octets #!
#% Call = true;
#casecast IA5String Cast
			Buffer.Encode__IA5String #!
#% Call = true;
#casecast BMPString Cast
			Buffer.Encode__BMPString #!
#% Call = true;
#casecast UTF8String Cast
			Buffer.Encode__UTF8String #!
#% Call = true;
#casecast PrintableString Cast
			Buffer.Encode__PrintableString #!
#% Call = true;
#casecast _Label Case
			Buffer.Encode__Object (#{Name}, #{Flags}, #{Code});
#casecast List Cast
			if (#{Name} == null || #{Name}.Count == 0) {
				Buffer.Encode__Object (null, #{Flags}, #{Code});
				}
			else {
				int XPosition = Buffer.Encode__Sequence_Start();
				foreach (#!
#% TypeDeclaration (Cast.Spec);
 _Index in #{Name}) {
		#!
#% Encode ("_Index", Cast.Spec, 0, 0);
					}
				Buffer.Encode__Sequence_End(XPosition, #{Flags}, #{Code});
			}
#casecast Set Cast
			if (#{Name} == null || #{Name}.Count == 0) {
				Buffer.Encode__Object (null, #{Flags}, #{Code});
				}
			else {
				int XPosition = Buffer.Encode__Set_Start();
				foreach (#!
#% TypeDeclaration (Cast.Spec);
 _Index in #{Name}) {
		#!
#% Encode ("_Index", Cast.Spec, 0, 0);
					}
				Buffer.Encode__Set_End(XPosition, #{Flags}, #{Code});
			}
#casecast Choice Cast
	// Do Choice
#foreach (Member ChoiceEntry in Cast.Entries)
            //
#! Encode (ChoiceEntry.Name.ToString(), ChoiceEntry.Spec, ChoiceEntry.Flags, ChoiceEntry.Code);
#% Encode (ChoiceEntry);
#end foreach
#end switchcast
#if Call
 (#{Name}, #{Flags}, #{Code});
#end if
#% }
#end block


#method MakeChildren _Choice Element
#foreach (OID OID in Element.Children)

		/// <summary>
		/// #{OID.Name} = #{OID.Root} (#{OID.Value}) as integer sequence
		/// </summary>
		public readonly static int [] OID__#{OID.Name} = new int [] { #!
#% MakeConst(OID.Binary) ;	
};
		/// <summary>
		/// #{OID.Name} = #{OID.Root} (#{OID.Value}) as string
		/// </summary>
		public const string OIDS__#{OID.Name} = "#!
#% MakeString(OID.Binary) ;	
";


#% MakeChildren (OID);
#end foreach
#end method

#method MakeConst int[] Array
#% bool Comma = false;
#foreach (int Value in Array)
#if Comma
, #!
#end if
#% Comma = true;
#{Value}#!
#end foreach
#end method


#method MakeString int[] Array
#% bool Comma = false;
#foreach (int Value in Array)
#if Comma
.#!
#end if
#% Comma = true;
#{Value}#!
#end foreach
#end method

#end pclass