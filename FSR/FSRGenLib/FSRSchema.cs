
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;


//
// Namespace FSRGen
// Class FSRSchema
//


// Types
//   TopTypeType
//       FSR
//   TypeType
//       Charset
//       State
//       Token
//       Entry
//       On
//       Any
//       Return
//       GoTo
//   IdType
//       Top
//       PrefixT
//       tCharset
//       tState
//   NamespaceType
//       FSRGen
//   ClassType
//       FSRSchema
//   NameType
//       Id
//       Prefix
//       Entries
//       First
//       Last
//       Action
//       Is
//       Match
//       Emit
//       Next
//   TokenType
//       tAction
//       tToken

namespace FSRGen {


    public enum FSRSchemaType {
        _Top,

        FSR,
        Charset,
        State,
        Entry,
        On,
        Any,
        Return,
        GoTo,
        Token,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public FSRSchemaType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);
        }



    public partial class FSR : _Choice {
        public ID<_Choice>				Id; 
        public ID<_Choice>				Prefix; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.FSR;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("FSR");
				}

	        Output.WriteId ("Id", Id.ToString()); 
	        Output.WriteId ("Prefix", Prefix.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("FSR");
				}			
			}
		}

    public partial class Charset : _Choice {
        public ID<_Choice>				Id; 
		public string					First;
		public string					Last;

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.Charset;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Charset");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("First", First);
			Output.WriteAttribute ("Last", Last);
			if (tag) {
				Output.EndElement ("Charset");
				}			
			}
		}

    public partial class State : _Choice {
        public ID<_Choice>				Id; 
        public TOKEN<_Choice>			Action;
        public TOKEN<_Choice>			Token;
        public List <Entry>           Entries = new List<Entry> ();

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.State;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("State");
				}

	        Output.WriteId ("Id", Id.ToString()); 
	        Output.WriteId ("Action", Action.ToString());
	        Output.WriteId ("Token", Token.ToString());
			Output.StartList ("");
			foreach (Entry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("State");
				}			
			}
		}

    public partial class Entry : _Choice {
        public _Choice					Is;
        public _Choice					Action;

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.Entry;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Entry");
				}

	        Is.Serialize (Output, true);
	        Action.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Entry");
				}			
			}
		}

    public partial class On : _Choice {
		public string					Match;

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.On;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("On");
				}

			Output.WriteAttribute ("Match", Match);
			if (tag) {
				Output.EndElement ("On");
				}			
			}
		}

    public partial class Any : _Choice {

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.Any;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Any");
				}

			if (tag) {
				Output.EndElement ("Any");
				}			
			}
		}

    public partial class Return : _Choice {
        public TOKEN<_Choice>			Emit;

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.Return;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Return");
				}

	        Output.WriteId ("Emit", Emit.ToString());
			if (tag) {
				Output.EndElement ("Return");
				}			
			}
		}

    public partial class GoTo : _Choice {
        public REF<_Choice>				Next;

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.GoTo;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("GoTo");
				}

	        Output.WriteId ("Next", Next.ToString());
			if (tag) {
				Output.EndElement ("GoTo");
				}			
			}
		}

    public partial class Token : _Choice {
        public ID<_Choice>				Id; 

        public override FSRSchemaType _Tag () {
            return FSRSchemaType.Token;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Token");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			if (tag) {
				Output.EndElement ("Token");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override FSRSchemaType _Tag () {
            return FSRSchemaType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }
//	}

//namespace Goedel.Registry {

    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		FSR_Start,
		FSR__Id,				
		FSR__Prefix,				
		FSR__Entries,				
		Charset_Start,
		Charset__Id,				
		Charset__First,				
		Charset__Last,				
		State_Start,
		State__Id,				
		State__Action,				
		State__Token,				
		State__Entries,				
		Entry_Start,
		Entry__Is,				
		Entry__Action,				
		On_Start,
		On__Match,				
		Any_Start,
		Return_Start,
		Return__Emit,				
		GoTo_Start,
		GoTo__Next,				
		Token_Start,
		Token__Id,				
        }


    struct _StackItem {
        public StateCode   State;
        public FSRGen._Choice     Token;
        }

    public partial class FSRSchema : Goedel.Registry.Parser{
        public List <FSRGen._Choice>        Top;
        public Registry	<FSRGen._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        FSRGen._Choice				Current;
        List <_StackItem>						Stack;
        TokenType								CurrentToken;
        Position								CurrentPosition;
        string									CurrentText;


        public static FSRSchema Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new FSRSchema();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }

            return Result;
            }


        public FSRSchema() {
            Top = new List<FSRGen._Choice> () ;
            Registry = new Registry <FSRGen._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__Top = Registry.TYPE ("Top"); 
			TYPE__PrefixT = Registry.TYPE ("PrefixT"); 
			TYPE__tCharset = Registry.TYPE ("tCharset"); 
			TYPE__tState = Registry.TYPE ("tState"); 
			TYPE__tAction = Registry.TYPE ("tAction"); 
			TYPE__tToken = Registry.TYPE ("tToken"); 



            }



        public TYPE<FSRGen._Choice> TYPE__Top ;
        public TYPE<FSRGen._Choice> TYPE__PrefixT ;
        public TYPE<FSRGen._Choice> TYPE__tCharset ;
        public TYPE<FSRGen._Choice> TYPE__tState ;
        public TYPE<FSRGen._Choice> TYPE__tAction ;
        public TYPE<FSRGen._Choice> TYPE__tToken ;

        private FSRGen._Choice New_Choice(string Label) {
            switch (Label) {

                case "FSR": return NewFSR();
                case "Charset": return NewCharset();
                case "State": return NewState();
                case "Entry": return NewEntry();
                case "On": return NewOn();
                case "Any": return NewAny();
                case "Return": return NewReturn();
                case "GoTo": return NewGoTo();
                case "Token": return NewToken();

				}
            throw new System.Exception ("Reserved word not recognized \"" + Label + "\"");
            }



        private FSRGen.FSR NewFSR() {
            FSRGen.FSR result = new FSRGen.FSR();
            Push (result);
            State = StateCode.FSR_Start;
            return result;
            }


        private FSRGen.Charset NewCharset() {
            FSRGen.Charset result = new FSRGen.Charset();
            Push (result);
            State = StateCode.Charset_Start;
            return result;
            }


        private FSRGen.State NewState() {
            FSRGen.State result = new FSRGen.State();
            Push (result);
            State = StateCode.State_Start;
            return result;
            }


        private FSRGen.Entry NewEntry() {
            FSRGen.Entry result = new FSRGen.Entry();
            Push (result);
            State = StateCode.Entry_Start;
            return result;
            }


        private FSRGen.On NewOn() {
            FSRGen.On result = new FSRGen.On();
            Push (result);
            State = StateCode.On_Start;
            return result;
            }


        private FSRGen.Any NewAny() {
            FSRGen.Any result = new FSRGen.Any();
            Push (result);
            State = StateCode.Any_Start;
            return result;
            }


        private FSRGen.Return NewReturn() {
            FSRGen.Return result = new FSRGen.Return();
            Push (result);
            State = StateCode.Return_Start;
            return result;
            }


        private FSRGen.GoTo NewGoTo() {
            FSRGen.GoTo result = new FSRGen.GoTo();
            Push (result);
            State = StateCode.GoTo_Start;
            return result;
            }


        private FSRGen.Token NewToken() {
            FSRGen.Token result = new FSRGen.Token();
            Push (result);
            State = StateCode.Token_Start;
            return result;
            }


        static FSRGen.FSRSchemaType _Reserved(string Label) {
            switch (Label) {

                case "FSR": return FSRGen.FSRSchemaType.FSR;
                case "Charset": return FSRGen.FSRSchemaType.Charset;
                case "State": return FSRGen.FSRSchemaType.State;
                case "Entry": return FSRGen.FSRSchemaType.Entry;
                case "On": return FSRGen.FSRSchemaType.On;
                case "Any": return FSRGen.FSRSchemaType.Any;
                case "Return": return FSRGen.FSRSchemaType.Return;
                case "GoTo": return FSRGen.FSRSchemaType.GoTo;
                case "Token": return FSRGen.FSRSchemaType.Token;

                }
            return FSRGen.FSRSchemaType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (FSRGen._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (FSRGen._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new System.Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {
            CurrentToken = Token;
            CurrentPosition = Position;
            CurrentText = Text;

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new System.Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            FSRGen.FSRSchemaType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == FSRGen.FSRSchemaType.FSR)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new System.Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new System.Exception("Too Many Closing Braces");

                    case StateCode.FSR_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.FSR Current_Cast = (FSRGen.FSR)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__Top, Current_Cast);
                            State = StateCode.FSR__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.FSR__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.FSR Current_Cast = (FSRGen.FSR)Current;
                            Current_Cast.Prefix = Registry.ID(Position, Text, TYPE__PrefixT, Current_Cast);
                            State = StateCode.FSR__Prefix;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.FSR__Prefix:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.FSR__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.FSR__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							FSRGen.FSR Current_Cast = (FSRGen.FSR)Current;
                            FSRGen.FSRSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == FSRGen.FSRSchemaType.Charset) |
									(LabelType == FSRGen.FSRSchemaType.State) |
									(LabelType == FSRGen.FSRSchemaType.Token) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Charset State Token ]");
								}
							}
                        break;


                    case StateCode.Charset_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.Charset Current_Cast = (FSRGen.Charset)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__tCharset, Current_Cast);
                            State = StateCode.Charset__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Charset__Id:
                        if (Token == TokenType.STRING) {
                            FSRGen.Charset Current_Cast = (FSRGen.Charset)Current;
                            Current_Cast.First = Text;
                            State = StateCode.Charset__First;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Charset__First:
                        if (Token == TokenType.STRING) {
                            FSRGen.Charset Current_Cast = (FSRGen.Charset)Current;
                            Current_Cast.Last = Text;
                            State = StateCode.Charset__Last;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Charset__Last:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.State_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.State Current_Cast = (FSRGen.State)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__tState, Current_Cast);
                            State = StateCode.State__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.State__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.State Current_Cast = (FSRGen.State)Current;
                            Current_Cast.Action = Registry.TOKEN(Position, Text, TYPE__tAction, Current_Cast);
                            State = StateCode.State__Action;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.State__Action:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.State Current_Cast = (FSRGen.State)Current;
                            Current_Cast.Token = Registry.TOKEN(Position, Text, TYPE__tToken, Current_Cast);
                            State = StateCode.State__Token;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.State__Token:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.State__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.State__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            FSRGen.State Current_Cast = (FSRGen.State)Current;
                            Current_Cast.Entries.Add (NewEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Entry_Start:
                        if (Token == TokenType.LABEL) {
							FSRGen.Entry Current_Cast = (FSRGen.Entry)Current;
                            FSRGen.FSRSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == FSRGen.FSRSchemaType.On) |
									(LabelType == FSRGen.FSRSchemaType.Any) ) {
                                State = StateCode.Entry__Is;
                                Current_Cast.Is = New_Choice(Text);
                                }
                            else {
                                FSRGen._Label result = new FSRGen._Label();
                                result.Label = Registry.REF(Position, Text, TYPE__tCharset, Current_Cast);
                                Current_Cast.Is = result;
                                State = StateCode.Entry__Is;
                                }
                            break;
                            }
                        else if (Token == TokenType.LITERAL) {
                            FSRGen._Label result = new FSRGen._Label();
                            FSRGen.Entry Current_Cast = (FSRGen.Entry)Current;
                            result.Label = Registry.REF(Position, Text, TYPE__tCharset, Current_Cast);
                            Current_Cast.Is = result;
                            State = StateCode.Entry__Is;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [On Any ]");

                    case StateCode.Entry__Is:
                        if (Token == TokenType.LABEL) {
							FSRGen.Entry Current_Cast = (FSRGen.Entry)Current;
                            FSRGen.FSRSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == FSRGen.FSRSchemaType.Return) |
									(LabelType == FSRGen.FSRSchemaType.GoTo) ) {
                                State = StateCode.Entry__Action;
                                Current_Cast.Action = New_Choice(Text);
                                }
                            else {
                               throw new System.Exception("Parser Error Expected [Return GoTo ]");
                                }
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Return GoTo ]");

                    case StateCode.Entry__Action:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.On_Start:
                        if (Token == TokenType.STRING) {
                            FSRGen.On Current_Cast = (FSRGen.On)Current;
                            Current_Cast.Match = Text;
                            State = StateCode.On__Match;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.On__Match:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Any_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Return_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.Return Current_Cast = (FSRGen.Return)Current;
                            Current_Cast.Emit = Registry.TOKEN(Position, Text, TYPE__tToken, Current_Cast);
                            State = StateCode.Return__Emit;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Return__Emit:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.GoTo_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.GoTo Current_Cast = (FSRGen.GoTo)Current;
                            Current_Cast.Next = Registry.REF(Position, Text, TYPE__tState, Current_Cast);
                            State = StateCode.GoTo__Next;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.GoTo__Next:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Token_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            FSRGen.Token Current_Cast = (FSRGen.Token)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__tToken, Current_Cast);
                            State = StateCode.Token__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Token__Id:
                        Pop ();
                        Represent = true; 
                        break;

                    default:
                        throw new System.Exception("Unreachable code reached");
                    }
                }
            }
        }
	}


