
//  Test
//  
//  This file was automatically generated at 2/8/2015 3:19:39 PM
//   
//  Changes to this file may be overwritten without warning
//  
//  Generator:  GoedelShell version 1.0.0.0
//      Goedel Script Version : 0.1   Generated 
//      Goedel Schema Version : 0.1   Generated
//  
//      Copyright : Copyright ©  2012
//  
//  Build Platform: Win32NT 6.2.9200.0
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;


//
// Namespace CommandP
// Class CommandParse
//


// Types
//   TopTypeType
//       Class
//   TypeType
//       Brief
//       Command
//       OptionSet
//       Enumerate
//       Type
//       About
//       Parameter
//       Option
//       Include
//       DefaultCommand
//       Lazy
//       Parser
//       Generator
//       Script
//       Default
//       Case
//   IdType
//       CommandType
//       TypeType
//       OptionSetType
//   NamespaceType
//       CommandP
//   ClassType
//       CommandParse
//   NameType
//       Namespace
//       Id
//       Entries
//       Tag
//       Text
//       Name
//       Modifier
//       Extension
//       Options
//   TokenType
//       ClassType
//       PType
//       CaseType

namespace CommandP {


    public enum CommandParseType {
        _Top,

        Class,
        Command,
        DefaultCommand,
        Brief,
        Parameter,
        Parser,
        Option,
        Script,
        Include,
        OptionSet,
        Enumerate,
        Case,
        Type,
        Default,
        About,
        Lazy,
        Generator,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public CommandParseType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);
        }



    public partial class Class : _Choice {
        public TOKEN<_Choice>			Namespace;
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Class;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Class");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Class");
				}			
			}
		}

    public partial class Command : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Command;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Command");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Command");
				}			
			}
		}

    public partial class DefaultCommand : _Choice {

        public override CommandParseType _Tag () {
            return CommandParseType.DefaultCommand;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("DefaultCommand");
				}

			if (tag) {
				Output.EndElement ("DefaultCommand");
				}			
			}
		}

    public partial class Brief : _Choice {
		public string					Text;

        public override CommandParseType _Tag () {
            return CommandParseType.Brief;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Brief");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Brief");
				}			
			}
		}

    public partial class Parameter : _Choice {
        public TOKEN<_Choice>			Name;
		public string					Text;
        public REF<_Choice>				Type;
        public List <_Choice>           Modifier = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Parameter;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Parameter");
				}

	        Output.WriteId ("Name", Name.ToString());
			Output.WriteAttribute ("Text", Text);
	        Output.WriteId ("Type", Type.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Modifier) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Parameter");
				}			
			}
		}

    public partial class Parser : _Choice {
        public TOKEN<_Choice>			Namespace;
        public TOKEN<_Choice>			Class;
		public string					Extension;
        public List <_Choice>           Modifier = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Parser;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Parser");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Class", Class.ToString());
			Output.WriteAttribute ("Extension", Extension);
			Output.StartList ("");
			foreach (_Choice _e in Modifier) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Parser");
				}			
			}
		}

    public partial class Option : _Choice {
        public TOKEN<_Choice>			Name;
		public string					Command;
        public REF<_Choice>				Type;
        public List <_Choice>           Modifier = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Option;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Option");
				}

	        Output.WriteId ("Name", Name.ToString());
			Output.WriteAttribute ("Command", Command);
	        Output.WriteId ("Type", Type.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Modifier) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Option");
				}			
			}
		}

    public partial class Script : _Choice {
        public TOKEN<_Choice>			Namespace;
        public TOKEN<_Choice>			Class;
        public TOKEN<_Choice>			Id;
		public string					Extension;
        public List <_Choice>           Modifier = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Script;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Script");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Class", Class.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Extension", Extension);
			Output.StartList ("");
			foreach (_Choice _e in Modifier) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Script");
				}			
			}
		}

    public partial class Include : _Choice {
        public REF<_Choice>				Id;

        public override CommandParseType _Tag () {
            return CommandParseType.Include;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Include");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Include");
				}			
			}
		}

    public partial class OptionSet : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Options = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.OptionSet;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("OptionSet");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("OptionSet");
				}			
			}
		}

    public partial class Enumerate : _Choice {
        public ID<_Choice>				Id; 
        public List <Case>           Entries = new List<Case> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Enumerate;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enumerate");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (Case _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enumerate");
				}			
			}
		}

    public partial class Case : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;

        public override CommandParseType _Tag () {
            return CommandParseType.Case;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Case");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			if (tag) {
				Output.EndElement ("Case");
				}			
			}
		}

    public partial class Type : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Text;

        public override CommandParseType _Tag () {
            return CommandParseType.Type;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Type");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Type");
				}			
			}
		}

    public partial class Default : _Choice {
		public string					Text;

        public override CommandParseType _Tag () {
            return CommandParseType.Default;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Default");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Default");
				}			
			}
		}

    public partial class About : _Choice {
		public string					Tag;

        public override CommandParseType _Tag () {
            return CommandParseType.About;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("About");
				}

			Output.WriteAttribute ("Tag", Tag);
			if (tag) {
				Output.EndElement ("About");
				}			
			}
		}

    public partial class Lazy : _Choice {
        public TOKEN<_Choice>			Name;
		public string					Tag;
        public List <_Choice>           Modifier = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Lazy;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Lazy");
				}

	        Output.WriteId ("Name", Name.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Modifier) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Lazy");
				}			
			}
		}

    public partial class Generator : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Modifier = new List<_Choice> ();

        public override CommandParseType _Tag () {
            return CommandParseType.Generator;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Generator");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Modifier) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Generator");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override CommandParseType _Tag () {
            return CommandParseType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }
//	}

//namespace Goedel.Registry {

    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Class_Start,
		Class__Namespace,				
		Class__Id,				
		Class__Entries,				
		Command_Start,
		Command__Id,				
		Command__Tag,				
		Command__Entries,				
		DefaultCommand_Start,
		Brief_Start,
		Brief__Text,				
		Parameter_Start,
		Parameter__Name,				
		Parameter__Text,				
		Parameter__Type,				
		Parameter__Modifier,				
		Parser_Start,
		Parser__Namespace,				
		Parser__Class,				
		Parser__Extension,				
		Parser__Modifier,				
		Option_Start,
		Option__Name,				
		Option__Command,				
		Option__Type,				
		Option__Modifier,				
		Script_Start,
		Script__Namespace,				
		Script__Class,				
		Script__Id,				
		Script__Extension,				
		Script__Modifier,				
		Include_Start,
		Include__Id,				
		OptionSet_Start,
		OptionSet__Id,				
		OptionSet__Options,				
		Enumerate_Start,
		Enumerate__Id,				
		Enumerate__Entries,				
		Case_Start,
		Case__Id,				
		Case__Tag,				
		Type_Start,
		Type__Id,				
		Type__Text,				
		Default_Start,
		Default__Text,				
		About_Start,
		About__Tag,				
		Lazy_Start,
		Lazy__Name,				
		Lazy__Tag,				
		Lazy__Modifier,				
		Generator_Start,
		Generator__Id,				
		Generator__Modifier,				
        }


    struct _StackItem {
        public StateCode   State;
        public CommandP._Choice     Token;
        }

    public partial class CommandParse : Goedel.Registry.Parser{
        public List <CommandP._Choice>        Top;
        public Registry	<CommandP._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        CommandP._Choice				Current;
        List <_StackItem>						Stack;
        TokenType								CurrentToken;
        Position								CurrentPosition;
        string									CurrentText;



        public CommandParse() {
            Top = new List<CommandP._Choice> () ;
            Registry = new Registry <CommandP._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__CommandType = Registry.TYPE ("CommandType"); 
			TYPE__TypeType = Registry.TYPE ("TypeType"); 
			TYPE__OptionSetType = Registry.TYPE ("OptionSetType"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 
			TYPE__PType = Registry.TYPE ("PType"); 
			TYPE__CaseType = Registry.TYPE ("CaseType"); 



            }



        public TYPE<CommandP._Choice> TYPE__CommandType ;
        public TYPE<CommandP._Choice> TYPE__TypeType ;
        public TYPE<CommandP._Choice> TYPE__OptionSetType ;
        public TYPE<CommandP._Choice> TYPE__ClassType ;
        public TYPE<CommandP._Choice> TYPE__PType ;
        public TYPE<CommandP._Choice> TYPE__CaseType ;

        private CommandP._Choice New_Choice(string Label) {
            switch (Label) {

                case "Class": return NewClass();
                case "Command": return NewCommand();
                case "DefaultCommand": return NewDefaultCommand();
                case "Brief": return NewBrief();
                case "Parameter": return NewParameter();
                case "Parser": return NewParser();
                case "Option": return NewOption();
                case "Script": return NewScript();
                case "Include": return NewInclude();
                case "OptionSet": return NewOptionSet();
                case "Enumerate": return NewEnumerate();
                case "Case": return NewCase();
                case "Type": return NewType();
                case "Default": return NewDefault();
                case "About": return NewAbout();
                case "Lazy": return NewLazy();
                case "Generator": return NewGenerator();

				}
            throw new System.Exception ("Reserved word not recognized \"" + Label + "\"");
            }



        private CommandP.Class NewClass() {
            CommandP.Class result = new CommandP.Class();
            Push (result);
            State = StateCode.Class_Start;
            return result;
            }


        private CommandP.Command NewCommand() {
            CommandP.Command result = new CommandP.Command();
            Push (result);
            State = StateCode.Command_Start;
            return result;
            }


        private CommandP.DefaultCommand NewDefaultCommand() {
            CommandP.DefaultCommand result = new CommandP.DefaultCommand();
            Push (result);
            State = StateCode.DefaultCommand_Start;
            return result;
            }


        private CommandP.Brief NewBrief() {
            CommandP.Brief result = new CommandP.Brief();
            Push (result);
            State = StateCode.Brief_Start;
            return result;
            }


        private CommandP.Parameter NewParameter() {
            CommandP.Parameter result = new CommandP.Parameter();
            Push (result);
            State = StateCode.Parameter_Start;
            return result;
            }


        private CommandP.Parser NewParser() {
            CommandP.Parser result = new CommandP.Parser();
            Push (result);
            State = StateCode.Parser_Start;
            return result;
            }


        private CommandP.Option NewOption() {
            CommandP.Option result = new CommandP.Option();
            Push (result);
            State = StateCode.Option_Start;
            return result;
            }


        private CommandP.Script NewScript() {
            CommandP.Script result = new CommandP.Script();
            Push (result);
            State = StateCode.Script_Start;
            return result;
            }


        private CommandP.Include NewInclude() {
            CommandP.Include result = new CommandP.Include();
            Push (result);
            State = StateCode.Include_Start;
            return result;
            }


        private CommandP.OptionSet NewOptionSet() {
            CommandP.OptionSet result = new CommandP.OptionSet();
            Push (result);
            State = StateCode.OptionSet_Start;
            return result;
            }


        private CommandP.Enumerate NewEnumerate() {
            CommandP.Enumerate result = new CommandP.Enumerate();
            Push (result);
            State = StateCode.Enumerate_Start;
            return result;
            }


        private CommandP.Case NewCase() {
            CommandP.Case result = new CommandP.Case();
            Push (result);
            State = StateCode.Case_Start;
            return result;
            }


        private CommandP.Type NewType() {
            CommandP.Type result = new CommandP.Type();
            Push (result);
            State = StateCode.Type_Start;
            return result;
            }


        private CommandP.Default NewDefault() {
            CommandP.Default result = new CommandP.Default();
            Push (result);
            State = StateCode.Default_Start;
            return result;
            }


        private CommandP.About NewAbout() {
            CommandP.About result = new CommandP.About();
            Push (result);
            State = StateCode.About_Start;
            return result;
            }


        private CommandP.Lazy NewLazy() {
            CommandP.Lazy result = new CommandP.Lazy();
            Push (result);
            State = StateCode.Lazy_Start;
            return result;
            }


        private CommandP.Generator NewGenerator() {
            CommandP.Generator result = new CommandP.Generator();
            Push (result);
            State = StateCode.Generator_Start;
            return result;
            }


        static CommandP.CommandParseType _Reserved(string Label) {
            switch (Label) {

                case "Class": return CommandP.CommandParseType.Class;
                case "Command": return CommandP.CommandParseType.Command;
                case "DefaultCommand": return CommandP.CommandParseType.DefaultCommand;
                case "Brief": return CommandP.CommandParseType.Brief;
                case "Parameter": return CommandP.CommandParseType.Parameter;
                case "Parser": return CommandP.CommandParseType.Parser;
                case "Option": return CommandP.CommandParseType.Option;
                case "Script": return CommandP.CommandParseType.Script;
                case "Include": return CommandP.CommandParseType.Include;
                case "OptionSet": return CommandP.CommandParseType.OptionSet;
                case "Enumerate": return CommandP.CommandParseType.Enumerate;
                case "Case": return CommandP.CommandParseType.Case;
                case "Type": return CommandP.CommandParseType.Type;
                case "Default": return CommandP.CommandParseType.Default;
                case "About": return CommandP.CommandParseType.About;
                case "Lazy": return CommandP.CommandParseType.Lazy;
                case "Generator": return CommandP.CommandParseType.Generator;

                }
            return CommandP.CommandParseType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (CommandP._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (CommandP._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new System.Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {
            CurrentToken = Token;
            CurrentPosition = Position;
            CurrentText = Text;

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new System.Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == CommandP.CommandParseType.Class)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new System.Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new System.Exception("Too Many Closing Braces");

                    case StateCode.Class_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Class Current_Cast = (CommandP.Class)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Namespace;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Class__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Class Current_Cast = (CommandP.Class)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Class__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Class__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Class__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Class Current_Cast = (CommandP.Class)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Brief) |
									(LabelType == CommandP.CommandParseType.Command) |
									(LabelType == CommandP.CommandParseType.OptionSet) |
									(LabelType == CommandP.CommandParseType.Enumerate) |
									(LabelType == CommandP.CommandParseType.Type) |
									(LabelType == CommandP.CommandParseType.About) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief Command OptionSet Enumerate Type About ]");
								}
							}
                        break;


                    case StateCode.Command_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Command Current_Cast = (CommandP.Command)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__CommandType, Current_Cast);
                            State = StateCode.Command__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Command__Id:
                        if (Token == TokenType.STRING) {
                            CommandP.Command Current_Cast = (CommandP.Command)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Command__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Command__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Command__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Command__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Command Current_Cast = (CommandP.Command)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Brief) |
									(LabelType == CommandP.CommandParseType.Parameter) |
									(LabelType == CommandP.CommandParseType.Option) |
									(LabelType == CommandP.CommandParseType.Include) |
									(LabelType == CommandP.CommandParseType.DefaultCommand) |
									(LabelType == CommandP.CommandParseType.Lazy) |
									(LabelType == CommandP.CommandParseType.Parser) |
									(LabelType == CommandP.CommandParseType.Generator) |
									(LabelType == CommandP.CommandParseType.Script) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief Parameter Option Include DefaultCommand Lazy Parser Generator Script ]");
								}
							}
                        break;


                    case StateCode.DefaultCommand_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Brief_Start:
                        if (Token == TokenType.STRING) {
                            CommandP.Brief Current_Cast = (CommandP.Brief)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Brief__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Brief__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Parameter_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Parameter Current_Cast = (CommandP.Parameter)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__PType, Current_Cast);
                            State = StateCode.Parameter__Name;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Name:
                        if (Token == TokenType.STRING) {
                            CommandP.Parameter Current_Cast = (CommandP.Parameter)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Parameter__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Parameter__Text:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Parameter Current_Cast = (CommandP.Parameter)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Parameter__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Type:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Parameter__Modifier;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Parameter__Modifier: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Parameter Current_Cast = (CommandP.Parameter)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Default) |
									(LabelType == CommandP.CommandParseType.Brief) ) {
                                Current_Cast.Modifier.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Default Brief ]");
								}
							}
                        break;


                    case StateCode.Parser_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Parser Current_Cast = (CommandP.Parser)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Parser__Namespace;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Parser__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Parser Current_Cast = (CommandP.Parser)Current;
                            Current_Cast.Class = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Parser__Class;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Parser__Class:
                        if (Token == TokenType.STRING) {
                            CommandP.Parser Current_Cast = (CommandP.Parser)Current;
                            Current_Cast.Extension = Text;
                            State = StateCode.Parser__Extension;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Parser__Extension:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Parser__Modifier;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Parser__Modifier: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Parser Current_Cast = (CommandP.Parser)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Brief) ) {
                                Current_Cast.Modifier.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief ]");
								}
							}
                        break;


                    case StateCode.Option_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Option Current_Cast = (CommandP.Option)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__PType, Current_Cast);
                            State = StateCode.Option__Name;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Option__Name:
                        if (Token == TokenType.STRING) {
                            CommandP.Option Current_Cast = (CommandP.Option)Current;
                            Current_Cast.Command = Text;
                            State = StateCode.Option__Command;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Option__Command:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Option Current_Cast = (CommandP.Option)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Option__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Option__Type:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Option__Modifier;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Option__Modifier: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Option Current_Cast = (CommandP.Option)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Default) |
									(LabelType == CommandP.CommandParseType.Brief) ) {
                                Current_Cast.Modifier.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Default Brief ]");
								}
							}
                        break;


                    case StateCode.Script_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Script Current_Cast = (CommandP.Script)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Script__Namespace;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Script__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Script Current_Cast = (CommandP.Script)Current;
                            Current_Cast.Class = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Script__Class;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Script__Class:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Script Current_Cast = (CommandP.Script)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Script__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Script__Id:
                        if (Token == TokenType.STRING) {
                            CommandP.Script Current_Cast = (CommandP.Script)Current;
                            Current_Cast.Extension = Text;
                            State = StateCode.Script__Extension;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Script__Extension:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Script__Modifier;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Script__Modifier: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Script Current_Cast = (CommandP.Script)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Brief) ) {
                                Current_Cast.Modifier.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief ]");
								}
							}
                        break;


                    case StateCode.Include_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Include Current_Cast = (CommandP.Include)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__OptionSetType, Current_Cast);
                            State = StateCode.Include__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Include__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OptionSet_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.OptionSet Current_Cast = (CommandP.OptionSet)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__OptionSetType, Current_Cast);
                            State = StateCode.OptionSet__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.OptionSet__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.OptionSet__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.OptionSet__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.OptionSet Current_Cast = (CommandP.OptionSet)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Option) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Option ]");
								}
							}
                        break;


                    case StateCode.Enumerate_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Enumerate Current_Cast = (CommandP.Enumerate)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Enumerate__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Enumerate__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enumerate__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enumerate__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            CommandP.Enumerate Current_Cast = (CommandP.Enumerate)Current;
                            Current_Cast.Entries.Add (NewCase ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Case_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Case Current_Cast = (CommandP.Case)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__CaseType, Current_Cast);
                            State = StateCode.Case__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Case__Id:
                        if (Token == TokenType.STRING) {
                            CommandP.Case Current_Cast = (CommandP.Case)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Case__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Case__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Type_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Type Current_Cast = (CommandP.Type)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Type__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Type__Id:
                        if (Token == TokenType.STRING) {
                            CommandP.Type Current_Cast = (CommandP.Type)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Type__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Type__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Default_Start:
                        if (Token == TokenType.STRING) {
                            CommandP.Default Current_Cast = (CommandP.Default)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Default__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Default__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.About_Start:
                        if (Token == TokenType.STRING) {
                            CommandP.About Current_Cast = (CommandP.About)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.About__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.About__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Lazy_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Lazy Current_Cast = (CommandP.Lazy)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__PType, Current_Cast);
                            State = StateCode.Lazy__Name;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Lazy__Name:
                        if (Token == TokenType.STRING) {
                            CommandP.Lazy Current_Cast = (CommandP.Lazy)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Lazy__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Lazy__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Lazy__Modifier;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Lazy__Modifier: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Lazy Current_Cast = (CommandP.Lazy)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Brief) ) {
                                Current_Cast.Modifier.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief ]");
								}
							}
                        break;


                    case StateCode.Generator_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            CommandP.Generator Current_Cast = (CommandP.Generator)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Generator__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Generator__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Generator__Modifier;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Generator__Modifier: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							CommandP.Generator Current_Cast = (CommandP.Generator)Current;
                            CommandP.CommandParseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == CommandP.CommandParseType.Brief) ) {
                                Current_Cast.Modifier.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief ]");
								}
							}
                        break;



                    default:
                        throw new System.Exception("Unreachable code reached");
                    }
                }
            }
        }
	}


