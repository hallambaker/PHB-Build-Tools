#script 1.0
#license MITLicense
#using Goedel.Utilities
#pclass Goedel.Tool.Yaschema Generate


#method GenerateCS YaschemaStruct Yaschema
#% Registry.Boilerplate.License(_Output, "//  ", "MITLicense");
#% Registry.Boilerplate.Header(_Output, "//  ", DateTime.Now);

using System;
using System.IO;
using System.Net;
using System.Collections.Generic;
using Goedel.Cryptography;
using Goedel.Cryptography.Dare;
using Goedel.Utilities;
using Goedel.Protocol;
using System.Threading.Tasks;


namespace #{Yaschema.NameSpaceName} {

	/// <summary>
    /// Client connection class. Tracks the state of a client connection.
    /// </summary>
    public partial class ConnectionClient : Connection {

#filter Client client Yaschema.Top

#foreach (var packet in client.Entries)
#call GenersateSerializer packet
#end foreach
#end filter

#filter Host host Yaschema.Top
#foreach (var packet in host.Entries)
#% GenerateParser (packet, false);
#end foreach
#end filter


		}

    public partial class ConnectionHost : Connection {

#filter Host host Yaschema.Top
#foreach (var packet in host.Entries)
#call GenersateSerializer packet
#end foreach
#end filter

#filter Client client Yaschema.Top
#foreach (var packet in client.Entries)
#if (packet.IsInitial)
        // Skip Client packet #{packet.Id} (initial packets parsed by the listener)
#else 
#% GenerateParser (packet, false);
#end if
#end foreach
#end filter
#filter Client client Yaschema.Top
#foreach (var packet in client.Entries)
#if (packet.Completer)

        /// <summary>
        /// Perform key exchanges and complete parsing of the packet
        /// </summary>
        public void Complete#{packet.Id} (#{packet.ClassName} result) {
            var outerReader = result.Reader;
#call ParseMezzanine packet
            }
#end if
#end foreach
#end filter
		}


    public partial class Listener {
#filter Client client Yaschema.Top
#foreach (var packet in client.Entries)
#if (packet.IsInitial)
#% GenerateParser (packet, true);
#end if
#end foreach
#end filter
		}

#foreach (var packet in Yaschema.Packets)

    /// <summary>
    /// Parsed #{packet.Id} packet
    /// </summary>   
    public partial class #{packet.ClassName} : Packet {
#call GeneratePacket packet
        }

#end foreach
	}


#end method

#method GenersateSerializer Packet packet
#% var plaintext = packet.Plaintext;
#% var mezzanine = packet.Mezzanine;
        // Serialize #{packet.PacketType} packet #{packet.Id}

        /// <summary>
        /// Create a serialised packet of type #{packet.Id} packet.
        /// </summary>
        /// <param name="payload">The payload data.</param>
        /// <param name="plaintextExtensionsIn">Additional extensions to be presented 
        /// in the plaintext segment.</param>
#if (packet.HasMezzanine)
        /// <param name="mezanineExtensionsIn">Additional extensions to be presented
        /// in the mezzanine segment.</param>
#end if
#if (packet.HasEncrypted)
        /// <param name="ciphertextExtensions">Additional extensions to be presented 
        /// in the encrypted segment.</param>
#end if
        /// <returns>The serialized data.</returns>
        public byte[] Serialize#{packet.Id} (
                byte[] payload = null,
                List<PacketExtension> plaintextExtensionsIn = null#!
#if (packet.HasMezzanine)
,
                List<PacketExtension> mezanineExtensionsIn = null#!
#end if
#if (packet.HasEncrypted)
,
                List<PacketExtension> ciphertextExtensions = null#!
#end if
                ) {

            // The plaintext part
            var outerWriter = new PacketWriterAesGcm();
#if (plaintext == null)
            // There are no plaintext fields.
            outerWriter.WriteExtensions(plaintextExtensionsIn);
#else
            // Plaintext fields..
#if (plaintext.AddExtensions)
            var plaintextExtensions = new List<PacketExtension>();
#end if
#if (plaintext.Ephemeral)
            ClientKeyExchange (out var ephemeral, out var clientKeyId);
            outerWriter.Write (clientKeyId);
            outerWriter.Write (ephemeral);
#elseif (plaintext.KeyId)
            ClientKeyExchange (out var clientKeyId);
            outerWriter.Write (clientKeyId);
#end if
#if (plaintext.Ephemerals)
            AddEphemerals (plaintextExtensions);
#end if
#if (plaintext.Challenge)
            AddChallenge (plaintextExtensions);
#elseif (plaintext.Response)
            AddResponse (plaintextExtensions);
#end if
#if (plaintext.Credential)
            AddCredentials (plaintextExtensions);
#end if
#if (plaintext.AddExtensions)
            plaintextExtensions.AddRangeSafe(plaintextExtensionsIn);
            outerWriter.WriteExtensions(plaintextExtensions);
#else
            outerWriter.WriteExtensions(plaintextExtensionsIn);
#end if
#end if


#if (packet.HasMezzanine) 
            // Mezzanine
            var mezanineWriter = new PacketWriterAesGcm(outerWriter.RemainingSpace);
#if (mezzanine.AddExtensions)
            var mezanineExtensions = new List<PacketExtension>();
#end if  
#if (mezzanine.Ephemeral)
            MutualKeyExchange (out var ephemeral, out var hostKeyId);
            mezanineWriter.Write (hostKeyId);
            mezanineWriter.Write (ephemeral);
#elseif (mezzanine.KeyId)
            MutualKeyExchange (out var hostKeyId);
            mezanineWriter.Write (hostKeyId);
#end if  
#if (mezzanine.Credential)
            AddCredentials (mezanineExtensions);
#end if
#if (mezzanine.AddExtensions)
            mezanineExtensions.AddRangeSafe(mezanineExtensionsIn);
            mezanineWriter.WriteExtensions(mezanineExtensions);
#else
            mezanineWriter.WriteExtensions(plaintextExtensionsIn);
#end if
#if (packet.HasEncrypted) 
            // Encrypted inside Mezzanine
            var innerWriter = new PacketWriter(mezanineWriter.RemainingSpace);
            innerWriter.WriteExtensions(ciphertextExtensions);
            innerWriter.Write(payload);
            mezanineWriter.Encrypt(MutualKeyOut, innerWriter);
#else
            mezanineWriter.Write(payload);
#end if
            outerWriter.Encrypt(ClientKeyOut, mezanineWriter);
#elseif (packet.HasEncrypted) 
            // Encrypted in plaintext
            var innerWriter = new PacketWriter(outerWriter.RemainingSpace);
            innerWriter.WriteExtensions(ciphertextExtensions);
            innerWriter.Write(payload);
            outerWriter.Encrypt(MutualKeyOut, innerWriter);
#else
            // Only have plaintext
            outerWriter.Write(payload);
#end if

            // Return the outermost packet
            return outerWriter.Packet;
            }

#end method

#method2 GenerateParser Packet packet bool isstatic
#% var plaintext = packet.Plaintext;
#% var mezzanine = packet.Mezzanine;

        /// <summary>
        /// Parse the packet <paramref name="packet"/> received from <paramref name="sourceId"/>
        /// as a #{packet.Id} packet.
        /// </summary>
        /// <param name="sourceId">The packet source.</param>
        /// <param name="packet">The packet data</param>
        /// <returns>The parsed packet.</returns>

        public #{isstatic.If("static")} #{packet.ClassName} Parse#{packet.Id} (PortId sourceId, byte[] packet) {
            var result = new #{packet.ClassName} () {
                SourcePortId = sourceId
                };

            // The plaintext part
            var outerReader = new PacketReaderAesGcm(packet);
#if (packet.HasPlaintext) 
#if (plaintext.Ephemeral)
            result.HostKeyId = outerReader.ReadString ();
            result.ClientEphemeral = outerReader.ReadBinary ();
#elseif (plaintext.KeyId)
            result.HostKeyId = outerReader.ReadString ();
#end if
#end if
            result.PlaintextExtensions = outerReader.ReadExtensions();
#if (packet.HasPlaintext) 
#if (plaintext.Credential)
            CredentialOther = CredentialSelf.GetCredentials (result.PlaintextExtensions);
#end if
#end if
#if (packet.Completer)
            // Parsing the inner packet is deferred until plaintext is parsed.
            result.Reader = outerReader;
#else
#call ParseMezzanine packet
#end if

            return result;
            }
#end method2

#method ParseMezzanine Packet packet
#% var plaintext = packet.Plaintext;
#% var mezzanine = packet.Mezzanine;
#if (packet.HasPlaintext) 
#if (plaintext.Ephemeral)
            ClientKeyExchange (result.ClientEphemeral, result.HostKeyId);
#elseif (plaintext.KeyId)
            ClientKeyExchange (result.HostKeyId);
#end if
#end if
#if (packet.HasMezzanine) 
            // Mezzanine
            var mezanineReader = outerReader.Decrypt (ClientKeyIn);
#if (mezzanine.Ephemeral)
            result.ClientKeyId = outerReader.ReadString ();
            result.HostEphemeral = outerReader.ReadBinary ();
            MutualKeyExchange (result.HostEphemeral, result.ClientKeyId);
#elseif (mezzanine.KeyId)
            result.ClientKeyId = outerReader.ReadString ();
            MutualKeyExchange (result.ClientKeyId);
#end if
            result.MezzanineExtensions = mezanineReader.ReadExtensions();
#if (mezzanine.Credential)
            CredentialOther = CredentialSelf.GetCredentials (result.MezzanineExtensions);
#end if
#if (packet.HasEncrypted) 
            // Encrypted inside Mezzanine
            var innerReader = mezanineReader.Decrypt (MutualKeyIn);
            result.CiphertextExtensions = innerReader.ReadExtensions();
            result.Payload = innerReader.ReadBinary();
#else
            result.Payload = mezanineReader.ReadBinary();
#end if
#elseif (packet.HasEncrypted) 
            // Encrypted inside Mezzanine
            var innerReader = mezanineReader.Decrypt (MutualKeyIn);
            result.CiphertextExtensions = innerReader.ReadExtensions();
            result.Payload = innerReader.ReadBinary();
#else
            // Only have plaintext
            result.Payload = outerReader.ReadBinary();
#end if
#end method

#method GeneratePacket Packet packet
#% var plaintext = packet.Plaintext;
#% var mezzanine = packet.Mezzanine;

#if (packet.Completer)
        ///<summary>Packet reader used to complete reading of the packet.</summary> 
        public PacketReader Reader{ get; set; }
#end if
#if (packet.HasMezzanine) 
        ///<summary>Options specified in the packet mezzanine.</summary> 
        public List<PacketExtension> MezzanineExtensions{ get; set; }
#end if
#if (packet.HasEncrypted)
        ///<summary>Options specified in the packet ciphertext.</summary> 
        public List<PacketExtension> CiphertextExtensions { get; set; }
#end if

#if (packet.HasPlaintext) 
#if (plaintext.Ephemeral)
        ///<summary>Host chosen ephemeral key.</summary> 
        public byte[] ClientEphemeral  { get; set; }
#end if
#if (plaintext.KeyId)
        ///<summary>Client Key Identifier.</summary> 
        public string HostKeyId { get; set; }
#end if
#end if

#if (packet.HasMezzanine) 
#if (mezzanine.Ephemeral)
        ///<summary>Client chosen ephemeral key.</summary> 
        public byte[] HostEphemeral  { get; set; }
#end if
#if (mezzanine.KeyId)
        ///<summary>Host Key Identifier.</summary> 
        public string ClientKeyId { get; set; }
#end if
#end if


#end method


#method GenerateMD YaschemaStruct YaschemaStruct

#end method

#end pclass
