
//  Copyright (c) 2015 by Phillip Hallam-Baker
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;




//
// Namespace Goedel.Document.Markdown.Tags
// Class MarkSchema
//


// Types
//   TopTypeType
//       Class
//   TypeType
//       Meta
//       Item
//       Annotation
//       Layout
//       Block
//       Remark
//       Format
//       Flag
//       String
//       Integer
//       Markup
//       XML
//       Stack
//       Wrap
//       Any
//       Level
//       Default
//       Entry
//       XEmpty
//       TValue
//       XStart
//       XClose
//       Template
//       XString
//   IdType
//       ElementID
//       AttributeID
//       FormatID
//   NamespaceType
//       Goedel.Document.Markdown.Tags
//   ClassType
//       MarkSchema
//   NameType
//       Namespace
//       Name
//       Entries
//       TBS
//       Id
//       Start
//       Start1
//       End
//       Tag
//       First
//       Value
//       Wrapper
//       Text
//       Strings
//       Label
//       Attributes
//   TokenType
//       NamespaceType
//       ClassType
//       FormatField

#pragma warning disable IDE0022, IDE0066, IDE1006, IDE0059
namespace Goedel.Document.Markdown.Tags {


    public enum MarkSchemaType {
        _Top,

        Class,
        Meta,
        Layout,
        Block,
        Annotation,
        Item,
        Markup,
        XML,
        Default,
        Stack,
        Wrap,
        Level,
        Remark,
        Start,
        End,
        String,
        Flag,
        Integer,
        Format,
        Entry,
        XEmpty,
        XStart,
        XClose,
        Template,
        TValue,
        XString,
        Any,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public MarkSchemaType _Tag ();

        public _Choice _Parent;
        public MarkSchema _Base;

		public abstract void Serialize (StructureWriter Output, bool tag);

    	public virtual void Init (_Choice parent) {
            _Parent = parent;
            _Base ??= parent?._Base;
			}

        

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice parent) {
			Init (parent);
            _Base = parent._Base;
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Class : _Choice {
        public TOKEN<_Choice>			Namespace;
        public TOKEN<_Choice>			Name;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.Class;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Class");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Name", Name.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Class");
				}			
			}
		}

    public partial class Meta : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.Meta;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Meta");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Meta");
				}			
			}
		}

    public partial class Layout : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.Layout;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Layout");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Layout");
				}			
			}
		}

    public partial class Block : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.Block;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Block");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Block");
				}			
			}
		}

    public partial class Annotation : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.Annotation;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Annotation");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Annotation");
				}			
			}
		}

    public partial class Item : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.Item;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Item");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Item");
				}			
			}
		}

    public partial class Markup : _Choice {
		public string					Start;
		public string					Start1;
		public string					End;

        public override MarkSchemaType _Tag () =>MarkSchemaType.Markup;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Markup");
				}

			Output.WriteAttribute ("Start", Start);
			Output.WriteAttribute ("Start1", Start1);
			Output.WriteAttribute ("End", End);
			if (tag) {
				Output.EndElement ("Markup");
				}			
			}
		}

    public partial class XML : _Choice {
		public string					Tag;
		public string					First;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.XML;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("XML");
				}

			Output.WriteAttribute ("Tag", Tag);
			Output.WriteAttribute ("First", First);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("XML");
				}			
			}
		}

    public partial class Default : _Choice {
		public string					Tag;
		public string					Value;

        public override MarkSchemaType _Tag () =>MarkSchemaType.Default;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Default");
				}

			Output.WriteAttribute ("Tag", Tag);
			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Default");
				}			
			}
		}

    public partial class Stack : _Choice {
        public REF<_Choice>				Wrapper;

        public override MarkSchemaType _Tag () =>MarkSchemaType.Stack;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Stack");
				}

	        Output.WriteId ("Wrapper", Wrapper.ToString());
			if (tag) {
				Output.EndElement ("Stack");
				}			
			}
		}

    public partial class Wrap : _Choice {
        public REF<_Choice>				Wrapper;

        public override MarkSchemaType _Tag () =>MarkSchemaType.Wrap;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Wrap");
				}

	        Output.WriteId ("Wrapper", Wrapper.ToString());
			if (tag) {
				Output.EndElement ("Wrap");
				}			
			}
		}

    public partial class Level : _Choice {
		public int						Value;

        public override MarkSchemaType _Tag () =>MarkSchemaType.Level;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Level");
				}

			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Level");
				}			
			}
		}

    public partial class Remark : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override MarkSchemaType _Tag () =>MarkSchemaType.Remark;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Remark");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("Remark");
				}			
			}
		}

    public partial class Start : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override MarkSchemaType _Tag () =>MarkSchemaType.Start;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Start");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("Start");
				}			
			}
		}

    public partial class End : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override MarkSchemaType _Tag () =>MarkSchemaType.End;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("End");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("End");
				}			
			}
		}

    public partial class String : _Choice {
        public ID<_Choice>				Id; 

        public override MarkSchemaType _Tag () =>MarkSchemaType.String;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class Flag : _Choice {
        public ID<_Choice>				Id; 

        public override MarkSchemaType _Tag () =>MarkSchemaType.Flag;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Flag");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			if (tag) {
				Output.EndElement ("Flag");
				}			
			}
		}

    public partial class Integer : _Choice {
        public ID<_Choice>				Id; 

        public override MarkSchemaType _Tag () =>MarkSchemaType.Integer;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Integer");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			if (tag) {
				Output.EndElement ("Integer");
				}			
			}
		}

    public partial class Format : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.Format;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Format");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Format");
				}			
			}
		}

    public partial class Entry : _Choice {
        public TOKEN<_Choice>			Id;
		public List <System.String>			Strings = new List <System.String> (); 

        public override MarkSchemaType _Tag () =>MarkSchemaType.Entry;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Entry");
				}

	        Output.WriteId ("Id", Id.ToString());
			foreach (string _s in Strings) {
				Output.WriteAttribute ("Strings",_s);
				}
			if (tag) {
				Output.EndElement ("Entry");
				}			
			}
		}

    public partial class XEmpty : _Choice {
		public string					Label;
        public List <TValue>           Attributes = new List<TValue> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.XEmpty;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Attributes) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("XEmpty");
				}

			Output.WriteAttribute ("Label", Label);
			Output.StartList ("");
			foreach (TValue _e in Attributes) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("XEmpty");
				}			
			}
		}

    public partial class XStart : _Choice {
		public string					Label;
        public List <TValue>           Attributes = new List<TValue> ();

        public override MarkSchemaType _Tag () =>MarkSchemaType.XStart;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Attributes) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("XStart");
				}

			Output.WriteAttribute ("Label", Label);
			Output.StartList ("");
			foreach (TValue _e in Attributes) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("XStart");
				}			
			}
		}

    public partial class XClose : _Choice {

        public override MarkSchemaType _Tag () =>MarkSchemaType.XClose;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("XClose");
				}

			if (tag) {
				Output.EndElement ("XClose");
				}			
			}
		}

    public partial class Template : _Choice {
		public string					Text;

        public override MarkSchemaType _Tag () =>MarkSchemaType.Template;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Template");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Template");
				}			
			}
		}

    public partial class TValue : _Choice {
		public string					Tag;
		public string					Value;

        public override MarkSchemaType _Tag () =>MarkSchemaType.TValue;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("TValue");
				}

			Output.WriteAttribute ("Tag", Tag);
			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("TValue");
				}			
			}
		}

    public partial class XString : _Choice {
		public string					Text;

        public override MarkSchemaType _Tag () =>MarkSchemaType.XString;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("XString");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("XString");
				}			
			}
		}

    public partial class Any : _Choice {

        public override MarkSchemaType _Tag () =>MarkSchemaType.Any;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Any");
				}

			if (tag) {
				Output.EndElement ("Any");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() =>  Label = null;

        public override MarkSchemaType _Tag () => MarkSchemaType._Label;

		public override void Serialize (StructureWriter Output, bool tag) =>Output.WriteId ("ID", Label.ToString());
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Class_Start,
		Class__Namespace,				
		Class__Name,				
		Class__Entries,				
		Meta_Start,
		Meta__TBS,				
		Meta__Id,				
		Meta__Entries,				
		Layout_Start,
		Layout__Id,				
		Layout__Entries,				
		Block_Start,
		Block__Id,				
		Block__Entries,				
		Annotation_Start,
		Annotation__Id,				
		Annotation__Entries,				
		Item_Start,
		Item__Id,				
		Item__Entries,				
		Markup_Start,
		Markup__Start,				
		Markup__Start1,				
		Markup__End,				
		XML_Start,
		XML__Tag,				
		XML__First,				
		XML__Entries,				
		Default_Start,
		Default__Tag,				
		Default__Value,				
		Stack_Start,
		Stack__Wrapper,				
		Wrap_Start,
		Wrap__Wrapper,				
		Level_Start,
		Level__Value,				
		Remark_Start,
		Remark__Text,				
		Start_Start,
		Start__Text,				
		End_Start,
		End__Text,				
		String_Start,
		String__Id,				
		Flag_Start,
		Flag__Id,				
		Integer_Start,
		Integer__Id,				
		Format_Start,
		Format__Id,				
		Format__Entries,				
		Entry_Start,
		Entry__Id,				
		Entry__Strings,				
		XEmpty_Start,
		XEmpty__Label,				
		XEmpty__Attributes,				
		XStart_Start,
		XStart__Label,				
		XStart__Attributes,				
		XClose_Start,
		Template_Start,
		Template__Text,				
		TValue_Start,
		TValue__Tag,				
		TValue__Value,				
		XString_Start,
		XString__Text,				
		Any_Start,
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Document.Markdown.Tags._Choice     Token;
        }

    public partial class MarkSchema : Goedel.Registry.Parser{
        public List <Goedel.Document.Markdown.Tags._Choice>        Top;
        public Registry	<Goedel.Document.Markdown.Tags._Choice>	Registry;

        public bool StartOfEntry {get;  private set;}

        StateCode								State;
        Goedel.Document.Markdown.Tags._Choice				Current;
        List <_StackItem>						Stack;


        public static MarkSchema Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new MarkSchema() {
				Options = Options
				};

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
            Result.Init ();
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
                Entry._Base = this;
				Entry._InitChildren (null);
				}
			}

        public MarkSchema() {
            Top = new List<Goedel.Document.Markdown.Tags._Choice> () ;
            Registry = new Registry <Goedel.Document.Markdown.Tags._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            StartOfEntry = true;

			TYPE__ElementID = Registry.TYPE ("ElementID"); 
			TYPE__AttributeID = Registry.TYPE ("AttributeID"); 
			TYPE__FormatID = Registry.TYPE ("FormatID"); 
			TYPE__NamespaceType = Registry.TYPE ("NamespaceType"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 
			TYPE__FormatField = Registry.TYPE ("FormatField"); 



            }



        public TYPE<Goedel.Document.Markdown.Tags._Choice> TYPE__ElementID ;
        public TYPE<Goedel.Document.Markdown.Tags._Choice> TYPE__AttributeID ;
        public TYPE<Goedel.Document.Markdown.Tags._Choice> TYPE__FormatID ;
        public TYPE<Goedel.Document.Markdown.Tags._Choice> TYPE__NamespaceType ;
        public TYPE<Goedel.Document.Markdown.Tags._Choice> TYPE__ClassType ;
        public TYPE<Goedel.Document.Markdown.Tags._Choice> TYPE__FormatField ;

        private Goedel.Document.Markdown.Tags._Choice New_Choice(string Label) {
            switch (Label) {

                case "Class": return NewClass();
                case "Meta": return NewMeta();
                case "Layout": return NewLayout();
                case "Block": return NewBlock();
                case "Annotation": return NewAnnotation();
                case "Item": return NewItem();
                case "Markup": return NewMarkup();
                case "XML": return NewXML();
                case "Default": return NewDefault();
                case "Stack": return NewStack();
                case "Wrap": return NewWrap();
                case "Level": return NewLevel();
                case "Remark": return NewRemark();
                case "Start": return NewStart();
                case "End": return NewEnd();
                case "String": return NewString();
                case "Flag": return NewFlag();
                case "Integer": return NewInteger();
                case "Format": return NewFormat();
                case "Entry": return NewEntry();
                case "XEmpty": return NewXEmpty();
                case "XStart": return NewXStart();
                case "XClose": return NewXClose();
                case "Template": return NewTemplate();
                case "TValue": return NewTValue();
                case "XString": return NewXString();
                case "Any": return NewAny();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Document.Markdown.Tags.Class NewClass() {
            Goedel.Document.Markdown.Tags.Class result = new Goedel.Document.Markdown.Tags.Class();
            Push (result);
            State = StateCode.Class_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Meta NewMeta() {
            Goedel.Document.Markdown.Tags.Meta result = new Goedel.Document.Markdown.Tags.Meta();
            Push (result);
            State = StateCode.Meta_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Layout NewLayout() {
            Goedel.Document.Markdown.Tags.Layout result = new Goedel.Document.Markdown.Tags.Layout();
            Push (result);
            State = StateCode.Layout_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Block NewBlock() {
            Goedel.Document.Markdown.Tags.Block result = new Goedel.Document.Markdown.Tags.Block();
            Push (result);
            State = StateCode.Block_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Annotation NewAnnotation() {
            Goedel.Document.Markdown.Tags.Annotation result = new Goedel.Document.Markdown.Tags.Annotation();
            Push (result);
            State = StateCode.Annotation_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Item NewItem() {
            Goedel.Document.Markdown.Tags.Item result = new Goedel.Document.Markdown.Tags.Item();
            Push (result);
            State = StateCode.Item_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Markup NewMarkup() {
            Goedel.Document.Markdown.Tags.Markup result = new Goedel.Document.Markdown.Tags.Markup();
            Push (result);
            State = StateCode.Markup_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.XML NewXML() {
            Goedel.Document.Markdown.Tags.XML result = new Goedel.Document.Markdown.Tags.XML();
            Push (result);
            State = StateCode.XML_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Default NewDefault() {
            Goedel.Document.Markdown.Tags.Default result = new Goedel.Document.Markdown.Tags.Default();
            Push (result);
            State = StateCode.Default_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Stack NewStack() {
            Goedel.Document.Markdown.Tags.Stack result = new Goedel.Document.Markdown.Tags.Stack();
            Push (result);
            State = StateCode.Stack_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Wrap NewWrap() {
            Goedel.Document.Markdown.Tags.Wrap result = new Goedel.Document.Markdown.Tags.Wrap();
            Push (result);
            State = StateCode.Wrap_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Level NewLevel() {
            Goedel.Document.Markdown.Tags.Level result = new Goedel.Document.Markdown.Tags.Level();
            Push (result);
            State = StateCode.Level_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Remark NewRemark() {
            Goedel.Document.Markdown.Tags.Remark result = new Goedel.Document.Markdown.Tags.Remark();
            Push (result);
            State = StateCode.Remark_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Start NewStart() {
            Goedel.Document.Markdown.Tags.Start result = new Goedel.Document.Markdown.Tags.Start();
            Push (result);
            State = StateCode.Start_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.End NewEnd() {
            Goedel.Document.Markdown.Tags.End result = new Goedel.Document.Markdown.Tags.End();
            Push (result);
            State = StateCode.End_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.String NewString() {
            Goedel.Document.Markdown.Tags.String result = new Goedel.Document.Markdown.Tags.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Flag NewFlag() {
            Goedel.Document.Markdown.Tags.Flag result = new Goedel.Document.Markdown.Tags.Flag();
            Push (result);
            State = StateCode.Flag_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Integer NewInteger() {
            Goedel.Document.Markdown.Tags.Integer result = new Goedel.Document.Markdown.Tags.Integer();
            Push (result);
            State = StateCode.Integer_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Format NewFormat() {
            Goedel.Document.Markdown.Tags.Format result = new Goedel.Document.Markdown.Tags.Format();
            Push (result);
            State = StateCode.Format_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Entry NewEntry() {
            Goedel.Document.Markdown.Tags.Entry result = new Goedel.Document.Markdown.Tags.Entry();
            Push (result);
            State = StateCode.Entry_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.XEmpty NewXEmpty() {
            Goedel.Document.Markdown.Tags.XEmpty result = new Goedel.Document.Markdown.Tags.XEmpty();
            Push (result);
            State = StateCode.XEmpty_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.XStart NewXStart() {
            Goedel.Document.Markdown.Tags.XStart result = new Goedel.Document.Markdown.Tags.XStart();
            Push (result);
            State = StateCode.XStart_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.XClose NewXClose() {
            Goedel.Document.Markdown.Tags.XClose result = new Goedel.Document.Markdown.Tags.XClose();
            Push (result);
            State = StateCode.XClose_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Template NewTemplate() {
            Goedel.Document.Markdown.Tags.Template result = new Goedel.Document.Markdown.Tags.Template();
            Push (result);
            State = StateCode.Template_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.TValue NewTValue() {
            Goedel.Document.Markdown.Tags.TValue result = new Goedel.Document.Markdown.Tags.TValue();
            Push (result);
            State = StateCode.TValue_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.XString NewXString() {
            Goedel.Document.Markdown.Tags.XString result = new Goedel.Document.Markdown.Tags.XString();
            Push (result);
            State = StateCode.XString_Start;
            return result;
            }


        private Goedel.Document.Markdown.Tags.Any NewAny() {
            Goedel.Document.Markdown.Tags.Any result = new Goedel.Document.Markdown.Tags.Any();
            Push (result);
            State = StateCode.Any_Start;
            return result;
            }


        static Goedel.Document.Markdown.Tags.MarkSchemaType _Reserved(string Label) {
            switch (Label) {

                case "Class": return Goedel.Document.Markdown.Tags.MarkSchemaType.Class;
                case "Meta": return Goedel.Document.Markdown.Tags.MarkSchemaType.Meta;
                case "Layout": return Goedel.Document.Markdown.Tags.MarkSchemaType.Layout;
                case "Block": return Goedel.Document.Markdown.Tags.MarkSchemaType.Block;
                case "Annotation": return Goedel.Document.Markdown.Tags.MarkSchemaType.Annotation;
                case "Item": return Goedel.Document.Markdown.Tags.MarkSchemaType.Item;
                case "Markup": return Goedel.Document.Markdown.Tags.MarkSchemaType.Markup;
                case "XML": return Goedel.Document.Markdown.Tags.MarkSchemaType.XML;
                case "Default": return Goedel.Document.Markdown.Tags.MarkSchemaType.Default;
                case "Stack": return Goedel.Document.Markdown.Tags.MarkSchemaType.Stack;
                case "Wrap": return Goedel.Document.Markdown.Tags.MarkSchemaType.Wrap;
                case "Level": return Goedel.Document.Markdown.Tags.MarkSchemaType.Level;
                case "Remark": return Goedel.Document.Markdown.Tags.MarkSchemaType.Remark;
                case "Start": return Goedel.Document.Markdown.Tags.MarkSchemaType.Start;
                case "End": return Goedel.Document.Markdown.Tags.MarkSchemaType.End;
                case "String": return Goedel.Document.Markdown.Tags.MarkSchemaType.String;
                case "Flag": return Goedel.Document.Markdown.Tags.MarkSchemaType.Flag;
                case "Integer": return Goedel.Document.Markdown.Tags.MarkSchemaType.Integer;
                case "Format": return Goedel.Document.Markdown.Tags.MarkSchemaType.Format;
                case "Entry": return Goedel.Document.Markdown.Tags.MarkSchemaType.Entry;
                case "XEmpty": return Goedel.Document.Markdown.Tags.MarkSchemaType.XEmpty;
                case "XStart": return Goedel.Document.Markdown.Tags.MarkSchemaType.XStart;
                case "XClose": return Goedel.Document.Markdown.Tags.MarkSchemaType.XClose;
                case "Template": return Goedel.Document.Markdown.Tags.MarkSchemaType.Template;
                case "TValue": return Goedel.Document.Markdown.Tags.MarkSchemaType.TValue;
                case "XString": return Goedel.Document.Markdown.Tags.MarkSchemaType.XString;
                case "Any": return Goedel.Document.Markdown.Tags.MarkSchemaType.Any;

                }
            return Goedel.Document.Markdown.Tags.MarkSchemaType._Bottom;
            }


		public void Serialize (TextWriter Output)=> Serialize (Output, OutputFormat.Goedel);

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Document.Markdown.Tags._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Document.Markdown.Tags._Choice Token) {
            _StackItem Item = new _StackItem () {
					State = State,
					Token = Current
					};

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.AssertFalse (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.AssertFalse (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Class)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) { 
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Class_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Class Current_Cast = (Goedel.Document.Markdown.Tags.Class)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Class__Namespace;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Class__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Class Current_Cast = (Goedel.Document.Markdown.Tags.Class)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Name;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Class__Name:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Class__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Class__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.Class Current_Cast = (Goedel.Document.Markdown.Tags.Class)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Meta) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Item) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Annotation) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Layout) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Block) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Remark) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Format) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Meta Item Annotation Layout Block Remark Format ]");
								}
							}
                        break;


                    case StateCode.Meta_Start:

                    case StateCode.Meta__TBS:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Meta Current_Cast = (Goedel.Document.Markdown.Tags.Meta)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ElementID, Current_Cast);
                            State = StateCode.Meta__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Meta__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Meta__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Meta__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.Meta Current_Cast = (Goedel.Document.Markdown.Tags.Meta)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Flag) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.String) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Remark) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Integer) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Meta) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Flag String Remark Integer Meta ]");
								}
							}
                        break;


                    case StateCode.Layout_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Layout Current_Cast = (Goedel.Document.Markdown.Tags.Layout)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ElementID, Current_Cast);
                            State = StateCode.Layout__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Layout__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Layout__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Layout__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.Layout Current_Cast = (Goedel.Document.Markdown.Tags.Layout)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Flag) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.String) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Remark) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Integer) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Layout) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Markup) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.XML) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Stack) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Wrap) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Any) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Flag String Remark Integer Layout Markup XML Stack Wrap Any ]");
								}
							}
                        break;


                    case StateCode.Block_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Block Current_Cast = (Goedel.Document.Markdown.Tags.Block)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ElementID, Current_Cast);
                            State = StateCode.Block__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Block__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Block__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Block__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.Block Current_Cast = (Goedel.Document.Markdown.Tags.Block)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Flag) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.String) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Remark) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Integer) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Markup) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Level) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.XML) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Stack) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Wrap) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Flag String Remark Integer Markup Level XML Stack Wrap ]");
								}
							}
                        break;


                    case StateCode.Annotation_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Annotation Current_Cast = (Goedel.Document.Markdown.Tags.Annotation)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ElementID, Current_Cast);
                            State = StateCode.Annotation__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Annotation__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Annotation__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Annotation__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.Annotation Current_Cast = (Goedel.Document.Markdown.Tags.Annotation)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Flag) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.String) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Remark) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Integer) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Markup) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.XML) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Flag String Remark Integer Markup XML ]");
								}
							}
                        break;


                    case StateCode.Item_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Item Current_Cast = (Goedel.Document.Markdown.Tags.Item)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ElementID, Current_Cast);
                            State = StateCode.Item__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Item__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Item__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Item__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.Item Current_Cast = (Goedel.Document.Markdown.Tags.Item)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Flag) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.String) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Remark) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Integer) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Markup) |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.XML) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Flag String Remark Integer Markup XML ]");
								}
							}
                        break;


                    case StateCode.Markup_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.Markup Current_Cast = (Goedel.Document.Markdown.Tags.Markup)Current;
                            Current_Cast.Start = Text;
                            State = StateCode.Markup__Start;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Markup__Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.Markup Current_Cast = (Goedel.Document.Markdown.Tags.Markup)Current;
                            Current_Cast.Start1 = Text;
                            State = StateCode.Markup__Start1;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Markup__Start1:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.Markup Current_Cast = (Goedel.Document.Markdown.Tags.Markup)Current;
                            Current_Cast.End = Text;
                            State = StateCode.Markup__End;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Markup__End:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.XML_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.XML Current_Cast = (Goedel.Document.Markdown.Tags.XML)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.XML__Tag;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.XML__Tag:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.XML Current_Cast = (Goedel.Document.Markdown.Tags.XML)Current;
                            Current_Cast.First = Text;
                            State = StateCode.XML__First;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.XML__First:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.XML__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.XML__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.XML Current_Cast = (Goedel.Document.Markdown.Tags.XML)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Default) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Default ]");
								}
							}
                        break;


                    case StateCode.Default_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.Default Current_Cast = (Goedel.Document.Markdown.Tags.Default)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Default__Tag;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Default__Tag:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.Default Current_Cast = (Goedel.Document.Markdown.Tags.Default)Current;
                            Current_Cast.Value = Text;
                            State = StateCode.Default__Value;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Default__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Stack_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Stack Current_Cast = (Goedel.Document.Markdown.Tags.Stack)Current;
                            Current_Cast.Wrapper = Registry.REF(Position, Text, TYPE__ElementID, Current_Cast);
                            State = StateCode.Stack__Wrapper;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Stack__Wrapper:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Wrap_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Wrap Current_Cast = (Goedel.Document.Markdown.Tags.Wrap)Current;
                            Current_Cast.Wrapper = Registry.REF(Position, Text, TYPE__ElementID, Current_Cast);
                            State = StateCode.Wrap__Wrapper;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Wrap__Wrapper:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Level_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Document.Markdown.Tags.Level Current_Cast = (Goedel.Document.Markdown.Tags.Level)Current;
                            Current_Cast.Value = Convert.ToInt32(Text);
                            State = StateCode.Level__Value;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Level__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Remark_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Remark__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Remark__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Document.Markdown.Tags.Remark Current_Cast = (Goedel.Document.Markdown.Tags.Remark)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Start_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Start__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Start__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Document.Markdown.Tags.Start Current_Cast = (Goedel.Document.Markdown.Tags.Start)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.End_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.End__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.End__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Document.Markdown.Tags.End Current_Cast = (Goedel.Document.Markdown.Tags.End)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.String_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.String Current_Cast = (Goedel.Document.Markdown.Tags.String)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__AttributeID, Current_Cast);
                            State = StateCode.String__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.String__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Flag_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Flag Current_Cast = (Goedel.Document.Markdown.Tags.Flag)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__AttributeID, Current_Cast);
                            State = StateCode.Flag__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Flag__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Integer_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Integer Current_Cast = (Goedel.Document.Markdown.Tags.Integer)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__AttributeID, Current_Cast);
                            State = StateCode.Integer__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Integer__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Format_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Format Current_Cast = (Goedel.Document.Markdown.Tags.Format)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__FormatID, Current_Cast);
                            State = StateCode.Format__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Format__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Format__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Format__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Document.Markdown.Tags.Format Current_Cast = (Goedel.Document.Markdown.Tags.Format)Current;
                            Goedel.Document.Markdown.Tags.MarkSchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Document.Markdown.Tags.MarkSchemaType.Entry) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Entry ]");
								}
							}
                        break;


                    case StateCode.Entry_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Document.Markdown.Tags.Entry Current_Cast = (Goedel.Document.Markdown.Tags.Entry)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FormatField, Current_Cast);
                            State = StateCode.Entry__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Entry__Id:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Entry__Strings;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Entry__Strings:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Document.Markdown.Tags.Entry Current_Cast = (Goedel.Document.Markdown.Tags.Entry)Current;
                            Current_Cast.Strings.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.XEmpty_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.XEmpty Current_Cast = (Goedel.Document.Markdown.Tags.XEmpty)Current;
                            Current_Cast.Label = Text;
                            State = StateCode.XEmpty__Label;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.XEmpty__Label:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.XEmpty__Attributes;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.XEmpty__Attributes: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Document.Markdown.Tags.XEmpty Current_Cast = (Goedel.Document.Markdown.Tags.XEmpty)Current;
                            Current_Cast.Attributes.Add (NewTValue ());
                            Represent = true;
                            }

                        break;


                    case StateCode.XStart_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.XStart Current_Cast = (Goedel.Document.Markdown.Tags.XStart)Current;
                            Current_Cast.Label = Text;
                            State = StateCode.XStart__Label;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.XStart__Label:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.XStart__Attributes;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.XStart__Attributes: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Document.Markdown.Tags.XStart Current_Cast = (Goedel.Document.Markdown.Tags.XStart)Current;
                            Current_Cast.Attributes.Add (NewTValue ());
                            Represent = true;
                            }

                        break;


                    case StateCode.XClose_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Template_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.Template Current_Cast = (Goedel.Document.Markdown.Tags.Template)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Template__Text;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Template__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.TValue_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.TValue Current_Cast = (Goedel.Document.Markdown.Tags.TValue)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.TValue__Tag;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.TValue__Tag:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.TValue Current_Cast = (Goedel.Document.Markdown.Tags.TValue)Current;
                            Current_Cast.Value = Text;
                            State = StateCode.TValue__Value;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.TValue__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.XString_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Document.Markdown.Tags.XString Current_Cast = (Goedel.Document.Markdown.Tags.XString)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.XString__Text;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.XString__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Any_Start:
                        Pop ();
                        Represent = true; 
                        break;

                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}
#pragma warning restore IDE0022	

