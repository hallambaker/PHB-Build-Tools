<?xml version='1.0' encoding='utf-8'?>
<rfc xmlns:xi="http://www.w3.org/2001/XInclude" category="info" docName="draft-hallambaker-threshold-00" indexInclude="false" ipr="trust200902" prepTime="2019-12-26T18:32:39Z" scripts="Common,Latin" sortRefs="true" submissionType="independent" symRefs="true" tocDepth="3" tocInclude="true" version="3" xml:lang="en"><front>
<title abbrev="Threshold Cryptography in Elliptic Curves">Threshold Cryptography in Elliptic Curves</title>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-threshold" stream="independent"/>
<author fullname="Phillip Hallam-Baker" initials="P. M." surname="Hallam-Baker"><organization>Venture Cryptography.</organization>
<address>
<email>phill@hallambaker.com</email>
</address>
</author>
<date day="26" month="December" year="2019"/>
<area/>
<workgroup/>
<keyword>Threshold Cryptography</keyword>
<keyword>Elliptic Curve</keyword>
<keyword>Threshold Encryption</keyword>
<keyword>Threshold Key Generation</keyword>
<keyword>Side Channel Resistance</keyword>
<abstract>
<t>Threshold cryptography schemes are described with application to the Ed25519, Ed448, X25519 and X448 Elliptic Curves. Threshold key generation allows generation of keypairs to be divided between two or more parties with verifiable security guaranties. Threshold decryption allows elliptic curve key agreement to be divided between two or more parties such that all the parties must co-operate to complete a private key agreement operation. The same primitives may be applied to improve resistance to side channel attacks.</t>
<t><eref target="http://whatever">https://mailarchive.ietf.org/arch/browse/cfrg/</eref>Discussion of this draft should take place on the CFRG mailing list (cfrg@irtf.org), which is archived at .</t>
</abstract>
</front>
<middle>
<section title="Introduction" anchor="s-1"><t>Public key cryptography provides greater functionality than symmetric key cryptography by introducing separate keys for separate roles. Knowledge of the public encryption key does not provide the ability to decrypt. Knowledge of the public signature verification key does not provide the ability to sign. Threshold cryptography extends the scope of traditional public key cryptography with further separation of roles.</t>
<t>A Threshold scheme is <em>interchangeable</em> if the inputs and outputs of the threshold scheme are identical to those of a conventional scheme. A threshold scheme is <em>auditable</em> if it to verify that the output made use of a particular contribution.</t>
<t>This document describes a threshold decryption and an auditable threshold key generation scheme for the elliptic curve scheme described in <xref target="RFC7748"></xref> and <xref target="RFC8032"></xref>. Both schemes are interchangeable in their own right but require minor modifications to the underlying elliptic curve systems to encode the necessary information in the public (X25519/X448) or private key (Ed25519/Ed448).</t>
<t>Threshold key agreement and threshold signatures will be specified in future drafts.</t>
</section>
<section title="Definitions" anchor="s-2"><t>This section presents the related specifications and standard, the terms that are used as terms of art within the documents and the terms used as requirements language.</t>
<section title="Requirements Language" anchor="s-2_1"><t>The key words "<bcp14>MUST</bcp14>", "<bcp14>MUST NOT</bcp14>", "<bcp14>REQUIRED</bcp14>", "<bcp14>SHALL</bcp14>", "<bcp14>SHALL NOT</bcp14>", "<bcp14>SHOULD</bcp14>", "<bcp14>SHOULD NOT</bcp14>", "<bcp14>RECOMMENDED</bcp14>", "<bcp14>MAY</bcp14>", and "<bcp14>OPTIONAL</bcp14>" in this document are to be interpreted as described in <xref target="RFC2119"></xref>.</t>
</section>
<section title="Defined Terms" anchor="s-2_2"><t>The following terms are used as terms of art in this document.</t>
<dl>
<dt>Auditable</dt>
<dd>
<t>Whether it is possible (or not) to verify that the output of a threshold scheme made use of a particular contribution.</t>
</dd>
<dt>Interchangeable</dt>
<dd>
<t>A Threshold scheme is <em>interchangeable</em> if the inputs and outputs of the threshold scheme are identical to those of a conventional scheme</t>
</dd>
<dt>Multi-Encryption</dt>
<dd>
<t>The use of multiple decryption fields to allow a document encrypted under a session key to be decrypted by multiple parties under different decryption keys.</t>
<t>Multi-Encryption allows a document to be shared with multiple recipients but does not allow the decryption role to be divided between multiple parties.</t>
</dd>
<dt>Multi-Signatures</dt>
<dd>
<t>The use of multiple independently verifiable digital signatures to authenticate a document.</t>
<t>Multi-Signatures allow separation of the signing roles and thus achieve a threshold capability. But they are not true threshold signatures as the set of signers is visible to external parties.</t>
</dd>
<dt>Onboarding</dt>
<dd>
<t>The process by which an embedded device is provisioned for deployment in a local network.</t>
</dd>
<dt>Threshold Key Generation</dt>
<dd>
<t>An aggregate public, private key pair is constructed from a set of contributions such that the private key is a function of the private key of all the contributions.</t>
<t>A Threshold Key Generation function is auditable if and only if the public component of the aggregate key can be computed from the public keys of the contributions alone.</t>
</dd>
<dt>Threshold Decryption</dt>
<dd>
<t>Threshold decryption divides the decryption role between two or more parties.</t>
</dd>
<dt>Threshold Key Agreement</dt>
<dd>
<t>A bilateral key agreement exchange in which one or both sides present multiple public keys and the key agreement value is a function of all of them.</t>
<t>This approach allows a party to present multiple credentials in a single exchange, a de</t>
</dd>
<dt>Threshold Signatures</dt>
<dd>
<t>Threshold signatures divide the signature role between two or more parties in such a way that the parties and their roles is not visible to an external observer.</t>
</dd>
</dl>
</section>
<section title="Related Specifications" anchor="s-2_3"><t>This document extends the elliptic curve cryptography systems described in <xref target="RFC7748"></xref> and <xref target="RFC8032"></xref> to provide threshold capabilities.</t>
<t>This work was originally motivated by the requirements of the Mathematical Mesh <xref target="draft-hallambaker-mesh-architecture"></xref></t>
</section>
<section title="Implementation Status" anchor="s-2_4"><t>The implementation status of the reference code base is described in the companion document <xref target="draft-hallambaker-mesh-developer"></xref>.</t>
</section>
</section>
<section title="Principles" anchor="s-3"><t>The threshold cryptography mechanisms described in this specification are made possible by the fact that Diffie Hellman key agreement and elliptic curve variants thereof support properties we call the Key Combination Law and the Result Combination Law.</t>
<t>Let {<em>X</em>, <em>x</em>}, {<em>Y</em>, <em>y</em>}, {<em>A</em>, <em>a</em>} be {public, private} key pairs and r [.] S represent the Diffie Hellman operation applying the private key r to the public key S.</t>
<t>The Key Combination law states that we can define an operator [x] such that there is a keypair {<em>Z</em>, <em>z</em>} such that:</t>
<t><em>Z</em> = <em>X</em> [x] <em>Y</em> and <em>z</em> = (<em>x</em> + <em>y</em>) mod <em>o</em> (where <em>o</em> is the order of the group)</t>
<t>The Result Combination Law states that we can define an operator [+] such that:</t>
<t>(<em>x</em> [.] <em>A</em>) [+] (<em>y</em> [.] <em>A</em>) = (<em>z</em> [.] <em>A</em>) = (<em>a</em> [.] <em>Z</em>)</t>
<t>It will be noted that each of these laws is interchangeable. The output of the key combination law to a Diffie Hellman key pair is a Diffie Hellman key pair and the output of the result combination law is a Diffie Hellman result. This allows modular and recursive application of these principles.</t>
<section title="Application to Diffie Hellman (not normative)" anchor="s-3_1"><t>Diffie Hellman in a modular field  provides a concise demonstration of the key combination and result combination laws <xref target="RFC2631"></xref>. The realization of the threshold schemes in a modular field is outside the scope of this document.</t>
<t>For the Diffie Hellman system in a modular field p, with exponent e:</t>
<ul>
<li>r [.] S = <sup>r</sup>S mod p</li>
<li>o = p-1</li>
<li><em>A </em>[x] <em>B</em> = <em>A </em>[.] <em>B</em> = <em>AB </em>mod <em>p</em>.</li>
</ul>
<t><em>Proof:</em></t>
<t>Let z = x + y</t>
<t>By definition, X = e<sup>x</sup> mod p, Y = e<sup>y</sup> mod p, and Z = e<sup>z </sup>mod p.</t>
<t>Therefore, </t>
<dl>
<dt>Z = e<sup>z</sup> mod p </dt>
<dd>
<t>= e<sup>x+y</sup> mod p </t>
<t>= (e<sup>x</sup>e<sup>y</sup>) mod p </t>
<t>= e<sup>x </sup>mod p.e<sup>y</sup> mod p </t>
<t>= X.Y</t>
</dd>
</dl>
<t>Moreover, A = e<sup>a</sup> mod p,</t>
<t>Therefore,</t>
<dl>
<dt>(A<sup>x</sup> mod p).(<sup>y</sup>A mod p) </dt>
<dd>
<t>= (<sup>x</sup><sup>y</sup>AA) mod p) </t>
<t>= (<sup>x+y</sup>A) mod p) </t>
<t>= <sup>z</sup>A mod p</t>
<t>= e<sup>az</sup> mod p </t>
<t>= (e<sup>z</sup>)<sup>a</sup> mod p </t>
<t>= <sup>a</sup>Z mod p</t>
</dd>
</dl>
<t>Since e<sup>o</sup> mod p = 1, the same result holds for z = (x + y) mod o since e<sup>x+y+no</sup> = e<sup>x+y</sup>.e<sup>no</sup> = e<sup>x+y</sup>.1 = e<sup>x+y</sup>.</t>
</section>
<section title="Threshold Decryption" anchor="s-3_2"><t>Threshold decryption allows  a decryption key to be divided into two or more parts, allowing these roles to be assigned to different parties. This capability can be employed within a machine to divide use of a private key between an implementation running in the user mode and a process running in a privileged mode that is bound to the machine. Alternatively, threshold cryptography can be employed to </t>
<t>The key combination law and result combination law provide a basis for threshold decryption. </t>
<section title="Key Splitting" anchor="s-3_2_1"><t>We begin by creating a base key pair { X, x }. The public component X is used to perform encryption operations by means of a key agreement against an ephemeral key in the usual fashion. The private component x may be used for decryption in the normal fashion or to provide the source material for a key splitting operation.</t>
<t>To split the base key into n shares { <sub>1</sub>S, s<sub>1</sub> }, { <sub>2</sub>S, s<sub>2</sub> }, ... { <sub>n</sub>S, s<sub>n</sub> }, we begin by generating the first n-1 private keys in the normal fashion. It is not necessary to generate the corresponding public keys as these are not required.</t>
<t>The private key of the final key share s<sub>n</sub> is given by:</t>
<t><em>s<sub>n</sub> = (x - s1 - s2 - ... - sn-1) mod o</em></t>
<t>Thus, the base private key x is equal to the sum of the private key shares modulo the group order.</t>
</section>
<section title="Decryption" anchor="s-3_2_2"><t>To encrypt a document, we first generate an ephemeral key pair { Y, y }. The key agreement value e<sup>xy</sup> is calculated from the base public key X = e<sup>x</sup> and the ephemeral private key y. A key derivation function is then used to obtain the session key to be used to encrypt the document under a symmetric cipher.</t>
<t>To decrypt a document using the threshold key shares, each key share holder first performs a Diffie Hellman operation using their private key on the ephemeral public key. The key shares are then combined using the result combination law to obtain the key exchange value from which the session key is recovered.</t>
<t>The key contribution c<sub>i</sub> for the holder of the i<sup>th</sup> key share is calculated as:</t>
<t>c<sub>i</sub> = <sup>siY</sup></t>
<t>The key agreement value is thus</t>
<t>A = c<sub>1</sub> . c<sub>2</sub> . ... . c<sub>n</sub></t>
<t>This value is equal to the encryption key agreement value according to the group law.</t>
</section>
</section>
<section title="Threshold Key Generation" anchor="s-3_3"><t>The key combination law allows an aggregate private key to be derived from private key contributions provided by two or more parties such that the corresponding aggregate public key may be derived from the public keys corresponding to the contributions. The resulting key generation mechanism is thus, auditable and interoperable.</t>
<section title="Device Provisioning" anchor="s-3_3_1"><t>Auditable Threshold Key Generation provides a simple and efficient means of securely provisioning keys to devices. This is encountered in the IoT space as a concern in 'onboarding' and in the provisioning of unique keys for use with cryptographic applications (e.g. SSH, S/MIME, OpenPGP, etc.).</t>
<t>Consider the case in which Alice purchases an IoT connected Device D which requires a unique device key pair <em>{ X , x }</em> for its operation. The process of provisioning (aka 'onboarding') is performed using an administration device. Traditional key pair generation gives us three options:</t>
<ul>
<li>Generate and install a key pair during manufacture.</li>
<li>Generate a new key pair during device provisioning.</li>
<li>Generate a key pair on the administration device and transfer it to the device being provisioned. </li>
</ul>
<t>The first approach has the obvious disadvantage that the manufacturer has knowledge of the private key. This represents a liability for both the user and the manufacturer. Less obvious is the fact that the second approach doesn't actually provide a solution unless the process of generating keys on the device is auditable. The third approach is auditable with respect to the device being provisioned but not with respect to the administration device being used for provisioning. If that device were to be compromised, so could every device it was used to provision.</t>
<t>Threshold key generation allows the administration device and the joining device being provisioned to jointly provision a key pair as follows:</t>
<ul>
<li>The joining device has public, private key pair<em> { D, d }</em>.</li>
<li>A provisioning request is made for the device which includes the joining device public key <em>D</em>.</li>
<li>The administration device generates a key pair contribution <em>{ A, a }</em>. </li>
<li>The administration device private key is transmitted to the Device by means of a secure channel.</li>
<li>The joining device calculates the aggregate key pair <em>{ A [x] D, a+d }</em>. </li>
<li>The administration device authorizes the joining device to participate in the local network using the public key <em>A [x] D</em>.</li>
</ul>
<t>The Device key pair <bcp14>MAY</bcp14> be installed during manufacture or generated during provisioning or be derived from a combination of both using threshold key generation recursively. The provisioning request <bcp14>MAY</bcp14> be originated by the device or be generated by a purchasing system.</t>
<t>Note that the provisioning protocol does not require either party to authenticate the aggregate key pair. The protocol provides security by ensuring that both parties obtain the correct results if and only if the values each communicated to the other were correct.</t>
<t>Out of band authentication of the joining device public key <em>D</em> is sufficient to prevent Man-in-the-Middle attack. This may be achieved by means of a QR code printed on the device itself that discloses or provides a means of obtaining <em>D.</em></t>
</section>
<section title="Key Rollover" anchor="s-3_3_2"><t>Traditional key rollover protocols in PKIX and other PKIs following the Kohnfelder model, require a multi-step interaction between the key holder and the Certificate Authority.</t>
<t>Threshold key generation allows a Certificate Authority to implement key rollover with a single communication:</t>
<t>Consider the case in which the service host has a base key pair { B , b }. A CA that has knowledge of the Host public key B may generate a certificate for the time period <em>t</em> with a fresh key as follows:</t>
<ul>
<li>Generate a key pair contribution { <sub>t</sub>A, a<sub>t</sub> }. </li>
<li>Generate and sign an end entity certificate <sub>t</sub>C for the key B [x] <sub>t</sub>A.</li>
<li>Transmit <sub>t</sub>C, a<sub>t</sub> to the host by means of a secure channel</li>
</ul>
</section>
<section title="Host Activation" anchor="s-3_3_3"><t>Modern Internet service architectures frequently make use of short lived, ephemeral hosts running on virtualized machines. Provisioning cryptographic material in such environments is a significant challenge and especially so when the underlying hardware is a shared resource.</t>
<t>The key rollover approach described above provides a means of provisioning short lived credentials to ephemeral hosts that potentially avoids the need to build sensitive keys into the service image or configuration.</t>
</section>
<section title="Separation of Duties" anchor="s-3_3_4"><t>Threshold key generation provides a means of separating administration of cryptographic keys between individuals. This allows two or more administrators to control access to a private key without having the ability to use it themselves. This approach is of particular utility when used in combination with threshold decryption. Alice and Bob can be granted the ability to create key contributions allowing a user to decrypt information without having the ability to decrypt themselves.</t>
</section>
</section>
<section title="Side Channel Resistance" anchor="s-3_4"><t>Side-channel attacks, present a major concern in the implementation of public key cryptosystems. Of particular concern are the timing attacks identified by Paul Kocher <xref target="Kocher96"></xref> and related attacks in the power and emissions ranges. Performing repeated observations of the use of the same private key material provides an attacker with considerably greater opportunity to extract the private key material.</t>
<t>A simple but effective means of defeating such attacks is to split the private key value into two or more random shares for every private key operation and use the result combination law to recover the result. </t>
<t>The implementation of this approach is identical to that for Threshold Decryption except that instead of giving the key shares to different parties, they are kept by the party performing the private key operation.</t>
<t>While this approach doubles the number of private key operations required, the operations <bcp14>MAY</bcp14> be performed in parallel. Thus avoiding impact on the user experience.</t>
</section>
</section>
<section title="Application to Elliptic Curves" anchor="s-4"><t>For elliptic curve cryptosystems, the operators [x] and [.] are point addition.</t>
<t>Implementing a robust Key Co-Generation for the Elliptic Curve Cryptography schemes described in <xref target="RFC7748"></xref> and <xref target="RFC8032"></xref> requires some additional considerations to be addressed.</t>
<ul>
<li>The secret scalar used in the EdDSA algorithm is calculated from the private key using a digest function. It is therefore necessary to specify the Key Co-Generation mechanism by reference to operations on the secret scalar values rather than operations on the private keys.</li>
<li>The Montgomery Ladder traditionally used to perform X25519 and X448 point multiplication does not require implementation of a function to add two arbitrary points. While the steps required to create such a function are fully constrained by <xref target="RFC7748"></xref>, the means of performing point addition is not.</li>
</ul>
<section title="Implementation for Ed25519 and Ed448" anchor="s-4_1"><t><xref target="RFC8032"></xref> provides all the cryptographic operations required to perform threshold operations and corresponding public keys. </t>
<t>The secret scalars used in <xref target="RFC8032"></xref> private key operations are derived from a private key value using a cryptographic digest function. This encoding allows the inputs to a private key combination to be described but not the output. Contrawise, the encoding allows the inputs to a private key splitting operation to be described but not the output</t>
<t>It is therefore necessary to provide an alternative representation for the Ed25519 and Ed448 private keys. Moreover, the signature algorithm requires both a secret scalar and a prefix value as inputs.</t>
<t>Since threshold signatures are out of scope for this document and <xref target="RFC8032"></xref> does not specify a key agreement mechanism, it suffices to specify the data formats required to encode private key values generated by means of threshold key generation.</t>
<section title="Ed25519" anchor="s-4_1_1"><t>Let the inputs to the threshold key generation scheme be a set of 32 byte private key values <em>P<sub>1</sub>, P2 ... Pn. For each private key value i in turn:</em></t>
<ol start="0">
<li>Hash the 32-byte private key using SHA-512, storing the digest in a 64-octet large buffer, denoted<em> h<sub>i</sub></em>. Let n<sub>i</sub> be the first 32 octets of h<sub>i</sub> and m<sub>i</sub> be the remaining 32 octets of h<sub>i</sub>.</li>
<li>Prune n<sub>i</sub>: The lowest three bits of the first octet are cleared, the highest bit of the last octet is cleared, and the second highest bit of the last octet is set.</li>
<li>Interpret the buffer as the little-endian integer, forming a secret scalar s<sub>i</sub>.</li>
</ol>
<t>The private key values are calculated as follows:</t>
<t>The aggregate secret scalar value <em>s<sub>a</sub> = s1 + s2 + ... sn mod L, where L is the order of the curve.</em></t>
<t>The aggregate prefix value is calculated by either</t>
<ul>
<li>Some function TBS on the values m<sub>1</sub>, m<sub>2</sub>,  ... m<sub>n</sub>, or</li>
<li>Taking the SHA256 digest of s<sub>a</sub>.</li>
</ul>
<t>The second approach is the simplest and the most robust. It does however mean that the prefix is a function of the secret scalar rather than both being functions of the same seed. </t>
</section>
<section title="Ed448" anchor="s-4_1_2"><t>Let the inputs to the threshold key generation scheme be a set of 57 byte private key values <em>P<sub>1</sub>, P2 ... Pn. For each private key value i in turn:</em></t>
<ol start="0">
<li>Hash the 57-byte private key using SHAKE256(x, 114), storing the digest in a 114-octet large buffer, denoted<em> h<sub>i</sub></em>. Let n<sub>i</sub> be the first 57 octets of h<sub>i</sub> and m<sub>i</sub> be the remaining 57 octets of h<sub>i</sub>.</li>
<li>Prune n<sub>i</sub>: The two least significant bits of the first octet are cleared, all eight bits the last octet are cleared, and the highest bit of the second to last octet is set.</li>
<li>Interpret the buffer as the little-endian integer, forming a secret scalar s<sub>i</sub>.</li>
</ol>
<t>The private key values are calculated as follows:</t>
<t>The aggregate secret scalar value <em>s<sub>a</sub> = s1 + s2 + ... sn mod L, where L is the order of the curve.</em></t>
<t>The aggregate prefix value is calculated by either</t>
<ul>
<li>Some function TBS on the values m<sub>1</sub>, m<sub>2</sub>,  ... m<sub>n</sub>, or</li>
<li>Taking the SHAKE256(x, 57) digest of s<sub>a</sub>.</li>
</ul>
<t>The second approach is the simplest and the most robust. It does however mean that the prefix is a function of the secret scalar rather than both being functions of the same seed. </t>
</section>
</section>
<section title="Implementation for X25519 and X448" anchor="s-4_2"><t><xref target="RFC7748"></xref> defines all the cryptographic operations required to perform threshold key generation and threshold decryption but does not describe how to implement them.</t>
<t>The Montgomery curve described in <xref target="RFC7748"></xref> allows for efficient scalar multiplication using arithmetic operations on a single coordinate. Point addition requires both coordinate values. It is thus necessary to provide an extended representation for point encoding and provide an algorithm for recovering both coordinates from a scalar multiplication operation and an algorithm for point addition.</t>
<t>The notation of <xref target="RFC7748"></xref> is followed using {u, v} to represent the coordinates on the Montgomery curve and {x, y} for coordinates on the corresponding Edwards curve.</t>
<section title="Point Encoding" anchor="s-4_2_1"><t>The relationship between the u and v coordinates is specified by the Montgomery Curve formula itself:</t>
<t><em>v<sup>2</sup></em> = <em>u<sup>3</sup> + Au2 + u</em></t>
<t>An algorithm for extracting a square root of a number in a finite field is specified in <xref target="RFC8032">.</xref></t>
<t>Since <em>v<sup>2</sup></em> has a positive (<em>v</em>) and a negative solution (<em>-v</em>), it follows that <em>v<sup>2</sup></em> mod p will have the solutions <em>v</em>, <em>p-v</em>. Furthermore, since <em>p</em> is odd, if <em>v</em> is odd, <em>p-v</em> must be even and vice versa. It is thus sufficient to record whether <em>v</em> is odd or even to enable recovery of the <em>v</em> coordinate from <em>u</em>.</t>
</section>
<section title="X25519 Point Encoding" anchor="s-4_2_2"><t>The extended point encoding allowing the v coordinate to be recovered is as given in <xref target="draft-ietf-lwig-curve-representations"></xref></t>
<t>[TBS]</t>
</section>
<section title="X448 Point Encoding" anchor="s-4_2_3"><t>The extended point encoding allowing the v coordinate to be recovered is as given in <xref target="draft-ietf-lwig-curve-representations"></xref></t>
<t>[TBS]</t>
</section>
<section title="Point Addition" anchor="s-4_2_4"><t>The point addition formula for the Montgomery curve is defined as follows:</t>
<t>Let <sub>1</sub>P = {u<sub>1</sub>, v<sub>1</sub>}, <sub>2</sub>P = {u<sub>2</sub>,  v<sub>2</sub>}, <sub>3</sub>P = {u<sub>3</sub>, v<sub>3</sub>} = <sub>1</sub>P + <sub>2</sub>P </t>
<t>By definition: </t>
<t>u<sub>3</sub> = B(v<sub>2</sub> - v<sub>1</sub>)<sup>2</sup> / (u<sub>2</sub> - u<sub>1</sub>)<sup>2</sup> - A - u<sub>1</sub> - u<sub>2</sub></t>
<t>    = B((u<sub>2</sub>v<sub>1</sub> - u<sub>1</sub>v<sub>2</sub>)<sup>2</sup> ) / u<sub>1</sub>u<sub>2</sub> (u<sub>2</sub> - u<sub>1</sub>)<sup>2</sup></t>
<t>v<sub>3</sub> = ((2u<sub>1</sub> + u<sub>2</sub> + A)(v<sub>2</sub> - v<sub>1</sub>) / (u<sub>2</sub> - u<sub>1</sub>)) - B (v<sub>2</sub> - v<sub>1</sub>)<sup>3</sup> / (u<sub>2</sub> -u<sub>1</sub>)<sup>3</sup> - v<sub>1</sub></t>
<t>For curves X25519 and X448, B = 1 and so:</t>
<t>u<sub>3</sub> = ((v<sub>2</sub> - v<sub>1</sub>).(u<sub>2</sub> - u<sub>1</sub>)<sup>-1</sup>)<sup>2</sup> - A - u<sub>1</sub> - u<sub>2</sub></t>
<t>v<sub>3</sub> = ((2u<sub>1</sub> + u<sub>2</sub> + A)(v<sub>2</sub> - v<sub>1</sub>).(u<sub>2</sub> - u<sub>1</sub>)<sup>-1</sup>) - ((v<sub>2</sub> - v<sub>1</sub>).(u<sub>2</sub> -u<sub>1</sub>)<sup>-1</sup>)<sup>3</sup> - v<sub>1</sub></t>
<t>This may be implemented using the following code:</t>
<sourcecode>B = v2 - v1
C = u2 - u1
CINV = C^(p - 2)
D = B * CINV
DD = D * D
DDD = DD * D

u3 = DD - A - u1 - u2
v3 = ((u1 + u1 + u2 + A) * B * CINV) - DDD - v1</sourcecode>
<t>Performing point addition thus requires that we have sufficient knowledge of the values v<sub>1</sub>, v<sub>2</sub>. At minimum whether one is odd and the other even or if both are the same. </t>
</section>
<section title="Montgomery Ladder with Coordinate Recovery" anchor="s-4_2_5"><t>As originally described, the Montgomery Ladder only provides the u coordinate as output. L?pez and Dahab <xref target="Lopez99"></xref> provided a formula for recovery of the v coordinate of the result for curves over binary fields. This result was then extended by Okeya and Sakurai <xref target="Okeya01"></xref> to prime field Montgomery curves such as X25519 and X448. The realization of this result described by Costello and Smith <xref target="Costello17"></xref> is applied here.</t>
<t>The scalar multiplication function specified in <xref target="RFC7748"> takes as input the scalar value k and the coordinate u1 of the point P1 = {u1, v1} to be multiplied. The return value in this case is u2 where P2 = {u2, v2} = k.P1.</xref></t>
<t>To recover the coordinate v<sub>2</sub> we require the values x_2, z_2, x_3, z_3 calculated in the penultimate step:</t>
<sourcecode>   x_1 = u
   x_2 = 1
   z_2 = 0
   x_3 = u
   z_3 = 1
   swap = 0

   For t = bits-1 down to 0:
       k_t = (k &gt;&gt; t) &amp; 1
       swap ^= k_t
       // Conditional swap as specified in RFC 7748
       (x_2, x_3) = cswap(swap, x_2, x_3)
       (z_2, z_3) = cswap(swap, z_2, z_3)
       swap = k_t

       A = x_2 + z_2
       AA = A^2
       B = x_2 - z_2
       BB = B^2
       E = AA - BB
       C = x_3 + z_3
       D = x_3 - z_3
       DA = D * A
       CB = C * B
       x_3 = (DA + CB)^2
       z_3 = x_1 * (DA - CB)^2
       x_2 = AA * BB
       z_2 = E * (AA + a24 * E)

   (x_2, x_3) = cswap(swap, x_2, x_3)
   (z_2, z_3) = cswap(swap, z_2, z_3)
   Return x_2, z_2, x_3, z_3</sourcecode>
<t>The values x_2, z_2 give the projective form of the u coordinate of the point <sub>2</sub>P = {u<sub>2</sub>, v<sub>2</sub>} = k.<sub>1</sub>P and the  values x_3, z_3 give the projective form of the u coordinate of the point <sub>3</sub>P = {u<sub>3</sub>, v<sub>3</sub>} = (k+1).<sub>1</sub>P = <sub>1</sub>P + k.<sub>1</sub>P = <sub>1</sub>P + <sub>2</sub>P.</t>
<t>Given the coordinates {u<sub>1</sub>, v<sub>1</sub>}  of the point P1 and the u coordinates of the points  <sub>2</sub>P, <sub>1</sub>P + <sub>2</sub>P, the coordinate v<sub>2</sub> <bcp14>MAY</bcp14> be recovered by trial and error as follows:</t>
<sourcecode>v_test = SQRT (u3 + Au2 + u)
u_test = ADD_X (u, v, u_2, v_test)
if (u_test == u_3)
   return u_test
else
   return u_test +p</sourcecode>
<t>Alternatively, the following <bcp14>MAY</bcp14> be used to recover {u<sub>2</sub>, v<sub>2</sub>} without the need to extract the square root and using a single modular exponentiation operation to convert from the projective coordinates used in the calculation. As with the Montgomery ladder algorithm above, the expression has been modified to be consistent with the approach used in <xref target="RFC7748"> but any correct formula may be used.</xref></t>
<sourcecode>x_p = u
y_p = v

B = x_p * z_2    //v1
C = x_2 + B      //v2
D = X_2 - B      //v3
DD = D^2         //v3
E = DD. X_3      //v3
F = 2 * A * z_2  //v1

G = C + F        //v2
H = x_p * x_2    //v4
I = H + z_2      //v4
J = G * I        //v2
K = F * z_2      //v1
L = J - K        //v2
M = L * z_3      //v2

yy_2 = M - E     //Y'
N = 2 * y_p      //v1
O = N * z_2      //v1
P = O * z_3      //v1
xx_2 = P * x_q   //X'
zz_2 = P * z_ q  //Z'

ZINV = (zz_2^(p - 2))
u2 = xx_2 * ZINV
v2 = yy_2 * ZINV

return u2, v2</sourcecode>
</section>
</section>
</section>
<section title="Test Vectors" anchor="s-5"><section title="Threshold Key Generation" anchor="s-5_1"><section title="X25519" anchor="s-5_1_1"><t>The key parameters of the first key contribution are: </t>
<sourcecode>X25519Key1 (X25519)
    UDF:        ZAAA-CTKG-X255-XXKE-YX
    Scalar:     56751742936444772792970879017152360515706108153669948486
        190735258502824077920
    Encoded Private
  60 2A E2 12  AC 8E C8 86  A1 79 51 7E  79 90 5E C2
  9B AD 10 01  B9 2D 51 33  65 DB F4 9E  23 59 78 7D
    U: 25222393324990721517739552691612440154338285166262054281502859684
        220669343438
    V: 15622452724514925334849257786951944861130311422605147559630230860
        481236780294
    Encoded Public
  CE 36 B9 F1  56 BD 92 5C  F4 B6 F5 E1  E0 BA CA 6A
  9B 7C 37 7D  F8 DC 39 CC  12 2E A6 8F  64 5E C3 37
  00</sourcecode>
<t>The key parameters of the second key contribution are: </t>
<sourcecode>X25519Key2 (X25519)
    UDF:        ZAAA-CTKG-X255-XXKE-Y2
    Scalar:     30800688691513612134093999707357841640579640775881469593
        062950189697563564400
    Encoded Private
  70 19 5B 38  A4 46 21 79  31 AC 48 83  60 C9 BD F8
  E1 EE 04 53  67 F2 B5 D8  9E 42 53 66  6F 92 18 44
    U: 35108630063567318397224393939085269372284744000330218923799041589
        332061533992
    V: 13827314478911339710714490558315610168380330915483870499348836357
        802235649136
    Encoded Public
  28 37 F5 39  16 C6 10 C6  8A AC 75 E9  20 EF 67 6D
  C2 6C AF 2C  E4 F6 4F C9  E9 30 6C BD  C9 C7 9E 4D
  00</sourcecode>
<t>The aggregate private key is: </t>
<sourcecode>Scalar_A = (Scalar_1 + Scalar_2) mod L
  = 70836469997123835938663996799427126600035261699252680723027418877493
      6630452

Encoded Aggrgate Private Key:

  B4 54 B7 EF  13 30 0D DF  C6 CB FE 5D  6A A3 A8 C0
  7C 9C 15 54  20 20 07 0C  04 1E 48 05  93 EB 90 01</sourcecode>
<t>The aggregate public key is: </t>
<sourcecode>Point_A = Point_1 + Point_2

U: 416454936139914218771704724014904891682742086807613599097165979348462
    85027335
V: 473400233126764321363639652645349333601103100790621508110841442520995
    52212729

Encoded Public
  07 98 75 38  67 9C 66 21  A3 0A D1 06  CF F5 81 04
  94 C0 52 C9  9C FD AE 4E  13 3B 43 9D  9A 83 12 5C</sourcecode>
<t>Note that in this case, the unsigned representation of the key is used as the aggregate key is intended for unsigned CurveX key agreement. If the result is intended for use as a key contribution, the signed representation is required. </t>
</section>
<section title="X448" anchor="s-5_1_2"><t>The key parameters of the first key contribution are: </t>
<sourcecode>X448Key1 (X448)
    UDF:        ZAAA-ETKG-X44X-KEYX
    Scalar:     68165415229434843487640754974827937311214322558126978805
        5715553507401814865302008262214951100710804646043741434925630887
        320553400661768
    Encoded Private
  08 77 91 25  66 19 C6 1A  03 C7 60 9A  8C C8 10 9D
  DE F5 20 E1  A7 7F 3E 83  56 57 FE A6  C9 97 79 FB
  DC 85 55 6F  CE 17 79 70  CA 3E B5 D1  6A B0 50 6A
  60 F6 BF 3A  88 E5 15 F0
    U: 60697849609835675975297341597995979787516605306209816088918249829
        3453953345846660594020472424536065173283947670623780408505231207
        15561
    V: 60813500494147049417364978264586877278456315581444885337361828507
        6034450004202627339591608123302429557097118744860203117206220854
        848663
    Encoded Public
  29 C7 E7 1A  ED 85 B5 66  F4 CA 8F 4D  07 72 EC 4B
  15 42 FA 95  4D A3 25 F6  D2 BF C0 5E  11 C4 27 D3
  A1 43 D8 74  B6 4C C8 22  7D 64 56 58  A4 8C C6 5D
  DA F2 AA 75  DE DE 60 15  80</sourcecode>
<t>The key parameters of the second key contribution are: </t>
<sourcecode>X448Key2 (X448)
    UDF:        ZAAA-ETKG-X44X-KEY2
    Scalar:     67824881411761849798195083121628378835623370171088982693
        7962011129206719268741815680700006802689991287015918654801310197
        484516725932432
    Encoded Private
  90 C1 CE 67  A2 88 20 95  B9 A8 8A E7  5A 12 73 C6
  4C E3 B0 0E  3A A4 1A 72  03 39 FC 9B  47 D9 6A E0
  A2 81 63 57  77 EB 97 E5  CE 05 2C CB  EE D7 64 F6
  51 C1 42 E7  FE D9 E2 EE
    U: 32395912186842981800922536415382601434069282464793284039370624156
        5981551756628007189667971676177150776689230729229736979561639842
        244556
    V: 18056267944998342850921302138832444826477211000541459460301605410
        5989977716699286334066341414636204710801397092415122728296636211
        077711
    Encoded Public
  CC 67 05 A8  AE D3 8C 6E  17 F8 7F 66  77 14 7F 32
  D3 F6 12 1C  E2 80 A9 BF  A9 AA 41 FC  88 EF E3 F9
  38 C7 1C AA  1A 14 54 EC  F0 4D 6D 20  ED 4F 63 24
  F2 A0 68 F5  1C 09 1A 72  80</sourcecode>
<t>The aggregate private key is: </t>
<sourcecode>Scalar_A = (Scalar_1 + Scalar_2) mod L
  = 87935198894654874397041717160555226349504546089353009501069716070586
      506403266723929544670861554164189887604126085304951388779109045747

Encoded Aggrgate Private Key:

  F3 55 F6 DD  05 50 99 B7  68 84 84 A1  C5 89 8A 79
  3A 5B F6 27  DE 24 31 97  F5 94 73 D9  14 71 E4 DB
  7F 07 B9 C6  45 03 11 56  99 44 E1 9C  59 88 B5 60
  B2 B7 02 22  87 BF F8 1E</sourcecode>
<t>The aggregate public key is: </t>
<sourcecode>Point_A = Point_1 + Point_2

U: 611634634479536677984900819195998637894371405676964036939736481366881
    34799342739585406562158256601376457049422599663606975867088547575
V: 547531628982729065710146631050685048629332114514125362339393102647611
    348032713305801879333956525397915473191145951077541388024189524364

Encoded Public
  F7 2E 68 4B  64 DC 2E 24  61 B9 28 14  2E 1D D9 41
  6A 29 4F A2  5F F1 AF 07  24 6C 9B 8A  9E C0 E5 58</sourcecode>
<t>Note that in this case, the unsigned representation of the key is used as the aggregate key is intended for unsigned CurveX key agreement. If the result is intended for use as a key contribution, the signed representation is required. </t>
</section>
<section title="Ed25519" anchor="s-5_1_3"><t>The key parameters of the first key contribution are: </t>
<sourcecode>ED25519Key1 (ED25519)
    UDF:        ZAAA-GTKG-ED25-5XXK-EYX
    Scalar:     39507802390720856312219571924476007168388547774368948368
        537778683821975155688
    Encoded Private
  1C C7 DE DF  19 7B 39 5F  82 98 26 62  AA DE 6C 66
  04 C3 E3 A2  C8 3D 18 58  06 2C 3E EC  7C D4 B4 F2
    X: 42353721841561159243771574200946096579404715276724838688117248315
        8919506245796568293273125470706294881250827210288815928170449575
        540044968280671060652600
    Y: 14453248808291445687399372639220007070442564445118267751942208083
        7579501036794314829741330844154033441251810135221340268136716199
        3702790547954006637246092
    Encoded Public
  6D F1 94 33  33 CC 66 4D  93 89 E2 FB  38 61 21 D5
  C5 6B 29 0F  5C 12 A8 4D  99 06 31 2D  35 32 22 A5</sourcecode>
<t>The key parameters of the second key contribution are: </t>
<sourcecode>ED25519Key2 (ED25519)
    UDF:        ZAAA-GTKG-ED25-5XXK-EY2
    Scalar:     39507802390720856312219571924476007168388547774368948368
        537778683821975155688
    Encoded Private
  1C C7 DE DF  19 7B 39 5F  82 98 26 62  AA DE 6C 66
  04 C3 E3 A2  C8 3D 18 58  06 2C 3E EC  7C D4 B4 F2
    X: 42353721841561159243771574200946096579404715276724838688117248315
        8919506245796568293273125470706294881250827210288815928170449575
        540044968280671060652600
    Y: 14453248808291445687399372639220007070442564445118267751942208083
        7579501036794314829741330844154033441251810135221340268136716199
        3702790547954006637246092
    Encoded Public
  6D F1 94 33  33 CC 66 4D  93 89 E2 FB  38 61 21 D5
  C5 6B 29 0F  5C 12 A8 4D  99 06 31 2D  35 32 22 A5</sourcecode>
<t>The aggregate private key is: </t>
<sourcecode>Scalar_A = (Scalar_1 + Scalar_2) mod L
  = 66455490081190904847072782185220719282059319549388206770560479847894
      07801486

Encoded Aggrgate Private Key:

  8E 20 46 06  EE 61 70 82  FA 37 43 E2  5A 68 E7 3C
  73 4A 36 B7  AC A4 DF 68  A7 95 5C 8E  58 3F B1 0E</sourcecode>
<t>The aggregate public key is: </t>
<sourcecode>Point_A = Point_1 + Point_2

X: -78285292761951767745666894197721180606214882184104422609189932681698
    96558088044165355551471001743951239695738047106458517545601916457896
    1762059345997440
Y: 260549350612676062448188625658154114443427558625932490186172625180161
    79787773477706605100876536271693949174654809503102876480720244055516
    6017893772852160

Encoded Public
  8E 89 98 D0  2D 7F 76 C3  A7 FF B3 1D  2B 41 7E E9
  51 6B 51 B5  F2 84 8D 17  6F 59 9B 5B  6F 01 CF 73</sourcecode>
</section>
<section title="Ed448" anchor="s-5_1_4"><t>The key parameters of the first key contribution are: </t>
<sourcecode>ED448Key1 (ED448)
    UDF:        ZAAA-ITKG-ED44-XKEY-X
    Scalar:     68107042379793845336061948443025230596761423498013670789
        2691573619227377289077600094508827508414971288486032661275761963
        605715031718704
    Encoded Private
  E5 0F 73 50  27 0A 2F 7D  FD D0 96 E5  03 D3 35 2C
  99 CB 71 7C  0B D9 49 E0  40 5E C7 FB  D1 F5 05 18
    X: 21110522768058701369078562241515359390938392915945705092166970243
        9806449434669297504170824118675878901349273731089640143008623250
        57090
    Y: 56282777612186855707940376093524497676882603729010228713044489535
        8482487063409857262483973700689741501700215513985669123529544543
        795102
    Encoded Public
  83 C0 19 E3  07 2A C3 E6  3F 97 DD C2  4A 72 D7 AF
  A8 4B 69 8B  07 A3 4F 45  84 B2 BD 4B  10 B7 44 73
  43 79 89 4B  AA C6 03 25  1F 50 F1 3B  95 A2 4A 81
  13 51 2B 01  D0 2D E3 8C  80</sourcecode>
<t>The key parameters of the second key contribution are: </t>
<sourcecode>ED448Key2 (ED448)
    UDF:        ZAAA-ITKG-ED44-XKEY-2
    Scalar:     68107042379793845336061948443025230596761423498013670789
        2691573619227377289077600094508827508414971288486032661275761963
        605715031718704
    Encoded Private
  E5 0F 73 50  27 0A 2F 7D  FD D0 96 E5  03 D3 35 2C
  99 CB 71 7C  0B D9 49 E0  40 5E C7 FB  D1 F5 05 18
    X: 21110522768058701369078562241515359390938392915945705092166970243
        9806449434669297504170824118675878901349273731089640143008623250
        57090
    Y: 56282777612186855707940376093524497676882603729010228713044489535
        8482487063409857262483973700689741501700215513985669123529544543
        795102
    Encoded Public
  83 C0 19 E3  07 2A C3 E6  3F 97 DD C2  4A 72 D7 AF
  A8 4B 69 8B  07 A3 4F 45  84 B2 BD 4B  10 B7 44 73
  43 79 89 4B  AA C6 03 25  1F 50 F1 3B  95 A2 4A 81
  13 51 2B 01  D0 2D E3 8C  80</sourcecode>
<t>The aggregate private key is: </t>
<sourcecode>Scalar_A = (Scalar_1 + Scalar_2) mod L
  = 90173080078564848259922305056496676816356088757466810292775298672432
      726847378100175647367974983310833800009358909887793795139045888955

Encoded Aggrgate Private Key:

  BB 13 DF EE  6E 99 08 2F  3A 48 78 E0  1D 73 3E 8A
  9C 7E 8D 50  1F 20 00 A3  D0 1B 05 BF  00 41 0C 6E
  19 AA 40 21  C4 EC 1D 82  22 81 0F EE  4E B4 CD 08
  3C 09 43 F8  4C 87 C2 1F</sourcecode>
<t>The aggregate public key is: </t>
<sourcecode>Point_A = Point_1 + Point_2

X: 117970703860677873857394241859792339756031627299029461971946613964970
    547220649014069518272088071719887448971094010337125923569243159171
Y: 679430910062962953304601927238939723027714017166671976282539499239309
    676358730709148741795472033434901956727650426535076863107329148849

Encoded Public
  9A 6C C7 FF  5A AE B0 8B  EB 3D B6 C3  55 82 A7 B6
  4F 9C EC 91  F8 B0 F3 53  51 37 BB 9D  7F F6 63 90
  FE B0 15 3C  D4 35 F3 B9  01 FE 80 BE  B9 F2 2E DF
  FA 8B 15 E0  82 E4 F3 1B  80</sourcecode>
</section>
</section>
<section title="Threshold Decryption" anchor="s-5_2"><section title="Key Splitting X25519" anchor="s-5_2_1"><t>The encryption key pair is </t>
<sourcecode>X25519KeyA (X25519)
    UDF:        ZAAA-CTHD-X255-XXKE-YA
    Scalar:     36212799908425711450656372795692477094724455418915704216
        848228525958587810064
    Encoded Private
  10 01 D5 D1  E2 D3 DB 42  9E 40 5F D9  DB AE E8 09
  DE 43 C3 E6  D1 4F 3A 31  92 BF 19 8A  E9 B7 0F 50
    U: 14523539712308371644546850739155588238080554014514563739095172886
        049239361031
    V: 56685060472089790044070522288405984326906734250304251487683593932
        889808473139
    Encoded Public
  07 66 84 48  25 85 F6 4A  3A EE DF B7  69 1B 57 51
  EC 18 BE AF  08 BA 0D FE  BE F8 74 4E  3C 08 1C 20</sourcecode>
<t>To create n key shares we first create n-1 key pairs in the normal fashion. Since  these key pairs are only used for decryption operations, it is not necessary to  calculate the public components: </t>
<sourcecode>X25519Key1 (X25519)
    UDF:        ZAAA-CTHD-X255-XXKE-YX
    Scalar:     32951726132685026729149224926255648061071804906258082061
        427666995947179849152
    Encoded Private
  C0 B5 33 D4  F3 D0 16 4F  96 DF C3 AD  97 93 02 EF
  B4 25 E2 46  A3 69 1D 22  9B 5B A2 78  1C 04 DA 48</sourcecode>
<t>The secret scalar of the final key share is the secret scalar of the base key minus the sum of the secret scalars of the other shares modulo the group order: </t>
<sourcecode>Scalar_2 = (Scalar_A - Scalar_1) mod L
    = 403147584512037825404691865456117698808221309075461782425833707733
        6679400315
This is encoded as a binary integer in little endian format:

  7B 43 64 61  E9 28 4D 79  AB 9C 6E CC  9F 79 14 3D
  92 69 A5 2D  75 B9 57 53  2D 1B BC 02  06 BC E9 08</sourcecode>
</section>
<section title="Decryption X25519" anchor="s-5_2_2"><t>The means of encryption is unchanged. We begin by generating an ephemeral  key pair: </t>
<sourcecode>X25519KeyE (X25519)
    UDF:        ZAAA-CTHD-X255-XXKE-YE
    Scalar:     41955577142906312619127105554814681129195921605852142704
        362465226652441661496
    Encoded Private
  38 50 3C 88  22 4F 61 D7  9A 2E 1D 71  F0 31 74 44
  A2 3B 2B 35  21 21 CA 19  4B 11 EB F0  DF 03 C2 5C
    U: 10080018124246254127076649374753145019412450363156572968151721892
        767560820008
    V: 43683938787921854603630290352714276342923724280578266457509078671
        566344321831
    Encoded Public
  28 E5 5E 1D  DD 1D 93 71  24 53 0A 83  B3 68 0D 28
  8F 37 AC 53  B6 65 97 7E  C1 54 44 41  8C 16 49 16</sourcecode>
<t>The key agreement result is given by multiplying the public key of the encryption  pair by the secret scalar of the ephemeral key to obtain the u-coordinate of the result. </t>
<sourcecode>U: 247351751388894803426442650867524924086144759194834658830326105266222
    02018180</sourcecode>
<t>The u-coordinate is encoded in the usual fashion (i.e. without specifying the sign of v). </t>
<sourcecode>
  84 39 A5 21  13 F9 13 F0  7F F4 44 C0  DF 5D 44 DD
  DD F4 9B 87  4C DD E1 AB  64 00 8F A2  ED 9C AF 36</sourcecode>
<t>The first decryption contribution is generated from the secret scalar of the first key share and the public key of the ephemeral. </t>
<t>The outputs from the Montgomery Ladder are: </t>
<sourcecode>x_2 57800249527850149046770413207257250301842844049677844025524059085132
    359257003
z_2 37229326806761131733056994095424883574786241198535734197174081138402
    379671391
x_3 30722194817314627970562030033494699359853137448471883846088158083361
    967945513
z_3 29143359268139878301695995826542801325089258636824690596939399658126
    254126746</sourcecode>
<t>The coordinates of the corresponding point are: </t>
<sourcecode>u 2625200443692459084967263034650122583671912028244890150161521677645872
    8744244
v 2340339249609928967870268630489687123941624857494487121340604194885770
    7717709</sourcecode>
<t>The encoding of this point specifies the u coordinate and the sign (oddness) of the  v coordinate: </t>
<sourcecode>
  28 E5 5E 1D  DD 1D 93 71  24 53 0A 83  B3 68 0D 28
  8F 37 AC 53  B6 65 97 7E  C1 54 44 41  8C 16 49 16</sourcecode>
<t>The second decryption contribution is generated from the secret scalar of the second key share and the public key of the ephemeral in the same way: </t>
<sourcecode>u 2568180775076864300893967221119748767931055928591855851227298301978902
    8635830
v 5237624535641756510077423429806596028526835148653096601777403098805491
    0628425</sourcecode>
<sourcecode>
  28 E5 5E 1D  DD 1D 93 71  24 53 0A 83  B3 68 0D 28
  8F 37 AC 53  B6 65 97 7E  C1 54 44 41  8C 16 49 16</sourcecode>
<t>To obtain the key agreement value, we add the two decryption contributions: </t>
<sourcecode>u 5363809193902384353244842537457427150937755976201184630020143767288097
    6727749
v 2576238777948215852102595446870010694371604288066653261024661407554360
    2367190</sourcecode>
<t>This returns the same u coordinate value as before, allowing us to obtain the encoding  of the key agreement value and decrypt the message. </t>
</section>
<section title="Key Splitting X448" anchor="s-5_2_3"><t>The encryption key pair is </t>
<sourcecode>X448KeyA (X448)
    UDF:        ZAAA-ETHD-X44X-KEYA
    Scalar:     70596789123829480733485730386174565339013185647363028677
        7277621057939099785091228353248522408450794128800398810019569879
        502484967206280
    Encoded Private
  88 2D AF 58  10 66 9E 1E  F9 F2 C5 76  A2 00 86 F5
  B0 B9 C6 B9  E6 34 12 57  64 E3 63 B7  99 48 01 77
  9B A3 49 2D  7C B8 80 D7  63 44 6B C9  CB 83 F0 01
  B6 55 E0 92  1C 2A A6 F8
    U: 54256629638851994806054576189463839532492460394052748417730874429
        9533502601001906894660938607827805200569088593927035891085282184
        39174
    V: 12640494198304757803713993624351573936804262085795518571061045063
        1383333635306581037675004961525698205648857075020359124084524068
        583614
    Encoded Public
  06 FE 38 7A  1B 1E 99 D4  89 00 07 B9  88 6F 97 01
  BD 88 BB 9D  A9 31 30 CC  47 E6 2F 9C  44 35 AF A4</sourcecode>
<t>To create n key shares we first create n-1 key pairs in the normal fashion. Since  these key pairs are only used for decryption operations, it is not necessary to  calculate the public components: </t>
<sourcecode>X448Key1 (X448)
    UDF:        ZAAA-ETHD-X44X-KEYX
    Scalar:     63066265672668423343291438147840057172035337936373473359
        4300758463732521976388313294665447253881782852832499090049354258
        188417511652528
    Encoded Private
  B0 FC CE 55  87 AA A5 36  D2 5B E5 F2  5C 1B F7 9A
  5A 3D 97 D8  BB C0 81 84  98 3B 7C 29  C3 02 FC AE
  91 1B EA 67  68 C5 5E 87  7A ED 16 1F  CB D0 20 9D
  C0 D6 62 BD  0F 35 20 DE</sourcecode>
<t>The secret scalar of the final key share is the secret scalar of the base key minus the sum of the secret scalars of the other shares modulo the group order: </t>
<sourcecode>Scalar_2 = (Scalar_A - Scalar_1) mod L
    = 646627804476669823064550215361382899916128546345584148789705309556
        4959403070244163454368262048594523846084193642728800427461146131
        0355
This is encoded as a binary integer in little endian format:

  93 47 14 FF  94 BE F6 5C  77 63 44 89  DD CA 83 A6
  1A 79 82 CA  9E F6 6B 7D  98 23 59 77  60 4B FD 25
  2D BF 33 95  E4 7D DF 5E  DE 31 82 E8  96 54 11 9F
  76 2C 43 50  2C 5F C6 16</sourcecode>
</section>
<section title="Decryption X448" anchor="s-5_2_4"><t>The means of encryption is unchanged. We begin by generating an ephemeral  key pair: </t>
<sourcecode>X448KeyE (X448)
    UDF:        ZAAA-ETHD-X44X-KEYE
    Scalar:     40831502887772840901106715270468009328116701340228919444
        7950742749557088789408677311466089336893170031425082958041776608
        657845012501716
    Encoded Private
  D4 94 79 EE  56 3A 43 D5  FC EB 88 3E  F0 63 EF 2F
  B0 92 B2 9D  FD E1 43 8F  67 70 2A FC  2A AB A3 8B
  40 5A C6 D8  DE 8E B8 81  BF AD 17 BA  14 7F A4 B0
  D4 B1 9F CE  D3 0D D0 8F
    U: 41902542857582644710501442087876846551351583947506685319975417292
        1931242764163121977613761818608927787788470856012050834001655292
        441835
    V: 40254626888669687592165362896510117701831215997629302922912638410
        7109948063151002535904960734463095918076287222011626898597213849
        340021
    Encoded Public
  EB 34 D3 9E  92 3E 82 CC  E6 EC 77 9F  3D 11 83 3C
  B6 5B 5C 04  E8 1F D6 E1  07 C0 62 FE  F8 F6 34 BB</sourcecode>
<t>The key agreement result is given by multiplying the public key of the encryption  pair by the secret scalar of the ephemeral key to obtain the u-coordinate of the result. </t>
<sourcecode>U: 414519841929159382730636919036875317796178034011999213235983537052305
    106787024152424411931078767471781837755233750631283588936679550233</sourcecode>
<t>The u-coordinate is encoded in the usual fashion (i.e. without specifying the sign of v). </t>
<sourcecode>
  19 ED 3F 7A  63 6D AA 9A  3E 05 29 DE  CC BA C7 F1
  E0 A7 FA C0  C4 70 E0 E1  A5 FC DA 0A  B0 52 EC 8A</sourcecode>
<t>The first decryption contribution is generated from the secret scalar of the first key share and the public key of the ephemeral. </t>
<t>The outputs from the Montgomery Ladder are: </t>
<sourcecode>x_2 60087238657789265874539701675840521614326868580285788286550399232202
    7708113246880087865322820085919620753848185209702446811828858483595
z_2 12573140552649037921890899942919440571502561130496393232716617155244
    9066080557651788133951700597009878477147212706681069479775840967645
x_3 40216911160845555507626938485596306260547743077930604703891475599532
    0723805215287283180373439738964352905750714947142945295511147157394
z_3 48671808823760924633626118221453591105199403417491562559814414359340
    7933626543068597450465569884659930973430555454657130674077038979747</sourcecode>
<t>The coordinates of the corresponding point are: </t>
<sourcecode>u 5310627084956226133549480379012439149584638171147187426442235629260041
    86474991811830611467926523417739685244466041108245014409383321437
v 6480384951984610654865132490606294355962228129695701220316681167173896
    3455446043723779520423668998535402850812481731449606392177083381</sourcecode>
<t>The encoding of this point specifies the u coordinate and the sign (oddness) of the  v coordinate: </t>
<sourcecode>
  EB 34 D3 9E  92 3E 82 CC  E6 EC 77 9F  3D 11 83 3C
  B6 5B 5C 04  E8 1F D6 E1  07 C0 62 FE  F8 F6 34 BB</sourcecode>
<t>The second decryption contribution is generated from the secret scalar of the second key share and the public key of the ephemeral in the same way: </t>
<sourcecode>u 2432029307606011854651950642127064534858415441240032460817128643691026
    01495764607628214871657677482439232238254450281582409532827123057
v 3304237495909049135999182737314299324454426462198935317955136317282401
    67193898154033571033048069157608137872491595181800632292085611537</sourcecode>
<sourcecode>
  EB 34 D3 9E  92 3E 82 CC  E6 EC 77 9F  3D 11 83 3C
  B6 5B 5C 04  E8 1F D6 E1  07 C0 62 FE  F8 F6 34 BB</sourcecode>
<t>To obtain the key agreement value, we add the two decryption contributions: </t>
<sourcecode>u 2259776336573351712090323684006287979378142231675451855263136351631846
    27019682834233607456823018602790573389381890060345691088913511436
v 3356804465434915738990773252496451168197759413718456519751139752920227
    88339143143140400339843420207702195408750068698590142923542805226</sourcecode>
<t>This returns the same u coordinate value as before, allowing us to obtain the encoding  of the key agreement value and decrypt the message. </t>
</section>
</section>
</section>
<section title="Security Considerations" anchor="s-6"></section>
<section title="IANA Considerations" anchor="s-7"><t>This document requires no IANA actions.</t>
</section>
<section title="Acknowledgements" anchor="s-8"><t>Rene Struik, Tony Arcieri, Scott Fluhrer, Scott Fluhrer, Dan Brown, Mike Hamburg</t>
<t></t>
</section>
</middle>
<back>
<references title="Normative References"><reference anchor="RFC7748"><front>
<title>Elliptic Curves for Security</title>
<author fullname="A. Langley" initials="A." surname="Langley"><organization/>
<address>
</address>
</author>
<author fullname="M. Hamburg" initials="M." surname="Hamburg"><organization/>
<address>
</address>
</author>
<author fullname="S. Turner" initials="S." surname="Turner"><organization/>
<address>
</address>
</author>
<date month="January" year="2016"/>
</front>
<seriesInfo name="RFC" value="7748"/>
<seriesInfo name="DOI" value="10.17487/RFC7748"/>
</reference>
<reference anchor="RFC8032"><front>
<title>Edwards-Curve Digital Signature Algorithm (EdDSA)</title>
<author fullname="S. Josefsson" initials="S." surname="Josefsson"><organization/>
<address>
</address>
</author>
<author fullname="I. Liusvaara" initials="I." surname="Liusvaara"><organization/>
<address>
</address>
</author>
<date month="January" year="2017"/>
</front>
<seriesInfo name="RFC" value="8032"/>
<seriesInfo name="DOI" value="10.17487/RFC8032"/>
</reference>
<reference anchor="RFC2119"><front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname="S. Bradner" initials="S." surname="Bradner"><organization/>
<address>
</address>
</author>
<date month="March" year="1997"/>
</front>
<seriesInfo name="BCP" value="14"/>
<seriesInfo name="RFC" value="2119"/>
<seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>
<reference anchor="draft-ietf-lwig-curve-representations"><front>
<title>Alternative Elliptic Curve Representations</title>
<author fullname="Rene Struik" initials="R" surname="Struik"><organization/>
<address>
</address>
</author>
<date day="24" month="July" year="2019"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-ietf-lwig-curve-representations-08"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-ietf-lwig-curve-representations-08.txt"/>
<format type="PDF" target="http://www.ietf.org/internet-drafts/draft-ietf-lwig-curve-representations-08.pdf"/>
</reference>
</references>
<references title="Informative References"><reference anchor="RFC2631"><front>
<title>Diffie-Hellman Key Agreement Method</title>
<author fullname="E. Rescorla" initials="E." surname="Rescorla"><organization/>
<address>
</address>
</author>
<date month="June" year="1999"/>
</front>
<seriesInfo name="RFC" value="2631"/>
<seriesInfo name="DOI" value="10.17487/RFC2631"/>
</reference>
<reference anchor="draft-hallambaker-mesh-architecture"><front>
<title>Mathematical Mesh 3.0 Part I: Architecture Guide</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker"><organization/>
<address>
</address>
</author>
<date day="23" month="October" year="2019"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-mesh-architecture-11"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-mesh-architecture-11.txt"/>
</reference>
<reference anchor="draft-hallambaker-mesh-developer"><front>
<title>Mathematical Mesh: Reference Implementation</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker"><organization/>
<address>
</address>
</author>
<date day="23" month="October" year="2019"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-mesh-developer-09"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-mesh-developer-09.txt"/>
</reference>
<reference anchor="Kocher96"><front>
<title>[Reference Not Found!]</title>
<author initials="" surname=""><organization/>
<address>
</address>
</author>
<date/>
</front>
</reference>
<reference anchor="Lopez99"><front>
<title>[Reference Not Found!]</title>
<author initials="" surname=""><organization/>
<address>
</address>
</author>
<date/>
</front>
</reference>
<reference anchor="Okeya01"><front>
<title>[Reference Not Found!]</title>
<author initials="" surname=""><organization/>
<address>
</address>
</author>
<date/>
</front>
</reference>
<reference anchor="Costello17"><front>
<title>[Reference Not Found!]</title>
<author initials="" surname=""><organization/>
<address>
</address>
</author>
<date/>
</front>
</reference>
</references>
</back>
</rfc>
