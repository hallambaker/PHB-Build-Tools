<?xml version="1.0" encoding="utf-8"?>
<!--This file was generated using RFCTool-->
<topic id="9a1e36d4-be25-49e5-8182-8eebe08681d8" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!--The Abstract-->
    <introduction>
      <para>
        The parser libraries provide a means of serializing and deserializing data to and from ASN.1, JSON or TLS schema formats and encoding and decoding XML, HTML and Markdown texts.  
      </para>
      <para>
        At present the data encoding libraries use an assortment of schema definition languages. It is hoped that at some point it will be possible to use a single schema language to serve all the formats. 
      </para>
      <para>
        The document handling libraries convert all input text to a stripped form which corresponds loosely to HTML/2.0 or Markdown. 
      </para>
    </introduction>
    <!--The Body-->
    <section>
      <title> FSR Specification File </title>
      <content>
        <para>
          FSR is a tool from builting Finite State Recognizers from the state transition  table. The reason this approach is preferred over the Regular Expressions used in the traditional Lex, is that it makes it much easier to specify actions. 
        </para>
        <para>
          The following text fragment shows an FSR for parsing command line input.  
        </para>
        <para>
           The first line specifies the namespace and class to generate. 
        </para>
        <para>
           The Charset entries specify character ranges for later use.  These are not actually needed in the example though. 
        </para>
        <para>
           The Token entries declare output tokens. The string id just for documentation. 
        </para>
        <para>
           The State entries declare the set of FSR states and the transitions out of that state. 
        </para>
        <code language="none">
          <![CDATA[FSR Goedel.Registry CommandLex

	Charset Digit		"0" "9"
	Charset alpha		"a" "z"
	Charset ALPHA		"A" "Z"

	Token Empty		""
	Token Value			"example.file"
	Token Flag			"/flag"
	Token FlagValue		"/flag:example.file"


	
	State ItemStart Reset Empty		// Start of file
		On " \t\n" GoTo Fail
		On "/-" GoTo StartFlag
		Any GoTo IsValue

	State IsValue AddValue Value
		Any GoTo IsValue

	State StartFlag Ignore Flag
		Any GoTo IsFlag

	State IsFlag AddFlag Flag
		On ":=" GoTo StartFlagValue
		Any GoTo IsFlag

	State StartFlagValue Ignore FlagValue
		Any GoTo IsFlagValue		

	State IsFlagValue AddValue FlagValue
		Any GoTo IsFlagValue		

	State Fail Abort Empty]]>
        </code>
      </content>
    </section>
    <section>
      <title> Callback code </title>
      <content>
        <para>
          The FSR tool generates a class that calls a set of methods specified in the State entries. In this case our methods are: 
        </para>
        <para>
           Reset 
        </para>
        <para>
           AddValue 
        </para>
        <para>
           AddFlag 
        </para>
        <para>
           Ignore 
        </para>
        <para>
           Fail 
        </para>
        <para>
          Unlike other Goedel tools, FSR does not generate dummy virtual methods  to be overwritten in code. These must be specified for the example to compile: 
        </para>
        <code language="none">
          <![CDATA[namespace Goedel.Registry {
    public partial class CommandLex {
        /// &amp;lt;summary&amp;gt;
        /// Return the resulting string value
        /// &amp;lt;/summary&amp;gt;
        public string Value { get =&amp;gt; BuildValue.ToString(); }

        /// &amp;lt;summary&amp;gt;
        /// Return the resulting string value
        /// &amp;lt;/summary&amp;gt;
        public string Flag { get =&amp;gt; BuildFlag.ToString(); }

        StringBuilder BuildValue = new StringBuilder();
        StringBuilder BuildFlag = new StringBuilder();

        /// &amp;lt;summary&amp;gt;
        /// Reset the value buffers to start a new parse.
        /// &amp;lt;/summary&amp;gt;
        public override void Reset () {
            BuildValue.Clear();
            BuildFlag.Clear();
            }

        /// &amp;lt;summary&amp;gt;
        /// Add a character to the value buffer
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name="c"&amp;gt;The character read&amp;lt;/param&amp;gt;
        public virtual void AddValue (int c) {
            BuildValue.Append((char)c);
            }

		... other implementation methods.
		}
	}]]>
        </code>
      </content>
    </section>
    <section>
      <title>LexReader Library </title>
      <content>
        <code language="none">
          <![CDATA[        /// &amp;lt;summary&amp;gt;
        /// Construct a parser to read from a string to be specified in GetToken (data)
        /// &amp;lt;/summary&amp;gt;
        LexStringReader LexStringReader;
        public CommandLex () {
            LexStringReader = new LexStringReader(null);
            Reader = LexStringReader;
            }

        /// &amp;lt;summary&amp;gt;
        /// Parse the specified string. Note, this is only valid if no LexReader
        /// was specified in the constructor.
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name="Data"&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Token GetToken (string Data) {
            LexStringReader.String = Data;
            Reset();
            return GetToken();
            }]]>
        </code>
      </content>
    </section>
    <!--References-->
    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
