<?xml version="1.0" encoding="utf-8"?>
<!--This file was generated using RFCTool-->
<topic id="f49b1505-1206-4ffe-8f23-43f42f61e4bd" revisionNumber="1">
  <developerConceptualDocument xmlns="http://ddue.schemas.microsoft.com/authoring/2003/5" xmlns:xlink="http://www.w3.org/1999/xlink">
    <!--The Abstract-->
    <introduction>
      <para>
        The cryptography libraries provide a single consistent high level interface  to all the cryptographic resources used in the Mathematical Mesh. 
      </para>
    </introduction>
    <!--The Body-->
    <section>
      <title> Cryptography Libraries </title>
      <content>
        <para>
          The Cryptography libraries are organized around the following principal classes 
        </para>
        <definitionTable>
          <definedTerm>
            CryptoCatalog 
          </definedTerm>
          <definition>
            <para>
              A Registry that permits a CryptoProvider or CryptoAlgorithm to be obtained. 
            </para>
          </definition>
          <definedTerm>
            CryptoAlgorithmID 
          </definedTerm>
          <definition>
            <para>
              Enumeration that represents a cryptographic algorithm. This may be a bulk algorithm, a meta algorithm or a combination of the two. For example, digest and signature or encryption and exchange. 
            </para>
          </definition>
          <definedTerm>
            CryptoAlgorithm 
          </definedTerm>
          <definition>
            <para>
              Describes a cryptographic algorithm and contains factories for Key and CryptoProvider classes. 
            </para>
          </definition>
          <definedTerm>
            Key 
          </definedTerm>
          <definition>
            <para>
              Base class for all cryptographic keys, whether symmetric or asymmetric. 
            </para>
          </definition>
          <definedTerm>
            CryptoProvider 
          </definedTerm>
          <definition>
            <para>
              Base class for all classes that perform operations on *CryptoData* using a *Key* 
            </para>
          </definition>
          <definedTerm>
            CryptoProcessor 
          </definedTerm>
          <definition>
            <para>
              Base class for CryptoDataEncoder and CryptoDecoder  
            </para>
          </definition>
          <definedTerm>
            CryptoData 
          </definedTerm>
          <definition>
            <para>
              Base class for all ciphertext, plaintext and associated data. 
            </para>
          </definition>
        </definitionTable>
      </content>
      <sections>
        <section>
          <title>Initialization </title>
          <content>
            <para>
              One of the core goals of the Mesh project is to enable applications to make direct access to the security features provided by the host machine. Cryptographic keys should be stored using all the protections provided by the host, not the lowest common denominator supported by all the hosts. So even though the libraries are implemented in C# which generates platform independent code, applications should link to the support library for the specific platform. 
            </para>
            <para>
              The library Goedel.Cryptography does not provide access to any cryptographic algorithm providers. To make use of the library it is necessary to link to either  Goedel.Cryptography.Windows, Goedel.Cryptography.OSX or Goedel.Cryptography.Linux and  make a call to the corresponding initialize method as follows: 
            </para>
            <code language="none">
              <![CDATA[using Goedel.Mesh.Platform.Windows;
...

namespace foo {
    public void TestInitialize() {
        CryptographyWindows.Initialize(TestMode);
        }
	}]]>
            </code>
            <para>
              It is only necessary to call the initializer once per process. Once the library is  initialized, further attempts to initialize the library are ignored. 
            </para>
          </content>
        </section>
        <section>
          <title>The Algorithm Catalog </title>
          <content>
            <para>
              The catalog provides a means of locating CryptoAlgorithm descriptions of algorithms and factory methods for the corresponding providers.  
            </para>
            <para>
              The algorithm identifier used inside the libraries is the CryptoAlgorithmID enumeration,  which may be used to identify a bulk algorithm, a meta algorithm (i.e. signature,  exchange or keywrap) or a combination of the two. 
            </para>
            <para>
              Additional routines provide means of converting between  CryptoAlgorithmID identifiers and the identifiers used in encodings such as OIDs, URIs, PEM names and JSON names. 
            </para>
            <para>
              The catalog is initialized with entries for the algorithms supported by the platform cryptography providers. This insulates the library code from the current transition between the providers supported in the .NET Framework,  .NET Core and .NET Standard libraries. 
            </para>
            <para>
              Note that it is permitted to have more than one provider for a given algorithm in the catalog. This permits support for cryptographic hardware. 
            </para>
          </content>
          <sections>
            <section>
              <title>Discovery by ID or Name </title>
              <content>
                <para>
                  To make use of an algorithm, we may locate a provider by CryptoAlgorithmID which is  typically obtained from an encoding specific identifier. 
                </para>
                <para>
                  The following example shows a JSON algorithm identifier (RSA Signature with SHA-2-512 digest) being converted to an algorithm identifier which is then used to obtain an encoder which is used to process the data: 
                </para>
                <code language="none">
                  <![CDATA[    var DigestID = "RS512".FromJoseID();
    var Encoder = CryptoCatalog.Default.GetDigest(DigestID);
    var DigestOfData = Encoder.Process(Data);]]>
                </code>
                <para>
                  Note that it is not necessary to break out the digest component from the combined identifier, this is performed automatically by the GetDigest method.  
                </para>
              </content>
            </section>
            <section>
              <title>Shortcut Discovery </title>
              <content>
                <para>
                  For convenience, the Platform class provides static links to the default CryptoAlgorithm entries for the most commonly used algorithms: 
                </para>
                <para>
                   SHA-2 256 and 512 bit 
                </para>
                <para>
                   SHA-1 (deprecated) 
                </para>
                <para>
                   HMAC-SHA-2 256 and 512 bit 
                </para>
                <para>
                   AES-CBC 256 bit 
                </para>
                <para>
                   RSA Signature 
                </para>
                <para>
                   RSA Encryption 
                </para>
                <para>
                   DH Exchange 
                </para>
                <code language="none">
                  <![CDATA[var Digest = Platform.SHA2_256;
var Result = Digest.Process(TestString);
var Text = BaseConvert.ToBase16String(Result);]]>
                </code>
              </content>
            </section>
            <section>
              <title>Converting between identifiers </title>
              <content>
                <para>
                  For convenience, a set of Extension methods are defined for converting between ASN.1, XML and JSON identifiers and the library identifiers. These are: 
                </para>
                <para>
                   CryptoAlgorithmID FromXMLID (this string URL) 
                </para>
                <para>
                   CryptoAlgorithmID FromOID(this string OID) 
                </para>
                <para>
                   CryptoAlgorithmID FromJoseID (this string JoseID)  
                </para>
                <para>
                   string ToOID(this CryptoAlgorithmID ID) 
                </para>
                <para>
                   string ToXMLID(this CryptoAlgorithmID ID) 
                </para>
                <para>
                   string ToJoseID(this CryptoAlgorithmID ID)  
                </para>
              </content>
            </section>
            <section>
              <title>Operations on Algorithm Identifiers </title>
              <content>
                <para>
                  Extract specific parts of an algorithm identifier: 
                </para>
                <para>
                   static CryptoAlgorithmID Bulk (this CryptoAlgorithmID ID)  
                </para>
                <para>
                   static CryptoAlgorithmID Meta(this CryptoAlgorithmID ID) 
                </para>
                <para>
                  To extract a specific algorithm type: 
                </para>
                <para>
                   static CryptoAlgorithmID Digest(this CryptoAlgorithmID ID)  
                </para>
                <para>
                   static CryptoAlgorithmID MAC(this CryptoAlgorithmID ID) 
                </para>
                <para>
                   static CryptoAlgorithmID Encryption(this CryptoAlgorithmID ID) 
                </para>
                <para>
                   static CryptoAlgorithmID Mode(this CryptoAlgorithmID ID) 
                </para>
                <para>
                   static CryptoAlgorithmID Signature(this CryptoAlgorithmID ID) 
                </para>
                <para>
                   static CryptoAlgorithmID Exchange(this CryptoAlgorithmID ID) 
                </para>
                <para>
                  The Meta and/or Bulk entries in an Algorithm identifier may have the value Default. The CryptoCatalog class provides the following methods override default entries to the defaults for that type of algorithm in the catalog: 
                </para>
                <para>
                   SignatureDefaults 
                </para>
                <para>
                   EncryptionDefaults 
                </para>
              </content>
            </section>
          </sections>
        </section>
        <section>
          <title>Creating Keys </title>
          <content>
            <para>
              Key creation is a two step process. 
            </para>
            <listItem>
              <para>
                 A provider is created for the desired algorithm 
              </para>
            </listItem>
            <listItem>
              <para>
                 Generation of a keypair with the specified key size is requested of the provider. 
              </para>
            </listItem>
            <code language="none">
              <![CDATA[Encrypter = CryptoCatalog.Default.GetExchange(CryptoAlgorithmID.RSAExch);
Encrypter.Generate(KeySecurity.Ephemeral, KeySize: 2048);]]>
            </code>
            <para>
              The KeySecurity enumeration specifies the level of security to be applied to a key, whether it should be persisted in long term storage and whether it may be exported or not. 
            </para>
            <para>
              Marking the key ephemeral in the above example means that it will be deleted after use and the API does not support export. Note however that while it is highly desirable for  a platform to support hardware measures that prevent export of keys marked as such, most platforms do not provide that level of security. 
            </para>
          </content>
        </section>
        <section>
          <title>JSON Object Signing and Encryption </title>
          <content>
            <para>
              The Goedel.Cryptography.Jose namespace supports JSON Object Signing and Encryption. 
            </para>
          </content>
          <sections>
            <section>
              <title>Simple signing and encryption </title>
              <content>
                <para>
                  Convenience routines are provided to sign and encrypt compact data.  These may be used to operate on: 
                </para>
                <para>
                   Binary data (byte[]) 
                </para>
                <para>
                   UTF8 Encoded string (string) 
                </para>
                <para>
                   JSON Object (Class inheriting from JSONObject) 
                </para>
                <para>
                  Implementations should make use of the convenience routines wherever possible as this  will allow them to automatically take advantage of implementations that make use of  streaming when this is implemented. 
                </para>
                <para>
                  Signing: 
                </para>
                <code language="none">
                  <![CDATA[var JWS = new JoseWebSignature(TestString, SignerKeyPair);]]>
                </code>
                <para>
                  Encryption: 
                </para>
                <code language="none">
                  <![CDATA[var JWE = new JoseWebEncryption(TestString, EncrypterKeyPair);]]>
                </code>
                <para>
                  Signing and Encryption: 
                </para>
                <code language="none">
                  <![CDATA[var JWES = new JoseWebEncryption(TestString, EncrypterKeyPair, SignerKeyPair);]]>
                </code>
              </content>
            </section>
            <section>
              <title>Multiple Signers </title>
              <content>
                <para>
                  To add a signer to an existing JWS, the AddSignature method is used: 
                </para>
                <code language="none">
                  <![CDATA[AddSignature(SigningKey);]]>
                </code>
              </content>
            </section>
            <section>
              <title>Multiple Recipients </title>
              <content>
                <para>
                  To add recipient to an existing JWE, the AddSignature method is used: 
                </para>
                <code language="none">
                  <![CDATA[AddRecipient(EncryptionKey);]]>
                </code>
              </content>
            </section>
            <section>
              <title>Signing and Encrypting streamed data </title>
              <content>
                <para>
                  At present the libraries do not support processing of streamed data. This is due to  an intentional decision to defer this work until a suitable format for this type of data  has been developed. 
                </para>
              </content>
            </section>
          </sections>
        </section>
      </sections>
    </section>
    <!--References-->
    <relatedTopics>
    </relatedTopics>
  </developerConceptualDocument>
</topic>
