#script 1.0
#license MITLicense
#xclass Goedel.Tool.Command GenerateCS
#%  public GenerateCS (TextWriter Output) : base (Output) {}
#!
#! To Do list:
#!
#!	*	Should sense the console width and properly format the usage output
#!	*	Should support brief descriptions of the options and output on usage
#!  *	Write backing code for ExistingFile NewFile Directory etc
#!	*	Support for shell mode
#!	*	Default command
#!	*	Predispatch call
#!  *	Allow debug stubs to be turned off to make code compact
#!
#% TYPE<_Choice> TypeType;
#% CommandParse CommandParse;
#% Separator Separator = new Separator (",");
#% string NameClassType = "Goedel.Registry.Type";
#% string NameClassFile = "Goedel.Registry._File";
#% string NameClassFlag = "Goedel.Registry._Flag";
#% string NameDispatchType = "Goedel.Registry.Dispatch";
#% Command DefaultCommand = null;


#method Generate CommandParse CommandParseIn
#% Goedel.Registry.Boilerplate.Header (_Output, "//  ", CommandParseIn.Options.Started);

#! Goedel.Registry.Script.MITLicense (_Output, "//", 
#!			Goedel.Registry.Script.AssemblyCopyright, Goedel.Registry.Script.AssemblyCompany);
#% GenerateX (CommandParseIn);
#end method


#method GenerateX CommandParse CommandParseIn
#% CommandParse = CommandParseIn;
#% CommandParse.Init();
#% TypeType = CommandParse.Registry.FindType ("TypeType");
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;

#foreach (_Choice Item in CommandParse.Top)
#switchcast CommandParseType Item
#casecast Class null
#call GenerateClass (Class)Item
#end switchcast
#end foreach

#end method

#% void GenerateCommandEntries (List<_Choice> Entries) {
#foreach (_Choice Entry in Entries)
#switchcast CommandParseType Entry
#casecast CommandSet Cast
#{Separator}
				{"#{Cast.Tag.ToLower()}", DescribeCommandSet_#{Cast.Id}}#!
#casecast Command Cast
#{Separator}
				{"#{Cast.Tag.ToLower()}", _#{Cast.Id}._DescribeCommand }#!
#casecast About Cast
#{Separator}
				{"#{Cast.Tag.ToLower()}", _About }#!
#end switchcast
#end foreach
#% }

#method GenerateClass Class Class
namespace #{Class.Namespace} {
    public partial class CommandLineInterpreter : CommandLineInterpreterBase {


		static char UnixFlag = '-';
		static char WindowsFlag = '/';

        static bool IsFlag(char c) {
            return (c == UnixFlag) | (c == WindowsFlag) ;
            }

#foreach (_Choice Entry in Class.Entries)
#switchcast CommandParseType Entry
#casecast CommandSet Cast
#% Separator.IsFirst = true;
		static DescribeCommandSet DescribeCommandSet_#{Cast.Id} = new DescribeCommandSet () {
            Identifier = "#{Cast.Tag.ToLower()}",
			Entries = new  SortedDictionary<string, DescribeCommand> () {#!
#call GenerateCommandEntries Cast.Entries

				} // End Entries
			};
#end switchcast
#end foreach

        static CommandLineInterpreter () {
            System.OperatingSystem OperatingSystem = System.Environment.OSVersion;

            if (OperatingSystem.Platform == PlatformID.Unix |
                    OperatingSystem.Platform == PlatformID.MacOSX) {
                FlagIndicator = UnixFlag;
                }
            else {
                FlagIndicator = WindowsFlag;
                }

#if (Class.DefaultCommand != null)
				DefaultCommand = _#{Class.DefaultCommand.Id}._DescribeCommand;
#end if
#if (Class.Description != null)
				Description = "#{Class.Description}";
#end if

			Entries = new  SortedDictionary<string, DescribeCommand> () {#!
#% Separator.IsFirst = true;
#call GenerateCommandEntries Class.Entries
#{Separator}
				{"help", _Brief }
				}; // End Entries



            }

#foreach (_Choice Entry in Class.Entries)
#switchcast CommandParseType Entry
#casecast About Cast
        public static DescribeCommandEntry _About = new DescribeCommandEntry() {
            Identifier = "about",
            HandleDelegate = About,
			Entries = new  List<DescribeEntry> () {}
            };
#casecast Brief Cast
        public static DescribeCommandEntry _Brief = new DescribeCommandEntry() {
            Identifier = "help",
            HandleDelegate = Brief,
			Entries = new  List<DescribeEntry> () {}
            };
#end switchcast
#end foreach


#if CommandParse.Main
        static void Main(string[] args) {
			var CLI = new CommandLineInterpreter ();
			CLI.MainMethod (args);
			}
#else

#end if
        public void MainMethod(string[] args) {

			#{Class.Id} Dispatch = new #{Class.Id} ();


#if CommandParse.Catcher
			try {
#end if
				Assert.False (args.Length == 0, NoCommand.Throw);

                if (IsFlag(args[0][0])) {
					Dispatcher (Entries, Dispatch, args, 0);
                    }
                else {
#if DefaultCommand != null
					Handle_#{DefaultCommand.Id} (Dispatch, args, 0);
#else
                    Assert.True (false, NoCommand.Throw);
#end if
                    }
#if CommandParse.Catcher
				}

            catch (ParserException) {
			    Brief ();
				}

            catch (System.Exception Exception) {
                Console.WriteLine("Application: {0}", Exception.Message);
                }
#end if
            } // Main


#foreach (_Choice Entry in Class.Entries)
#switchcast CommandParseType Entry
#casecast Command Command
#% CommandHandler (Command, Class);
#casecast CommandSet CommandSet
#foreach (var Inner in CommandSet.Entries)
#switchcast CommandParseType Inner
#casecast Command Command
#% CommandHandler (Command, Class);
#end switchcast
#end foreach
#end switchcast
#end foreach


	} // class Main


	// The stub class for carrying optional parameters for each command type
	// As with the main class each consists of an abstract main class 
	// with partial virtual that can be extended as required.

	// All subclasses inherit from the abstract classes Goedel.Regisrty.Dispatch 
	// and Goedel.Registry.Type

#foreach (_Choice Entry in Class.Entries)
#switchcast CommandParseType Entry
#casecast OptionSet OptionSet
	public interface I#{OptionSet.Id} {
#foreach (_Choice OptionC in OptionSet.Options)
#switchcast CommandParseType OptionC
#casecast Option Option
		#{Option.Type}			#{Option.Name}{get; set;}
#end switchcast
#end foreach
		}

#casecast Command Cast
#call CommandOptionClass Cast
#casecast CommandSet CommandSet
#foreach (var Inner in CommandSet.Entries)
#switchcast CommandParseType Inner
#casecast Command Command
#call CommandOptionClass Command
#end switchcast
#end foreach
#end switchcast
#end foreach

#! This section contains declarations for the builtins and types.
#!
#foreach (ID<_Choice> ID in TypeType.IDs)
    // Parameter type #{ID}
#if (ID.ToString() == "NewFile") | (ID.ToString() == "ExistingFile")
    public abstract class _#{ID} : #{NameClassFile} {
#elseif (ID.ToString() == "Flag")
    public abstract class _#{ID} : #{NameClassFlag} {
#else
    public abstract class _#{ID} : #{NameClassType} {
#end if
        public _#{ID}() {
            }

#if CommandParse.Builtins
#if (ID.ToString() == "Flag")
#elseif (ID.ToString() == "NewFile")
#elseif (ID.ToString() == "ExistingFile")
#else
		public string			Value {
			get => Text;
			}
#end if
#end if

        } // _#{ID}

    public partial class  #{ID} : _#{ID} {
        public #{ID}() {
            }
			
        public static #{ID} Factory (string Value) {
            var Result = new #{ID}();
            Result.Default(Value);
            return Result;
            }

        } // #{ID}


#end foreach


	// The stub class just contains routines that echo their arguments and
	// write 'not yet implemented'

	// Eventually there will be a compiler option to suppress the debugging
	// to eliminate the redundant code
    public class _#{Class.Id} : global::Goedel.Registry.DispatchShell {

#foreach (_Choice Entry in Class.Entries)
#switchcast CommandParseType Entry
#casecast Command Command
#call CommandMethod Command
#casecast CommandSet CommandSet
#foreach (var Inner in CommandSet.Entries)
#switchcast CommandParseType Inner
#casecast Command Command
#call CommandMethod Command
#end switchcast
#end foreach
#end switchcast
#end foreach

        } // class _#{Class.Id}

    public partial class #{Class.Id} : _#{Class.Id} {
        } // class #{Class.Id}

    } // namespace #{Class.Id}

#end method
// Types
//      NewFile   ExistingFile
//		Flag, String, Integer, enumeration

#method2 CommandHandler Command Command Class Class
		private enum TagType_#{Command.Id} {
#foreach (_Choice CommandEntry in Command.Entries)
#switchcast CommandParseType CommandEntry
#casecast Parameter Param
			#{Param.Name},
#casecast Parser Param
			#{Param.Class},
#casecast Option Param
			#{Param.Name},
#casecast Lazy Param
			#{Param.Name},
#casecast Script Param
			#{Param.Id},
#end switchcast
#end foreach			
			}

		public static void Handle_#{Command.Id} (
					DispatchShell  DispatchIn, string[] Args, int Index) {
			#{Class.Id} Dispatch =	DispatchIn as #{Class.Id};
			#{Command.Id}		Options = new #{Command.Id} ();
			ProcessOptions (Args, Index, Options);
			Dispatch.#{Command.Id} (Options);
			}
#end method2

#method CommandMethod Command Command
#% bool DefaultOutput = true;
#% string Lazy = null;
#foreach (_Choice CommandEntry in Command.Entries)
#switchcast CommandParseType CommandEntry
#casecast Parser null
#% DefaultOutput = false;
#casecast Generator null
#% DefaultOutput = false;
#casecast Script null
#% DefaultOutput = false;
#casecast Lazy Cast
#% Lazy = Cast.Name.ToString ();
#end switchcast
#end foreach
		public virtual void #{Command.Id} ( #{Command.Id} Options) {
#if DefaultOutput
			CommandLineInterpreter.DescribeValues (Options);
#else
			string inputfile = null;

#foreach (_Choice CommandEntry in Command.Entries)
#switchcast CommandParseType CommandEntry
#casecast Parser Parser
			inputfile = Options.#{Parser.Class}.Text;

            #{Parser.Namespace}.#{Parser.Class} Parse = new #{Parser.Namespace}.#{Parser.Class}() {
#foreach (_Choice CommandEntry2 in Command.Entries)
#switchcast CommandParseType CommandEntry2
#casecast Option Option
			    #{Option.Name} = Options.#{Option.Name}.Value,
#end switchcast
#end foreach
				Options = Options
				};
        
			
			using (Stream infile =
                        new FileStream(inputfile, FileMode.Open, FileAccess.Read)) {

                Lexer Schema = new Lexer(inputfile);

                Schema.Process(infile, Parse);
                }

#casecast Generator null
#end switchcast
#end foreach

#foreach (_Choice CommandEntry in Command.Entries)
#switchcast CommandParseType CommandEntry
#casecast Script Script
			// Script output of type #{Script.Id} #{Script.Extension}
			if (Options.#{Script.Id}.Text != null) {
				string outputfile = FileTools.DefaultOutput (inputfile, Options.#{Script.Id}.Text, 
					Options.#{Script.Id}.Extension);
#if Lazy != null
				if (Options.#{Lazy}.IsSet & FileTools.UpToDate (inputfile, outputfile)) {
					return;
					}
				using (Stream outputStream =
							new FileStream(outputfile, FileMode.Create, FileAccess.Write)) {
					using (TextWriter OutputWriter = new StreamWriter(outputStream, Encoding.UTF8)) {

						#{Script.Namespace}.#{Script.Class} Script = new #{Script.Namespace}.#{Script.Class} (OutputWriter);

						Script.#{Script.Id} (Parse);
						}
					}
#end if		
				}
#end switchcast
#end foreach
#end if
			}

#end method

#method CommandOptionClass Command Command

    public class _#{Command.Id} : #{NameDispatchType} #!
#foreach (_Choice OptionC in Command.Entries)
#switchcast CommandParseType OptionC
#casecast Include Include
,
							I#{Include.Id}#!
#end switchcast
#end foreach
 {

		public override Goedel.Registry.Type[] _Data {get; set;} = new Goedel.Registry.Type [] {#!
#% Separator.IsFirst = true;
#foreach (var Entry in Command.EntryItems)
#{Separator}
			new #{Entry.Type} ()#!
#end foreach
			} ;

#foreach (var Entry in Command.EntryItems)
#% var Item = Entry.Item;
		/// <summary>Field accessor for #{Entry.IsOption.If("option","parameter")} [#{Entry.Tag}]</summary>
		public virtual #{Entry.Type} #{Entry.ID} {
			get => _Data[#{Entry.Index}] as #{Entry.Type};
			set => _Data[#{Entry.Index}]  = value;
			}
#end foreach

		public static DescribeCommandEntry _DescribeCommand = new  DescribeCommandEntry () {
			Identifier = "#{Command.Tag.ToLower()}",
			Brief =  "#{Command.Brief}",
			HandleDelegate =  CommandLineInterpreter.Handle_#{Command.Id},
			Lazy =  #{Command.Lazy.If("true","false")},
#!			Parser =  "#{Command.Parser}",
			Entries = new List<DescribeEntry> () {#!
#% Separator.IsFirst = true;
#foreach (var EntryItem in Command.EntryItems)
#% var Item = EntryItem.Item;
#{Separator}
				new DescribeEntryParameter () {
					Identifier = "#{EntryItem.ID}", 
					Default = "#{EntryItem.Default}",
					Brief = "#{EntryItem.Brief}",
					Index = #{EntryItem.Index},
					Key = "#{EntryItem.Tag.ToLower()}"
					}#!
#end foreach

				}
			};

		}

    public partial class #{Command.Id} : _#{Command.Id} {
        } // class #{Command.Id}
#end method


#end xclass
