// Script Syntax Version:  1.0

//  Unknown by Unknown
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
using System;
using System.IO;
using System.Collections.Generic;
using Goedel.Registry;
namespace GoedelSchema {
	/// <summary>A Goedel script.</summary>
	public partial class GenerateParser : global::Goedel.Registry.Script {
		/// <summary>Default constructor.</summary>
		public GenerateParser () : base () {
			}
		/// <summary>Constructor with output stream.</summary>
		/// <param name="Output">The output stream</param>
		public GenerateParser (TextWriter Output) : base (Output) {
			}

		 Goedel Goedel;
		

		//
		// GenerateCS
		//
		public void GenerateCS (Goedel GoedelIn) {
			 Goedel = GoedelIn;
			 // Boilerplate.Header (_Output, "//  ", GenerateTime);
			foreach  (_Choice Item in Goedel.Top) {
				switch (Item._Tag ()) {
					case GoedelType.Copyright: {
					  Copyright Copyright = (Copyright) Item; 
					switch (Copyright.License._Tag ()) {
						case GoedelType.MITLicense: { 
						
						 Boilerplate.MITLicense (_Output, "//  ", "Copyright (c) " + Copyright.Date, Copyright.Holder);
						break; }
						case GoedelType.BSD2License: { 
						
						 Boilerplate.BSD2License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
						break; }
						case GoedelType.BSD3License: { 
						
						 Boilerplate.BSD3License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
						break; }
						case GoedelType.ISCLicense: { 
						
						 Boilerplate.ISCLicense (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
						break; }
						case GoedelType.Apache2License: { 
						
						 Boilerplate.Apache2License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
						break; }
						case GoedelType.OtherLicense: {
						  OtherLicense License = (OtherLicense) Copyright.License; 
						_Output.Write ("// Copyright (1) {1} by {2}\n{0}", _Indent, Copyright.Date, Copyright.Holder);
						_Output.Write ("// {1}\n{0}", _Indent, License.Text);
					break; }
						}
				break; }
					}
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("// This file is automatically generated from the following source files:\n{0}", _Indent);
			foreach  (Source File in Goedel.Registry.Files) {
				_Output.Write ("// Input file  {1}\n{0}", _Indent, File.Name);
				}
			_Output.Write ("// Command line options: \n{0}", _Indent);
			_Output.Write ("//     /dlexer={1}\n{0}", _Indent, GoedelIn.DebugLexer);
			_Output.Write ("//     /dparser={1}\n{0}", _Indent, GoedelIn.DebugParser);
			_Output.Write ("//     /dstack={1}\n{0}", _Indent, GoedelIn.DebugStack);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("using System;\n{0}", _Indent);
			_Output.Write ("using System.Collections.Generic;\n{0}", _Indent);
			_Output.Write ("using System.IO;\n{0}", _Indent);
			_Output.Write ("using System.Text;\n{0}", _Indent);
			_Output.Write ("using Goedel.Registry;\n{0}", _Indent);
			_Output.Write ("using Goedel.Utilities;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Goedel.Top) {
				if (  (Item._Tag() ==  GoedelType.Class) ) {
					GenerateClass ((Class)Item);
					}
				}
			_Output.Write ("\n{0}", _Indent);
			}
		

		//
		// GenerateClass
		//
		public void GenerateClass (Class Class) {
			 TYPE<_Choice> IdTYPE = Goedel.Registry.FindType ("IdType");
			 TYPE<_Choice> TokenTYPE = Goedel.Registry.FindType ("TokenType");
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("//\n{0}", _Indent);
			_Output.Write ("// Namespace {1}\n{0}", _Indent, Class.Namespace);
			_Output.Write ("// Class {1}\n{0}", _Indent, Class.Name);
			_Output.Write ("//\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("// Types\n{0}", _Indent);
			foreach  (TYPE<_Choice> Type in Goedel.Registry.Types) {
				_Output.Write ("//   {1}\n{0}", _Indent, Type.Label);
				foreach  (ID<_Choice> ID in Type.IDs) {
					_Output.Write ("//       {1}\n{0}", _Indent, ID);
					}
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("namespace {1} {{\n{0}", _Indent, Class.Namespace);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("    public enum {1}Type {{\n{0}", _Indent, Class.Name);
			_Output.Write ("        _Top,\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					} else if (  (Item._Tag() == GoedelType.Type)) {
					 Type T = (Type) Item;
					 ID = T.Id.ToString();
					}
				_Output.Write ("        {1},\n{0}", _Indent, ID);
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        _Label,\n{0}", _Indent);
			_Output.Write ("        _Bottom\n{0}", _Indent);
			_Output.Write ("        }}    \n{0}", _Indent);
			_Output.Write ("    \n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("    public abstract partial class _Choice {{\n{0}", _Indent);
			_Output.Write ("        abstract public {1}Type _Tag ();\n{0}", _Indent, Class.Name);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		public abstract void Serialize (StructureWriter Output, bool tag);\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		public virtual void Init (_Choice Parent) {{\n{0}", _Indent);
			_Output.Write ("			}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		bool _Initialized = false;\n{0}", _Indent);
			_Output.Write ("		public virtual void _InitChildren (_Choice Parent) {{\n{0}", _Indent);
			_Output.Write ("			Init (Parent);\n{0}", _Indent);
			_Output.Write ("			if (_Initialized) {{\n{0}", _Indent);
			_Output.Write ("				return;\n{0}", _Indent);
			_Output.Write ("				}}\n{0}", _Indent);
			_Output.Write ("			_Initialized = true;\n{0}", _Indent);
			_Output.Write ("			}}\n{0}", _Indent);
			_Output.Write ("        }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				 List <Entry> Entries = null;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					 Entries = T.Entries;
					} else if (  (Item._Tag() == GoedelType.Type)) {
					 Type T = (Type) Item;
					 ID = T.Id.ToString();
					 Entries = T.Entries;
					}
				_Output.Write ("\n{0}", _Indent);
				_Output.Write ("    public partial class {1} : _Choice {{\n{0}", _Indent, ID);
				foreach  (Entry Entry in Entries) {
					DeclareEntry (Entry);
					}
				_Output.Write ("\n{0}", _Indent);
				_Output.Write ("        public override {1}Type _Tag () {{\n{0}", _Indent, Class.Name);
				_Output.Write ("            return {1}Type.{2};\n{0}", _Indent, Class.Name, ID);
				_Output.Write ("            }}\n{0}", _Indent);
				_Output.Write ("\n{0}", _Indent);
				_Output.Write ("		public override void _InitChildren (_Choice Parent) {{\n{0}", _Indent);
				_Output.Write ("			Init (Parent);\n{0}", _Indent);
				foreach  (Entry Entry in Entries) {
					switch (Entry.Type._Tag ()) {
						case GoedelType.Choice: { 
						_Output.Write ("			{1}._InitChildren (this);\n{0}", _Indent, Entry.Name);
						break; }
						case GoedelType.ChoiceREF: { 
						_Output.Write ("			{1}._InitChildren (this);\n{0}", _Indent, Entry.Name);
						break; }
						case GoedelType._Label: { 
						_Output.Write ("			{1}._InitChildren (this);\n{0}", _Indent, Entry.Name);
						break; }
						case GoedelType.List: {
						  List List = (List) Entry.Type; 
						if (  ((List.Type._Tag() == GoedelType._Label) |  (List.Type._Tag() == GoedelType.Choice) | (List.Type._Tag() == GoedelType.ChoiceREF)) ) {
							_Output.Write ("			foreach (var Sub in {1}) {{\n{0}", _Indent, Entry.Name);
							_Output.Write ("				Sub._InitChildren (this);\n{0}", _Indent);
							_Output.Write ("				}}\n{0}", _Indent);
							}
					break; }
						}
					}
				_Output.Write ("			}}\n{0}", _Indent);
				_Output.Write ("\n{0}", _Indent);
				_Output.Write ("		public override void Serialize (StructureWriter Output, bool tag) {{\n{0}", _Indent);
				_Output.Write ("\n{0}", _Indent);
				_Output.Write ("			if (tag) {{\n{0}", _Indent);
				_Output.Write ("				Output.StartElement (\"{1}\");\n{0}", _Indent, ID);
				_Output.Write ("				}}\n{0}", _Indent);
				_Output.Write ("\n{0}", _Indent);
				foreach  (Entry Entry in Entries) {
					SerializeEntry (Entry);
					}
				_Output.Write ("			if (tag) {{\n{0}", _Indent);
				_Output.Write ("				Output.EndElement (\"{1}\");\n{0}", _Indent, ID);
				_Output.Write ("				}}			\n{0}", _Indent);
				_Output.Write ("			}}\n{0}", _Indent);
				_Output.Write ("		}}\n{0}", _Indent);
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("    class _Label : _Choice {{\n{0}", _Indent);
			_Output.Write ("        public REF<_Choice>            Label;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		// This method is never called. It exists only to prevent a warning when a\n{0}", _Indent);
			_Output.Write ("		// Schema does not contain a ChoiceREF element.\n{0}", _Indent);
			_Output.Write ("        public void Reach() {{\n{0}", _Indent);
			_Output.Write ("            Label = null;\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        public override {1}Type _Tag () {{\n{0}", _Indent, Class.Name);
			_Output.Write ("            return {1}Type._Label;\n{0}", _Indent, Class.Name);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		public override void Serialize (StructureWriter Output, bool tag) {{\n{0}", _Indent);
			_Output.Write ("			Output.WriteId (\"ID\", Label.ToString());\n{0}", _Indent);
			_Output.Write ("			}}\n{0}", _Indent);
			_Output.Write ("        }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("    public enum StateCode {{  \n{0}", _Indent);
			_Output.Write ("        _Start,\n{0}", _Indent);
			_Output.Write ("        _Choice,\n{0}", _Indent);
			_Output.Write ("        _End,\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				 List <Entry> Entries = null;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					 Entries = T.Entries;
					} else if (  (Item._Tag() == GoedelType.Type)) {
					 Type T = (Type) Item;
					 ID = T.Id.ToString();
					 Entries = T.Entries;
					}
				_Output.Write ("		{1}_Start,\n{0}", _Indent, ID);
				foreach  (Entry Entry in Entries) {
					_Output.Write ("		{1}__{2},				\n{0}", _Indent, ID, Entry.Name);
					}
				}
			_Output.Write ("        }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("    struct _StackItem {{\n{0}", _Indent);
			_Output.Write ("        public StateCode   State;\n{0}", _Indent);
			_Output.Write ("        public {1}._Choice     Token;\n{0}", _Indent, Class.Namespace);
			_Output.Write ("        }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("    public partial class {1} : Goedel.Registry.Parser{{\n{0}", _Indent, Class.Name);
			_Output.Write ("        public List <{1}._Choice>        Top;\n{0}", _Indent, Class.Namespace);
			_Output.Write ("        public Registry	<{1}._Choice>	Registry;\n{0}", _Indent, Class.Namespace);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        bool _StartOfEntry;\n{0}", _Indent);
			_Output.Write ("        public bool StartOfEntry {{\n{0}", _Indent);
			_Output.Write ("            get {{return _StartOfEntry;}}\n{0}", _Indent);
			_Output.Write ("            private set {{ _StartOfEntry = value; }}\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        StateCode								State;\n{0}", _Indent);
			_Output.Write ("        {1}._Choice				Current;\n{0}", _Indent, Class.Namespace);
			_Output.Write ("        List <_StackItem>						Stack;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        public static {1} Parse(string File, Goedel.Registry.Dispatch Options) {{\n{0}", _Indent, Class.Name);
			_Output.Write ("            var Result = new {1}();\n{0}", _Indent, Class.Name);
			_Output.Write ("            Result.Options = Options;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            using (Stream infile =\n{0}", _Indent);
			_Output.Write ("                        new FileStream(File, FileMode.Open, FileAccess.Read)) {{\n{0}", _Indent);
			_Output.Write ("                Lexer Schema = new Lexer(File);\n{0}", _Indent);
			_Output.Write ("                Schema.Process(infile, Result);\n{0}", _Indent);
			_Output.Write ("                }}\n{0}", _Indent);
			_Output.Write ("			Result._InitChildren ();\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            return Result;\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		bool _Initialized = false;\n{0}", _Indent);
			_Output.Write ("		public virtual void _InitChildren () {{\n{0}", _Indent);
			_Output.Write ("			if (_Initialized) {{\n{0}", _Indent);
			_Output.Write ("				return;\n{0}", _Indent);
			_Output.Write ("				}}\n{0}", _Indent);
			_Output.Write ("			_Initialized = true;\n{0}", _Indent);
			_Output.Write ("			foreach (var Entry in Top) {{\n{0}", _Indent);
			_Output.Write ("				Entry._InitChildren (null);\n{0}", _Indent);
			_Output.Write ("				}}\n{0}", _Indent);
			_Output.Write ("			}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        public {1}() {{\n{0}", _Indent, Class.Name);
			_Output.Write ("            Top = new List<{1}._Choice> () ;\n{0}", _Indent, Class.Namespace);
			_Output.Write ("            Registry = new Registry <{1}._Choice> ();\n{0}", _Indent, Class.Namespace);
			_Output.Write ("            State = StateCode._Start;\n{0}", _Indent);
			_Output.Write ("            Stack = new List <_StackItem> ();\n{0}", _Indent);
			_Output.Write ("            _StartOfEntry = true;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			// Seems to be a bug here, IDs are only created if there is a reference to a type
			// 
			foreach  (ID<_Choice> ID in IdTYPE.IDs) {
				_Output.Write ("			TYPE__{1} = Registry.TYPE (\"{2}\"); \n{0}", _Indent, ID, ID);
				}
			foreach  (ID<_Choice> ID in TokenTYPE.IDs) {
				_Output.Write ("			TYPE__{1} = Registry.TYPE (\"{2}\"); \n{0}", _Indent, ID, ID);
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			//            TYPE__#{Type.Label} = Registry.TYPE ("#{Type.Label}"); ;
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			// #foreach (TYPE<_Choice> Type in Goedel.Registry.Types)
			_Output.Write ("\n{0}", _Indent);
			foreach  (ID<_Choice> ID in IdTYPE.IDs) {
				_Output.Write ("        public TYPE<{1}._Choice> TYPE__{2} ;\n{0}", _Indent, Class.Namespace, ID);
				}
			foreach  (ID<_Choice> ID in TokenTYPE.IDs) {
				_Output.Write ("        public TYPE<{1}._Choice> TYPE__{2} ;\n{0}", _Indent, Class.Namespace, ID);
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        private {1}._Choice New_Choice(string Label) {{\n{0}", _Indent, Class.Namespace);
			_Output.Write ("            switch (Label) {{\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					} else if (  (Item._Tag() == GoedelType.Type)) {
					 Type T = (Type) Item;
					 ID = T.Id.ToString();
					}
				_Output.Write ("                case \"{1}\": return New{2}();\n{0}", _Indent, ID, ID);
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("				}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            throw new NotFoundReserved (\"Reserved word not recognized \\\"\" + Label + \"\\\"\");\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					} else if (  (Item._Tag() == GoedelType.Type)) {
					 Type T = (Type) Item;
					 ID = T.Id.ToString();
					}
				_Output.Write ("\n{0}", _Indent);
				_Output.Write ("        private {1}.{2} New{3}() {{\n{0}", _Indent, Class.Namespace, ID, ID);
				_Output.Write ("            {1}.{2} result = new {3}.{4}();\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
				_Output.Write ("            Push (result);\n{0}", _Indent);
				_Output.Write ("            State = StateCode.{1}_Start;\n{0}", _Indent, ID);
				_Output.Write ("            return result;\n{0}", _Indent);
				_Output.Write ("            }}\n{0}", _Indent);
				_Output.Write ("\n{0}", _Indent);
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        static {1}.{2}Type _Reserved(string Label) {{\n{0}", _Indent, Class.Namespace, Class.Name);
			_Output.Write ("            switch (Label) {{\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					} else if (  (Item._Tag() == GoedelType.Type)) {
					 Type T = (Type) Item;
					 ID = T.Id.ToString();
					}
				_Output.Write ("                case \"{1}\": return {2}.{3}Type.{4};\n{0}", _Indent, ID, Class.Namespace, Class.Name, ID);
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("                }}\n{0}", _Indent);
			_Output.Write ("            return {1}.{2}Type._Bottom;\n{0}", _Indent, Class.Namespace, Class.Name);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		public void Serialize (TextWriter Output) {{\n{0}", _Indent);
			_Output.Write ("			Serialize (Output, OutputFormat.Goedel);\n{0}", _Indent);
			_Output.Write ("			}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {{\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);\n{0}", _Indent);
			_Output.Write ("			StructureWriter.StartDocument ();\n{0}", _Indent);
			_Output.Write ("			foreach ({1}._Choice Entry in Top) {{\n{0}", _Indent, Class.Namespace);
			_Output.Write ("				Entry.Serialize (StructureWriter, true);\n{0}", _Indent);
			_Output.Write ("				}}\n{0}", _Indent);
			_Output.Write ("			StructureWriter.EndDocument ();\n{0}", _Indent);
			_Output.Write ("			}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        void Push ({1}._Choice Token) {{\n{0}", _Indent, Class.Namespace);
			_Output.Write ("            _StackItem Item = new _StackItem ();\n{0}", _Indent);
			_Output.Write ("            Item.State = State;\n{0}", _Indent);
			_Output.Write ("            Item.Token = Current;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            Stack.Add (Item);\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            //Console.WriteLine (\"$$$$PUSH {{0}}\", Current);\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            Current = Token;\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        void Pop () {{\n{0}", _Indent);
			_Output.Write ("			Assert.False (Stack.Count == 0, InternalError.Throw);\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            _StackItem Item = Stack[Stack.Count -1];\n{0}", _Indent);
			_Output.Write ("            State = Item.State;\n{0}", _Indent);
			_Output.Write ("            Current = Item.Token;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            Stack.RemoveAt (Stack.Count -1 ) ;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            //Console.WriteLine (\"$$$$POP {{0}}\", Current);\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("        public override void Process(TokenType Token, Position Position, string Text) {{\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            if ((Token == TokenType.SEPARATOR) |\n{0}", _Indent);
			_Output.Write ("                (Token == TokenType.NULL) |\n{0}", _Indent);
			_Output.Write ("                (Token == TokenType.COMMENT)) {{\n{0}", _Indent);
			_Output.Write ("				return;\n{0}", _Indent);
			_Output.Write ("				}}\n{0}", _Indent);
			_Output.Write ("			Assert.False (Token == TokenType.INVALID, InvalidToken.Throw);\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            bool Represent = true;\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("            while (Represent) {{\n{0}", _Indent);
			_Output.Write ("                //Console.WriteLine (\"    {{3}}: {{0}} {{1}} '{{2}}'\", Token, Position, Text, State);\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("                Represent = false;\n{0}", _Indent);
			_Output.Write ("                switch (State) {{\n{0}", _Indent);
			_Output.Write ("                    case StateCode._Start:                 //      BEGIN\n{0}", _Indent);
			_Output.Write ("                        if (Token == TokenType.BEGIN) {{\n{0}", _Indent);
			_Output.Write ("                            State = StateCode._Choice;\n{0}", _Indent);
			_Output.Write ("                            break;\n{0}", _Indent);
			_Output.Write ("                            }}\n{0}", _Indent);
			_Output.Write ("                        else {{\n{0}", _Indent);
			_Output.Write ("							throw new ExpectedStart ();\n{0}", _Indent);
			_Output.Write ("							}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("                    case StateCode._Choice:                //      LABEL Class | END\n{0}", _Indent);
			_Output.Write ("                        if (Token == TokenType.LABEL) {{\n{0}", _Indent);
			_Output.Write ("                            {1}.{2}Type LabelType = _Reserved (Text);\n{0}", _Indent, Class.Namespace, Class.Name);
			_Output.Write ("                            if (false", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					_Output.Write (" |\n{0}", _Indent);
					_Output.Write ("									(LabelType == {1}.{2}Type.{3})", _Indent, Class.Namespace, Class.Name, ID);
					}
				}
			_Output.Write (") {{\n{0}", _Indent);
			_Output.Write ("                                Top.Add(New_Choice(Text));\n{0}", _Indent);
			_Output.Write ("                                }}\n{0}", _Indent);
			_Output.Write ("                            else {{\n{0}", _Indent);
			_Output.Write ("                                throw new Expected(\"Parser Error Expected [Class]\");\n{0}", _Indent);
			_Output.Write ("                                }}\n{0}", _Indent);
			_Output.Write ("                            break;\n{0}", _Indent);
			_Output.Write ("                            }}\n{0}", _Indent);
			_Output.Write ("                        if (Token == TokenType.END) {{\n{0}", _Indent);
			_Output.Write ("                            State = StateCode._End;\n{0}", _Indent);
			_Output.Write ("                            break;\n{0}", _Indent);
			_Output.Write ("                            }}\n{0}", _Indent);
			_Output.Write ("                        else {{\n{0}", _Indent);
			_Output.Write ("							throw new ExpectedClass();\n{0}", _Indent);
			_Output.Write ("							}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("                    case StateCode._End: {{                  //      -\n{0}", _Indent);
			_Output.Write ("                        throw new TooManyClose();\n{0}", _Indent);
			_Output.Write ("						}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			foreach  (_Choice Item in Class.Entries) {
				 string ID = null;
				 List <Entry> Entries = null;
				 bool IsList = false;
				if (  (Item._Tag() == GoedelType.TopType) ) {
					 TopType T = (TopType) Item;
					 ID = T.Id.ToString();
					 Entries = T.Entries;
					} else if (  (Item._Tag() == GoedelType.Type)) {
					 Type T = (Type) Item;
					 ID = T.Id.ToString();
					 Entries = T.Entries;
					}
				_Output.Write ("                    case StateCode.{1}_Start:\n{0}", _Indent, ID);
				foreach  (Entry Entry in Entries) {
					 IsList = false;
					switch (Entry.Type._Tag ()) {
						case GoedelType._Label: { 
						_Output.Write ("						// Parser transition for _Label $$$$$\n{0}", _Indent);
						break; }
						case GoedelType.Options: {
						  Options Options = (Options) Entry.Type; 
						
						 IsList = true;
						_Output.Write ("                        if (Token == TokenType.BEGIN) {{\n{0}", _Indent);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        else {{\n{0}", _Indent);
						_Output.Write ("							Pop ();\n{0}", _Indent);
						_Output.Write ("                            Represent = true;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        break;\n{0}", _Indent);
						_Output.Write ("                    case StateCode.{1}__{2}: \n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                        if (Token == TokenType.END) {{\n{0}", _Indent);
						_Output.Write ("                            Pop();\n{0}", _Indent);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("\n{0}", _Indent);
						_Output.Write ("						// Parser transition for OPTIONS $$$$$\n{0}", _Indent);
						_Output.Write ("                        else if (Token == TokenType.LABEL) {{\n{0}", _Indent);
						_Output.Write ("							{1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            {1}.{2}Type LabelType = _Reserved (Text);\n{0}", _Indent, Class.Namespace, Class.Name);
						_Output.Write ("							switch (LabelType) {{\n{0}", _Indent);
						foreach  (OptionEntry OEntry in Options.Entries) {
							_Output.Write ("								case {1}.{2}Type.{3} : {{\n{0}", _Indent, Class.Namespace, Class.Name, OEntry.Type);
							_Output.Write ("\n{0}", _Indent);
							_Output.Write ("									// {1}  {2}\n{0}", _Indent, OEntry.Name, OEntry.Type);
							switch (OEntry.Occurs._Tag ()) {
								case GoedelType.Single: { 
								_Output.Write ("									Current_Cast.{1} = New{2} ();\n{0}", _Indent, OEntry.Name, OEntry.Type);
								break; }
								case GoedelType.Multiple: { 
								_Output.Write ("									Current_Cast.{1}.Add (New{2} ());\n{0}", _Indent, OEntry.Name, OEntry.Type);
							break; }
								}
							_Output.Write ("									break;\n{0}", _Indent);
							_Output.Write ("									}}\n{0}", _Indent);
							}
						_Output.Write ("								default : {{\n{0}", _Indent);
						_Output.Write ("									throw new Expected(\"Parser Error Expected [", _Indent);
						foreach  (OptionEntry OEntry in Options.Entries) {
							_Output.Write ("{1} ", _Indent, OEntry.Type);
							}
						_Output.Write ("]\");\n{0}", _Indent);
						_Output.Write ("									}}\n{0}", _Indent);
						_Output.Write ("								}}\n{0}", _Indent);
						_Output.Write ("							}}\n{0}", _Indent);
						_Output.Write ("                        break;\n{0}", _Indent);
						break; }
						case GoedelType.List: {
						  List List = (List) Entry.Type; 
						_Output.Write ("\n{0}", _Indent);
						_Output.Write ("                        if (Token == TokenType.BEGIN) {{\n{0}", _Indent);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        else {{\n{0}", _Indent);
						_Output.Write ("							Pop ();\n{0}", _Indent);
						_Output.Write ("                            Represent = true;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        break;\n{0}", _Indent);
						_Output.Write ("                    case StateCode.{1}__{2}: \n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                        if (Token == TokenType.END) {{\n{0}", _Indent);
						_Output.Write ("                            Pop();\n{0}", _Indent);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("\n{0}", _Indent);
						_Output.Write ("						// Parser transition for LIST $$$$$\n{0}", _Indent);
						_Output.Write ("\n{0}", _Indent);
						
						 IsList = true;
						switch ( (List.Type._Tag())) {
							case  GoedelType._Label: {
							
							 _Label LLabel = (_Label) List.Type;
							_Output.Write ("\n{0}", _Indent);
							_Output.Write ("						/// Label\n{0}", _Indent);
							_Output.Write ("                        else {{\n{0}", _Indent);
							_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
							_Output.Write ("                            Current_Cast.{1}.Add (New{2} ());\n{0}", _Indent, Entry.Name, LLabel.Label);
							_Output.Write ("                            Represent = true;\n{0}", _Indent);
							_Output.Write ("                            }}\n{0}", _Indent);
							_Output.Write ("\n{0}", _Indent);
							break; }
							case  GoedelType.Choice: {
							
							 Choice Choice = (Choice) List.Type; 
							_Output.Write ("                        else if (Token == TokenType.LABEL) {{\n{0}", _Indent);
							_Output.Write ("							{1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
							_Output.Write ("                            {1}.{2}Type LabelType = _Reserved (Text);\n{0}", _Indent, Class.Namespace, Class.Name);
							_Output.Write ("                            if ( false ", _Indent);
							foreach  (REF<_Choice> Ref in Choice.Entries) {
								_Output.Write ("|\n{0}", _Indent);
								_Output.Write ("									(LabelType == {1}.{2}Type.{3}) ", _Indent, Class.Namespace, Class.Name, Ref);
								}
							_Output.Write (") {{\n{0}", _Indent);
							_Output.Write ("                                Current_Cast.{1}.Add (New_Choice(Text));\n{0}", _Indent, Entry.Name);
							_Output.Write ("                                }}\n{0}", _Indent);
							_Output.Write ("                            else {{\n{0}", _Indent);
							_Output.Write ("								throw new Expected (\"Parser Error Expected [", _Indent);
							foreach  (REF<_Choice> Ref in Choice.Entries) {
								_Output.Write ("{1} ", _Indent, Ref);
								}
							_Output.Write ("]\");\n{0}", _Indent);
							_Output.Write ("								}}\n{0}", _Indent);
							_Output.Write ("							}}\n{0}", _Indent);
							break; }
							case  GoedelType.ChoiceREF: {
							_Output.Write ("\n{0}", _Indent);
							_Output.Write ("\n{0}", _Indent);
							break; }
							case  GoedelType.ID: {
							break; }
							case  GoedelType.REF: {
							
							 REF REF = (REF) List.Type;
							_Output.Write ("                        else if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {{\n{0}", _Indent);
							_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
							_Output.Write ("                            Current_Cast.{1}.Add ( Registry.REF(Position, Text, TYPE__{2}, Current_Cast ) );\n{0}", _Indent, Entry.Name, REF.Type);
							_Output.Write ("                            break;\n{0}", _Indent);
							_Output.Write ("                            }}\n{0}", _Indent);
							_Output.Write ("\n{0}", _Indent);
							break; }
							case  GoedelType.Token: {
							break; }
							case  GoedelType.String: {
							break; }
							case  GoedelType.Text: {
							break; }
							case  GoedelType.Integer: {
						break; }
							}
						_Output.Write ("                        break;\n{0}", _Indent);
						_Output.Write ("\n{0}", _Indent);
						break; }
						case GoedelType.Choice: {
						  Choice Entry_Cast = (Choice) Entry.Type; 
						_Output.Write ("                        if (Token == TokenType.LABEL) {{\n{0}", _Indent);
						_Output.Write ("							{1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            {1}.{2}Type LabelType = _Reserved (Text);\n{0}", _Indent, Class.Namespace, Class.Name);
						_Output.Write ("                            if ( false ", _Indent);
						foreach  (REF<_Choice> Ref in Entry_Cast.Entries) {
							_Output.Write ("|\n{0}", _Indent);
							_Output.Write ("									(LabelType == {1}.{2}Type.{3}) ", _Indent, Class.Namespace, Class.Name, Ref);
							}
						_Output.Write (") {{\n{0}", _Indent);
						_Output.Write ("                                State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                                Current_Cast.{1} = New_Choice(Text);\n{0}", _Indent, Entry.Name);
						_Output.Write ("                                }}\n{0}", _Indent);
						_Output.Write ("                            else {{\n{0}", _Indent);
						_Output.Write ("                               throw new Expected (\"Parser Error Expected [", _Indent);
						foreach  (REF<_Choice> Ref in Entry_Cast.Entries) {
							_Output.Write ("{1} ", _Indent, Ref);
							}
						_Output.Write ("]\");\n{0}", _Indent);
						_Output.Write ("                                }}\n{0}", _Indent);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        else throw new Expected(\"Parser Error Expected [", _Indent);
						foreach  (REF<_Choice> Ref in Entry_Cast.Entries) {
							_Output.Write ("{1} ", _Indent, Ref);
							}
						_Output.Write ("]\");\n{0}", _Indent);
						break; }
						case GoedelType.ChoiceREF: {
						  ChoiceREF Entry_Cast = (ChoiceREF) Entry.Type; 
						_Output.Write ("                        if (Token == TokenType.LABEL) {{\n{0}", _Indent);
						_Output.Write ("							{1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            {1}.{2}Type LabelType = _Reserved (Text);\n{0}", _Indent, Class.Namespace, Class.Name);
						_Output.Write ("                            if ( false ", _Indent);
						foreach  (REF<_Choice> Ref in Entry_Cast.Entries) {
							_Output.Write ("|\n{0}", _Indent);
							_Output.Write ("									(LabelType == {1}.{2}Type.{3}) ", _Indent, Class.Namespace, Class.Name, Ref);
							}
						_Output.Write (") {{\n{0}", _Indent);
						_Output.Write ("                                State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                                Current_Cast.{1} = New_Choice(Text);\n{0}", _Indent, Entry.Name);
						_Output.Write ("                                }}\n{0}", _Indent);
						_Output.Write ("                            else {{\n{0}", _Indent);
						_Output.Write ("                                {1}._Label result = new {2}._Label();\n{0}", _Indent, Class.Namespace, Class.Namespace);
						_Output.Write ("                                result.Label = Registry.REF(Position, Text, TYPE__{1}, Current_Cast);\n{0}", _Indent, Entry_Cast.ID);
						_Output.Write ("                                Current_Cast.{1} = result;\n{0}", _Indent, Entry.Name);
						_Output.Write ("                                State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                                }}\n{0}", _Indent);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        else if (Token == TokenType.LITERAL) {{\n{0}", _Indent);
						_Output.Write ("                            {1}._Label result = new {2}._Label();\n{0}", _Indent, Class.Namespace, Class.Namespace);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            result.Label = Registry.REF(Position, Text, TYPE__{1}, Current_Cast);\n{0}", _Indent, Entry_Cast.ID);
						_Output.Write ("                            Current_Cast.{1} = result;\n{0}", _Indent, Entry.Name);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        else throw new Expected (\"Parser Error Expected [", _Indent);
						foreach  (REF<_Choice> Ref in Entry_Cast.Entries) {
							_Output.Write ("{1} ", _Indent, Ref);
							}
						_Output.Write ("]\");\n{0}", _Indent);
						break; }
						case GoedelType.ID: {
						  ID Entry_Cast = (ID) Entry.Type; 
						_Output.Write ("                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {{\n{0}", _Indent);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            Current_Cast.{1} = Registry.ID(Position, Text, TYPE__{2}, Current_Cast);\n{0}", _Indent, Entry.Name, Entry_Cast.Type);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        throw new Expected(\"Expected LABEL or LITERAL\");\n{0}", _Indent);
						break; }
						case GoedelType.REF: {
						  REF Entry_Cast = (REF) Entry.Type; 
						_Output.Write ("                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {{\n{0}", _Indent);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            Current_Cast.{1} = Registry.REF(Position, Text, TYPE__{2}, Current_Cast);\n{0}", _Indent, Entry.Name, Entry_Cast.Type);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        throw new Expected(\"Expected LABEL or LITERAL\");\n{0}", _Indent);
						break; }
						case GoedelType.Token: {
						  Token Entry_Cast = (Token) Entry.Type; 
						_Output.Write ("                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {{\n{0}", _Indent);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            Current_Cast.{1} = Registry.TOKEN(Position, Text, TYPE__{2}, Current_Cast);\n{0}", _Indent, Entry.Name, Entry_Cast.Type);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        throw new Expected(\"Expected LABEL or LITERAL\");\n{0}", _Indent);
						break; }
						case GoedelType.String: { 
						_Output.Write ("                        if (Token == TokenType.STRING) {{\n{0}", _Indent);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            Current_Cast.{1} = Text;\n{0}", _Indent, Entry.Name);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        throw new Expected(\"Expected String\");\n{0}", _Indent);
						break; }
						case GoedelType.Text: { 
						_Output.Write ("                        if (Token == TokenType.BEGIN) {{\n{0}", _Indent);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        else {{\n{0}", _Indent);
						_Output.Write ("                            Pop();\n{0}", _Indent);
						_Output.Write ("                            Represent = true;\n{0}", _Indent);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                    case StateCode.{1}__{2}:\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                       if (Token == TokenType.END) {{\n{0}", _Indent);
						_Output.Write ("                            Pop();\n{0}", _Indent);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                       else if (Token == TokenType.TEXT) {{\n{0}", _Indent);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            Current_Cast.{1}.Add (Text);\n{0}", _Indent, Entry.Name);
						_Output.Write ("                            break;							\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                       throw new Expected(\"Expected Text\");\n{0}", _Indent);
						_Output.Write ("\n{0}", _Indent);
						
						 IsList = true;
						break; }
						case GoedelType.Integer: { 
						_Output.Write ("                        if (Token == TokenType.INTEGER) {{\n{0}", _Indent);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            Current_Cast.{1} = Convert.ToInt32(Text);\n{0}", _Indent, Entry.Name);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        throw new Expected(\"Expected Integer\");\n{0}", _Indent);
						break; }
						case GoedelType.Boolean: { 
						_Output.Write ("                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL))  {{\n{0}", _Indent);
						_Output.Write ("                            {1}.{2} Current_Cast = ({3}.{4})Current;\n{0}", _Indent, Class.Namespace, ID, Class.Namespace, ID);
						_Output.Write ("                            Current_Cast.{1} = Convert.ToBoolean (Text);\n{0}", _Indent, Entry.Name);
						_Output.Write ("                            State = StateCode.{1}__{2};\n{0}", _Indent, ID, Entry.Name);
						_Output.Write ("                            break;\n{0}", _Indent);
						_Output.Write ("                            }}\n{0}", _Indent);
						_Output.Write ("                        throw new Expected(\"Expected True or False\");						\n{0}", _Indent);
					break; }
						}
					_Output.Write ("\n{0}", _Indent);
					if (  !IsList ) {
						_Output.Write ("                    case StateCode.{1}__{2}:\n{0}", _Indent, ID, Entry.Name);
						}
					}
				if (  !IsList ) {
					_Output.Write ("                        Pop ();\n{0}", _Indent);
					_Output.Write ("                        Represent = true; \n{0}", _Indent);
					_Output.Write ("                        break;\n{0}", _Indent);
					}
				}
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("                    default: {{\n{0}", _Indent);
			_Output.Write ("                        throw new UnreachableCode();\n{0}", _Indent);
			_Output.Write ("						}}\n{0}", _Indent);
			_Output.Write ("                    }}\n{0}", _Indent);
			_Output.Write ("                }}\n{0}", _Indent);
			_Output.Write ("            }}\n{0}", _Indent);
			_Output.Write ("        }}\n{0}", _Indent);
			_Output.Write ("	}}\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			}
		

		//
		// DeclareEntry
		//
		public void DeclareEntry (Entry Entry) {
			switch (Entry.Type._Tag ()) {
				case GoedelType._Label: {
				  _Label Label = (_Label) Entry.Type; 
				_Output.Write ("        public {1}					{2};\n{0}", _Indent, Label.Label, Entry.Name);
				break; }
				case GoedelType.Options: {
				  Options Options = (Options) Entry.Type; 
				foreach  (OptionEntry OEntry in Options.Entries) {
					switch (OEntry.Occurs._Tag ()) {
						case GoedelType.Single: { 
						_Output.Write ("		public {1}  {2} = new  {3}();\n{0}", _Indent, OEntry.Type, OEntry.Name, OEntry.Type);
						break; }
						case GoedelType.Multiple: { 
						_Output.Write ("		public List<{1}>  {2} = new  List <{3}> ();\n{0}", _Indent, OEntry.Type, OEntry.Name, OEntry.Type);
					break; }
						}
					}
				break; }
				case GoedelType.List: {
				  List List = (List) Entry.Type; 
				
				 string Type = "???";
				switch ( (List.Type._Tag())) {
					case  GoedelType._Label: {
					
					 _Label LLabel = (_Label) List.Type;
					
					 Type = LLabel.Label.ToString ();
					break; }
					case  GoedelType.Choice: {
					
					 Type = "_Choice";
					break; }
					case  GoedelType.ChoiceREF: {
					
					 Type = "_Choice";
					break; }
					case  GoedelType.ID: {
					
					 Type = "ID<_Choice>";
					break; }
					case  GoedelType.REF: {
					
					 Type = "REF<_Choice>";
					break; }
					case  GoedelType.Token: {
					
					 Type = "TOKEN<_Choice>";
					break; }
					case  GoedelType.String: {
					
					 Type = "string";
					break; }
					case  GoedelType.Text: {
					
					 Type = "String";
					break; }
					case  GoedelType.Integer: {
					
					 Type = "int";
					break; }
					case  GoedelType.Boolean: {
					
					 Type = "bool";
				break; }
					}
				_Output.Write ("        public List <{1}>           {2} = new List<{3}> ();\n{0}", _Indent, Type, Entry.Name, Type);
				break; }
				case GoedelType.Choice: { 
				_Output.Write ("        public _Choice					{1};\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.ChoiceREF: { 
				_Output.Write ("        public _Choice					{1};\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.ID: { 
				_Output.Write ("        public ID<_Choice>				{1}; \n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.REF: { 
				_Output.Write ("        public REF<_Choice>				{1};\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.Token: { 
				_Output.Write ("        public TOKEN<_Choice>			{1};\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.String: { 
				_Output.Write ("		public string					{1};\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.Text: { 
				_Output.Write ("		public List <System.String>			{1} = new List <System.String> (); \n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.Integer: { 
				_Output.Write ("		public int						{1};\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.Boolean: { 
				_Output.Write ("		public bool						{1};\n{0}", _Indent, Entry.Name);
			break; }
				}
			}
		

		//
		// SerializeEntry
		//
		public void SerializeEntry (Entry Entry) {
			switch (Entry.Type._Tag ()) {
				case GoedelType._Label: { 
				break; }
				case GoedelType.Options: {
				  Options Options = (Options) Entry.Type; 
				_Output.Write ("			Output.StartList (\"\");\n{0}", _Indent);
				foreach  (OptionEntry OEntry in Options.Entries) {
					switch (OEntry.Occurs._Tag ()) {
						case GoedelType.Single: { 
						_Output.Write ("		// public {1}  {2} = new  {3}();\n{0}", _Indent, OEntry.Type, OEntry.Name, OEntry.Type);
						_Output.Write ("			{1}.Serialize (Output, true);\n{0}", _Indent, OEntry.Name);
						break; }
						case GoedelType.Multiple: { 
						_Output.Write ("			foreach ({1} _e in {2}) {{\n{0}", _Indent, OEntry.Type, OEntry.Name);
						_Output.Write ("				_e.Serialize (Output, true);\n{0}", _Indent);
						_Output.Write ("				}}\n{0}", _Indent);
					break; }
						}
					}
				_Output.Write ("			Output.EndList (\"\");\n{0}", _Indent);
				break; }
				case GoedelType.List: {
				  List List = (List) Entry.Type; 
				_Output.Write ("			Output.StartList (\"\");\n{0}", _Indent);
				switch (List.Type._Tag ()) {
					case GoedelType._Label: {
					  _Label LLabel = (_Label) List.Type; 
					_Output.Write ("			foreach ({1} _e in {2}) {{\n{0}", _Indent, LLabel.Label, Entry.Name);
					_Output.Write ("				_e.Serialize (Output, true);\n{0}", _Indent);
					break; }
					case GoedelType.Choice: { 
					_Output.Write ("			foreach (_Choice _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				_e.Serialize (Output, true);\n{0}", _Indent);
					break; }
					case GoedelType.ChoiceREF: { 
					_Output.Write ("			foreach (_Choice _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				_e.Serialize (Output, true);\n{0}", _Indent);
					break; }
					case GoedelType.ID: { 
					_Output.Write ("			foreach (ID<_Choice> _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				Output.WriteId (\"{1}\", _e.ToString()); \n{0}", _Indent, Entry.Name);
					break; }
					case GoedelType.REF: { 
					_Output.Write ("			foreach (REF<_Choice> _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				Output.WriteId (\"{1}\", _e.ToString());\n{0}", _Indent, Entry.Name);
					break; }
					case GoedelType.Token: { 
					_Output.Write ("			foreach (TOKEN<_Choice> _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				Output.WriteId (\"{1}\", _e.ToString());\n{0}", _Indent, Entry.Name);
					break; }
					case GoedelType.String: { 
					_Output.Write ("			foreach (string _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				Output.WriteAttribute (\"{1}\", _e);\n{0}", _Indent, Entry.Name);
					break; }
					case GoedelType.Integer: { 
					_Output.Write ("			foreach (int _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				Output.Write (\"{1}\", _e);\n{0}", _Indent, Entry.Name);
					break; }
					case GoedelType.Boolean: { 
					_Output.Write ("			foreach (bool _e in {1}) {{\n{0}", _Indent, Entry.Name);
					_Output.Write ("				Output.WriteAttribute (\"{1}\", _e);\n{0}", _Indent, Entry.Name);
				break; }
					}
				_Output.Write ("				}}\n{0}", _Indent);
				_Output.Write ("			Output.EndList (\"\");\n{0}", _Indent);
				break; }
				case GoedelType.Choice: { 
				_Output.Write ("	        {1}.Serialize (Output, true);\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.ChoiceREF: { 
				_Output.Write ("	        {1}.Serialize (Output, true);\n{0}", _Indent, Entry.Name);
				break; }
				case GoedelType.ID: { 
				_Output.Write ("	        Output.WriteId (\"{1}\", {2}.ToString()); \n{0}", _Indent, Entry.Name, Entry.Name);
				break; }
				case GoedelType.REF: { 
				_Output.Write ("	        Output.WriteId (\"{1}\", {2}.ToString());\n{0}", _Indent, Entry.Name, Entry.Name);
				break; }
				case GoedelType.Token: { 
				_Output.Write ("	        Output.WriteId (\"{1}\", {2}.ToString());\n{0}", _Indent, Entry.Name, Entry.Name);
				break; }
				case GoedelType.String: { 
				_Output.Write ("			Output.WriteAttribute (\"{1}\", {2});\n{0}", _Indent, Entry.Name, Entry.Name);
				break; }
				case GoedelType.Text: { 
				_Output.Write ("			foreach (string _s in {1}) {{\n{0}", _Indent, Entry.Name);
				_Output.Write ("				Output.WriteAttribute (\"{1}\",_s);\n{0}", _Indent, Entry.Name);
				_Output.Write ("				}}\n{0}", _Indent);
				break; }
				case GoedelType.Integer: { 
				_Output.Write ("			Output.WriteAttribute (\"{1}\", {2});\n{0}", _Indent, Entry.Name, Entry.Name);
				break; }
				case GoedelType.Boolean: { 
				_Output.Write ("			Output.WriteAttribute (\"{1}\", {2});\n{0}", _Indent, Entry.Name, Entry.Name);
			break; }
				}
			}
		}
	}
