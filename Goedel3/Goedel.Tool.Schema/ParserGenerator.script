#script 1.0
#license MITLicense
#pclass GoedelSchema GenerateParser
#% DateTime GenerateTime = DateTime.UtcNow;
#% Goedel Goedel;
#method GenerateCS Goedel GoedelIn
#% Goedel = GoedelIn;
#% // Boilerplate.Header (_Output, "//  ", GenerateTime);
#foreach (_Choice Item in Goedel.Top)
#switchcast GoedelType Item
#casecast Copyright Copyright
#switchcast GoedelType Copyright.License
#casecast MITLicense License
#% Boilerplate.MITLicense (_Output, "//  ", "Copyright (c) " + Copyright.Date, Copyright.Holder);
#casecast BSD2License License
#% Boilerplate.BSD2License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast BSD3License License
#% Boilerplate.BSD3License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast ISCLicense License
#% Boilerplate.ISCLicense (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast Apache2License License
#% Boilerplate.Apache2License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast OtherLicense License
// Copyright (1) #{Copyright.Date} by #{Copyright.Holder}
// #{License.Text}
#end switchcast
#end switchcast
#end foreach

// This file is automatically generated from the following source files:
#foreach (Source File in Goedel.Registry.Files)
// Input file  #{File.Name}
#end foreach
// Command line options: 
//     /dlexer=#{GoedelIn.DebugLexer}
//     /dparser=#{GoedelIn.DebugParser}
//     /dstack=#{GoedelIn.DebugStack}

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;

#foreach (_Choice Item in Goedel.Top)
#if (Item._Tag() ==  GoedelType.Class)
#call GenerateClass (Class)Item
#end if
#end foreach

#end method

#method GenerateClass Class Class
#% TYPE<_Choice> IdTYPE = Goedel.Registry.FindType ("IdType");
#% TYPE<_Choice> TokenTYPE = Goedel.Registry.FindType ("TokenType");

//
// Namespace #{Class.Namespace}
// Class #{Class.Name}
//


// Types
#foreach (TYPE<_Choice> Type in Goedel.Registry.Types)
//   #{Type.Label}
#foreach (ID<_Choice> ID in Type.IDs)
//       #{ID}
#end foreach
#end foreach

namespace #{Class.Namespace} {


    public enum #{Class.Name}Type {
        _Top,

#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
#elseif (Item._Tag() == GoedelType.Type)
#% Type T = (Type) Item;
#% ID = T.Id.ToString();
#end if
        #{ID},
#end foreach

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public #{Class.Name}Type _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);

		public virtual void Init (_Choice Parent) {
			}

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice Parent) {
			Init (Parent);
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }


#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#% List <Entry> Entries = null;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
#% Entries = T.Entries;
#elseif (Item._Tag() == GoedelType.Type)
#% Type T = (Type) Item;
#% ID = T.Id.ToString();
#% Entries = T.Entries;
#end if

    public partial class #{ID} : _Choice {
#foreach (Entry Entry in Entries)
#call DeclareEntry Entry
#end foreach

        public override #{Class.Name}Type _Tag () {
            return #{Class.Name}Type.#{ID};
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
#foreach (Entry Entry in Entries)
#switchcast GoedelType Entry.Type
#casecast Choice Choice
			#{Entry.Name}._InitChildren (this);
#casecast ChoiceREF ChoiceREF
			#{Entry.Name}._InitChildren (this);
#casecast _Label Label
			#{Entry.Name}._InitChildren (this);
#casecast List List
#if ((List.Type._Tag() == GoedelType._Label) |  (List.Type._Tag() == GoedelType.Choice) | (List.Type._Tag() == GoedelType.ChoiceREF))
			foreach (var Sub in #{Entry.Name}) {
				Sub._InitChildren (this);
				}
#end if
#end switchcast
#end foreach
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("#{ID}");
				}

#foreach (Entry Entry in Entries)
#call SerializeEntry Entry
#end foreach
			if (tag) {
				Output.EndElement ("#{ID}");
				}			
			}
		}
#end foreach

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override #{Class.Name}Type _Tag () {
            return #{Class.Name}Type._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#% List <Entry> Entries = null;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
#% Entries = T.Entries;
#elseif (Item._Tag() == GoedelType.Type)
#% Type T = (Type) Item;
#% ID = T.Id.ToString();
#% Entries = T.Entries;
#end if
		#{ID}_Start,
#foreach (Entry Entry in Entries)
		#{ID}__#{Entry.Name},				
#end foreach
#end foreach
        }


    struct _StackItem {
        public StateCode   State;
        public #{Class.Namespace}._Choice     Token;
        }

    public partial class #{Class.Name} : Goedel.Registry.Parser{
        public List <#{Class.Namespace}._Choice>        Top;
        public Registry	<#{Class.Namespace}._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        #{Class.Namespace}._Choice				Current;
        List <_StackItem>						Stack;


        public static #{Class.Name} Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new #{Class.Name}();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
				Entry._InitChildren (null);
				}
			}

        public #{Class.Name}() {
            Top = new List<#{Class.Namespace}._Choice> () ;
            Registry = new Registry <#{Class.Namespace}._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

#! Seems to be a bug here, IDs are only created if there is a reference to a type
#! 
#foreach (ID<_Choice> ID in IdTYPE.IDs)
			TYPE__#{ID} = Registry.TYPE ("#{ID}"); 
#end foreach
#foreach (ID<_Choice> ID in TokenTYPE.IDs)
			TYPE__#{ID} = Registry.TYPE ("#{ID}"); 
#end foreach


#!#foreach (TYPE<_Choice> Type in Goedel.Registry.Types)
#!            TYPE__#{Type.Label} = Registry.TYPE ("#{Type.Label}"); ;
#!#end foreach

            }


#! #foreach (TYPE<_Choice> Type in Goedel.Registry.Types)

#foreach (ID<_Choice> ID in IdTYPE.IDs)
        public TYPE<#{Class.Namespace}._Choice> TYPE__#{ID} ;
#end foreach
#foreach (ID<_Choice> ID in TokenTYPE.IDs)
        public TYPE<#{Class.Namespace}._Choice> TYPE__#{ID} ;
#end foreach

        private #{Class.Namespace}._Choice New_Choice(string Label) {
            switch (Label) {

#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
#elseif (Item._Tag() == GoedelType.Type)
#% Type T = (Type) Item;
#% ID = T.Id.ToString();
#end if
                case "#{ID}": return New#{ID}();
#end foreach

				}
            throw new System.Exception ("Reserved word not recognized \"" + Label + "\"");
            }


#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
#elseif (Item._Tag() == GoedelType.Type)
#% Type T = (Type) Item;
#% ID = T.Id.ToString();
#end if

        private #{Class.Namespace}.#{ID} New#{ID}() {
            #{Class.Namespace}.#{ID} result = new #{Class.Namespace}.#{ID}();
            Push (result);
            State = StateCode.#{ID}_Start;
            return result;
            }

#end foreach

        static #{Class.Namespace}.#{Class.Name}Type _Reserved(string Label) {
            switch (Label) {

#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
#elseif (Item._Tag() == GoedelType.Type)
#% Type T = (Type) Item;
#% ID = T.Id.ToString();
#end if
                case "#{ID}": return #{Class.Namespace}.#{Class.Name}Type.#{ID};
#end foreach

                }
            return #{Class.Namespace}.#{Class.Name}Type._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (#{Class.Namespace}._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (#{Class.Namespace}._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new System.Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new System.Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            #{Class.Namespace}.#{Class.Name}Type LabelType = _Reserved (Text);
                            if (false#!
#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
 |
									(LabelType == #{Class.Namespace}.#{Class.Name}Type.#{ID})#!
#end if
#end foreach							
) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new System.Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new System.Exception("Too Many Closing Braces");

#foreach (_Choice Item in Class.Entries)
#% string ID = null;
#% List <Entry> Entries = null;
#% bool IsList = false;
#if (Item._Tag() == GoedelType.TopType)
#% TopType T = (TopType) Item;
#% ID = T.Id.ToString();
#% Entries = T.Entries;
#elseif (Item._Tag() == GoedelType.Type)
#% Type T = (Type) Item;
#% ID = T.Id.ToString();
#% Entries = T.Entries;
#end if
                    case StateCode.#{ID}_Start:
#foreach (Entry Entry in Entries)
#% IsList = false;
#switchcast GoedelType Entry.Type
#casecast _Label Label
						// Parser transition for _Label $$$$$
#casecast Options Options
#% IsList = true;
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.#{ID}__#{Entry.Name};
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.#{ID}__#{Entry.Name}: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							#{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            #{Class.Namespace}.#{Class.Name}Type LabelType = _Reserved (Text);
							switch (LabelType) {
#foreach (OptionEntry OEntry in Options.Entries)
								case #{Class.Namespace}.#{Class.Name}Type.#{OEntry.Type} : {

									// #{OEntry.Name}  #{OEntry.Type}
#switchcast GoedelType OEntry.Occurs
#casecast Single Single
									Current_Cast.#{OEntry.Name} = New#{OEntry.Type} ();
#casecast Multiple Multiple
									Current_Cast.#{OEntry.Name}.Add (New#{OEntry.Type} ());
#end switchcast
									break;
									}
#end foreach
								default : {
									throw new System.Exception("Parser Error Expected [#!
#foreach (OptionEntry OEntry in Options.Entries)
#{OEntry.Type} #!
#end foreach						
]");
									}
								}
							}
                        break;
#casecast List List

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.#{ID}__#{Entry.Name};
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.#{ID}__#{Entry.Name}: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

#% IsList = true;
#switch (List.Type._Tag())
#case GoedelType._Label
#% _Label LLabel = (_Label) List.Type;

						/// Label
                        else {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name}.Add (New#{LLabel.Label} ());
                            Represent = true;
                            }

#case GoedelType.Choice
#% Choice Choice = (Choice) List.Type; 
                        else if (Token == TokenType.LABEL) {
							#{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            #{Class.Namespace}.#{Class.Name}Type LabelType = _Reserved (Text);
                            if ( false #!
#foreach (REF<_Choice> Ref in Choice.Entries)
|
									(LabelType == #{Class.Namespace}.#{Class.Name}Type.#{Ref}) #!
#end foreach
) {
                                Current_Cast.#{Entry.Name}.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [#!
#foreach (REF<_Choice> Ref in Choice.Entries)
#{Ref} #!
#end foreach						
]");
								}
							}
#case GoedelType.ChoiceREF
#% ChoiceREF ChoiceREF = (ChoiceREF) List.Type; 

#case GoedelType.ID
#case GoedelType.REF
#% REF REF = (REF) List.Type;
                        else if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name}.Add ( Registry.REF(Position, Text, TYPE__#{REF.Type}, Current_Cast ) );
                            break;
                            }

#case GoedelType.Token
#case GoedelType.String
#case GoedelType.Text
#case GoedelType.Integer
#end switch
                        break;

#casecast Choice Entry_Cast
                        if (Token == TokenType.LABEL) {
							#{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            #{Class.Namespace}.#{Class.Name}Type LabelType = _Reserved (Text);
                            if ( false #!
#foreach (REF<_Choice> Ref in Entry_Cast.Entries)
|
									(LabelType == #{Class.Namespace}.#{Class.Name}Type.#{Ref}) #!
#end foreach
) {
                                State = StateCode.#{ID}__#{Entry.Name};
                                Current_Cast.#{Entry.Name} = New_Choice(Text);
                                }
                            else {
                               throw new System.Exception("Parser Error Expected [#!
#foreach (REF<_Choice> Ref in Entry_Cast.Entries)
#{Ref} #!
#end foreach						
]");
                                }
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [#!
#foreach (REF<_Choice> Ref in Entry_Cast.Entries)
#{Ref} #!
#end foreach						
]");
#casecast ChoiceREF Entry_Cast
                        if (Token == TokenType.LABEL) {
							#{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            #{Class.Namespace}.#{Class.Name}Type LabelType = _Reserved (Text);
                            if ( false #!
#foreach (REF<_Choice> Ref in Entry_Cast.Entries)
|
									(LabelType == #{Class.Namespace}.#{Class.Name}Type.#{Ref}) #!
#end foreach
) {
                                State = StateCode.#{ID}__#{Entry.Name};
                                Current_Cast.#{Entry.Name} = New_Choice(Text);
                                }
                            else {
                                #{Class.Namespace}._Label result = new #{Class.Namespace}._Label();
                                result.Label = Registry.REF(Position, Text, TYPE__#{Entry_Cast.ID}, Current_Cast);
                                Current_Cast.#{Entry.Name} = result;
                                State = StateCode.#{ID}__#{Entry.Name};
                                }
                            break;
                            }
                        else if (Token == TokenType.LITERAL) {
                            #{Class.Namespace}._Label result = new #{Class.Namespace}._Label();
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            result.Label = Registry.REF(Position, Text, TYPE__#{Entry_Cast.ID}, Current_Cast);
                            Current_Cast.#{Entry.Name} = result;
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [#!
#foreach (REF<_Choice> Ref in Entry_Cast.Entries)
#{Ref} #!
#end foreach						
]");
#casecast ID Entry_Cast
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name} = Registry.ID(Position, Text, TYPE__#{Entry_Cast.Type}, Current_Cast);
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");
#casecast REF Entry_Cast
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name} = Registry.REF(Position, Text, TYPE__#{Entry_Cast.Type}, Current_Cast);
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");
#casecast Token Entry_Cast
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name} = Registry.TOKEN(Position, Text, TYPE__#{Entry_Cast.Type}, Current_Cast);
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");
#casecast String Entry_Cast
                        if (Token == TokenType.STRING) {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name} = Text;
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        throw new System.Exception("Expected String");
#casecast Text Text
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.#{ID}__#{Entry.Name}:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name}.Add (Text);
                            break;							
                            }
                       throw new System.Exception("Expected Text");

#% IsList = true;
#casecast Integer Integer
                        if (Token == TokenType.INTEGER) {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name} = Convert.ToInt32(Text);
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        throw new System.Exception("Expected Integer");
#casecast Boolean Boolean
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL))  {
                            #{Class.Namespace}.#{ID} Current_Cast = (#{Class.Namespace}.#{ID})Current;
                            Current_Cast.#{Entry.Name} = Convert.ToBoolean (Text);
                            State = StateCode.#{ID}__#{Entry.Name};
                            break;
                            }
                        throw new System.Exception("Expected True or False");						
#end switchcast

#if !IsList
                    case StateCode.#{ID}__#{Entry.Name}:
#end if
#end foreach
#if !IsList
                        Pop ();
                        Represent = true; 
                        break;
#end if
#end foreach

                    default:
                        throw new System.Exception("Unreachable code reached");
                    }
                }
            }
        }
	}

#end method

#method DeclareEntry Entry Entry
#switchcast GoedelType Entry.Type
#casecast _Label Label
        public #{Label.Label}					#{Entry.Name};
#casecast Options Options
#foreach (OptionEntry OEntry in Options.Entries)
#switchcast GoedelType OEntry.Occurs
#casecast Single Single
		public #{OEntry.Type}  #{OEntry.Name} = new  #{OEntry.Type}();
#casecast Multiple Multiple
		public List<#{OEntry.Type}>  #{OEntry.Name} = new  List <#{OEntry.Type}> ();
#end switchcast
#end foreach
#casecast List List
#% string Type = "???";
#switch (List.Type._Tag())
#case GoedelType._Label
#% _Label LLabel = (_Label) List.Type;
#% Type = LLabel.Label.ToString ();
#case GoedelType.Choice
#% Type = "_Choice";
#case GoedelType.ChoiceREF
#% Type = "_Choice";
#case GoedelType.ID
#% Type = "ID<_Choice>";
#case GoedelType.REF
#% Type = "REF<_Choice>";
#case GoedelType.Token
#% Type = "TOKEN<_Choice>";
#case GoedelType.String
#% Type = "string";
#case GoedelType.Text
#% Type = "String";
#case GoedelType.Integer
#% Type = "int";
#case GoedelType.Boolean
#% Type = "bool";
#end switch
        public List <#{Type}>           #{Entry.Name} = new List<#{Type}> ();
#casecast Choice Choice
        public _Choice					#{Entry.Name};
#casecast ChoiceREF ChoiceREF
        public _Choice					#{Entry.Name};
#casecast ID ID
        public ID<_Choice>				#{Entry.Name}; 
#casecast REF REF
        public REF<_Choice>				#{Entry.Name};
#casecast Token Token
        public TOKEN<_Choice>			#{Entry.Name};
#casecast String String
		public string					#{Entry.Name};
#casecast Text Text
		public List <System.String>			#{Entry.Name} = new List <System.String> (); 
#casecast Integer Integer
		public int						#{Entry.Name};
#casecast Boolean Boolean
		public bool						#{Entry.Name};
#end switchcast
#end method


#method SerializeEntry Entry Entry
#switchcast GoedelType Entry.Type
#casecast _Label Label
#casecast Options Options
			Output.StartList ("");
#foreach (OptionEntry OEntry in Options.Entries)
#switchcast GoedelType OEntry.Occurs
#casecast Single Single
		// public #{OEntry.Type}  #{OEntry.Name} = new  #{OEntry.Type}();
			#{OEntry.Name}.Serialize (Output, true);
#casecast Multiple Multiple
			foreach (#{OEntry.Type} _e in #{OEntry.Name}) {
				_e.Serialize (Output, true);
				}
#end switchcast
#end foreach
			Output.EndList ("");
#casecast List List
			Output.StartList ("");
#switchcast GoedelType List.Type
#casecast _Label LLabel
			foreach (#{LLabel.Label} _e in #{Entry.Name}) {
				_e.Serialize (Output, true);
#casecast Choice Choice
			foreach (_Choice _e in #{Entry.Name}) {
				_e.Serialize (Output, true);
#casecast ChoiceREF ChoiceREF
			foreach (_Choice _e in #{Entry.Name}) {
				_e.Serialize (Output, true);
#casecast ID ID
			foreach (ID<_Choice> _e in #{Entry.Name}) {
				Output.WriteId ("#{Entry.Name}", _e.ToString()); 
#casecast REF REF
			foreach (REF<_Choice> _e in #{Entry.Name}) {
				Output.WriteId ("#{Entry.Name}", _e.ToString());
#casecast Token Token
			foreach (TOKEN<_Choice> _e in #{Entry.Name}) {
				Output.WriteId ("#{Entry.Name}", _e.ToString());
#casecast String String
			foreach (string _e in #{Entry.Name}) {
				Output.WriteAttribute ("#{Entry.Name}", _e);
#casecast Integer Integer
			foreach (int _e in #{Entry.Name}) {
				Output.Write ("#{Entry.Name}", _e);
#casecast Boolean Boolean
			foreach (bool _e in #{Entry.Name}) {
				Output.WriteAttribute ("#{Entry.Name}", _e);
#end switchcast
				}
			Output.EndList ("");
#casecast Choice Choice
	        #{Entry.Name}.Serialize (Output, true);
#casecast ChoiceREF ChoiceREF
	        #{Entry.Name}.Serialize (Output, true);
#casecast ID ID
	        Output.WriteId ("#{Entry.Name}", #{Entry.Name}.ToString()); 
#casecast REF REF
	        Output.WriteId ("#{Entry.Name}", #{Entry.Name}.ToString());
#casecast Token Token
	        Output.WriteId ("#{Entry.Name}", #{Entry.Name}.ToString());
#casecast String String
			Output.WriteAttribute ("#{Entry.Name}", #{Entry.Name});
#casecast Text Text
			foreach (string _s in #{Entry.Name}) {
				Output.WriteAttribute ("#{Entry.Name}",_s);
				}
#casecast Integer Integer
			Output.WriteAttribute ("#{Entry.Name}", #{Entry.Name});
#casecast Boolean Boolean
			Output.WriteAttribute ("#{Entry.Name}", #{Entry.Name});
#end switchcast
#end method

#end pclass