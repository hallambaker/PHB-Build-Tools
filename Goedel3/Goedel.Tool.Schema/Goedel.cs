
//  Test
//  
//  This file was automatically generated at 1/2/2016 11:52:27 PM
//   
//  Changes to this file may be overwritten without warning
//  
//  Generator:  GoedelShell version 1.0.0.0
//      Goedel Script Version : 0.1   Generated 
//      Goedel Schema Version : 0.1   Generated
//  
//      Copyright : Copyright ©  2012
//  
//  Build Platform: Win32NT 6.2.9200.0
//  
//  
//  Copyright (c) 2012 by Default Deny Security Inc.
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;


//
// Namespace GoedelSchema
// Class Goedel
//


// Types
//   TopTypeType
//       Copyright
//       Class
//   TypeType
//       MITLicense
//       BSD2License
//       BSD3License
//       ISCLicense
//       Apache2License
//       OtherLicense
//       TopType
//       Type
//       Entry
//       List
//       Choice
//       ID
//       REF
//       Token
//       String
//       Integer
//       Boolean
//       ChoiceREF
//       Options
//       Remark
//       OptionEntry
//       Single
//       Multiple
//   IdType
//       TopTypeType
//       TypeType
//       IdType
//   NamespaceType
//       GoedelSchema
//   ClassType
//       Goedel
//   NameType
//       Date
//       Holder
//       License
//       Text
//       Namespace
//       Name
//       Entries
//       Id
//       Occurs
//   TokenType
//       NamespaceType
//       ClassType
//       NameType
//       TokenType

namespace GoedelSchema {


    public enum GoedelType {
        _Top,

        Copyright,
        MITLicense,
        BSD2License,
        BSD3License,
        ISCLicense,
        Apache2License,
        OtherLicense,
        Class,
        TopType,
        Type,
        Entry,
        Remark,
        Options,
        OptionEntry,
        Single,
        Multiple,
        List,
        Choice,
        ChoiceREF,
        ID,
        REF,
        Token,
        String,
        Integer,
        Text,
        Boolean,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public GoedelType _Tag ();

		public abstract void Serialize (TextWriter Output, int Indent, bool tag);
        }



    public partial class Copyright : _Choice {
		public string					Date;
		public string					Holder;
        public _Choice					License;

        public override GoedelType _Tag () {
            return GoedelType.Copyright;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			Output.Write (Date);
			Output.Write (Holder);
	        License.Serialize (Output, Indent+1, true);
			}
		}

    public partial class MITLicense : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.MITLicense;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class BSD2License : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.BSD2License;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class BSD3License : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.BSD3License;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class ISCLicense : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.ISCLicense;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class Apache2License : _Choice {
        public override GoedelType _Tag () {
            return GoedelType.Apache2License;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class OtherLicense : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override GoedelType _Tag () {
            return GoedelType.OtherLicense;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			foreach (string _s in Text) {
				Output.Write (_s);
				}
			}
		}

    public partial class Class : _Choice {
        public TOKEN<_Choice>			Namespace;
        public TOKEN<_Choice>			Name;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GoedelType _Tag () {
            return GoedelType.Class;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Namespace);
	        Output.Write (Name);
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, Indent+1, true);
				}
			}
		}

    public partial class TopType : _Choice {
        public ID<_Choice>				Id; 
        public List <Entry>           Entries = new List<Entry> ();

        public override GoedelType _Tag () {
            return GoedelType.TopType;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Id); 
			foreach (Entry _e in Entries) {
				_e.Serialize (Output, Indent+1, true);
				}
			}
		}

    public partial class Type : _Choice {
        public ID<_Choice>				Id; 
        public List <Entry>           Entries = new List<Entry> ();

        public override GoedelType _Tag () {
            return GoedelType.Type;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Id); 
			foreach (Entry _e in Entries) {
				_e.Serialize (Output, Indent+1, true);
				}
			}
		}

    public partial class Entry : _Choice {
        public TOKEN<_Choice>			Name;
        public _Choice					Type;

        public override GoedelType _Tag () {
            return GoedelType.Entry;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Name);
	        Type.Serialize (Output, Indent+1, true);
			}
		}

    public partial class Remark : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override GoedelType _Tag () {
            return GoedelType.Remark;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			foreach (string _s in Text) {
				Output.Write (_s);
				}
			}
		}

    public partial class Options : _Choice {
        public List <OptionEntry>           Entries = new List<OptionEntry> ();

        public override GoedelType _Tag () {
            return GoedelType.Options;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			foreach (OptionEntry _e in Entries) {
				_e.Serialize (Output, Indent+1, true);
				}
			}
		}

    public partial class OptionEntry : _Choice {
        public TOKEN<_Choice>			Name;
        public REF<_Choice>				Type;
        public _Choice					Occurs;

        public override GoedelType _Tag () {
            return GoedelType.OptionEntry;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Name);
	        Output.Write (Type);
	        Occurs.Serialize (Output, Indent+1, true);
			}
		}

    public partial class Single : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.Single;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class Multiple : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.Multiple;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class List : _Choice {
        public _Choice					Type;

        public override GoedelType _Tag () {
            return GoedelType.List;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Type.Serialize (Output, Indent+1, true);
			}
		}

    public partial class Choice : _Choice {
        public List <REF<_Choice>>           Entries = new List<REF<_Choice>> ();

        public override GoedelType _Tag () {
            return GoedelType.Choice;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			foreach (REF<_Choice> _e in Entries) {
				Output.Write (_e);
				}
			}
		}

    public partial class ChoiceREF : _Choice {
        public REF<_Choice>				ID;
        public List <REF<_Choice>>           Entries = new List<REF<_Choice>> ();

        public override GoedelType _Tag () {
            return GoedelType.ChoiceREF;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (ID);
			foreach (REF<_Choice> _e in Entries) {
				Output.Write (_e);
				}
			}
		}

    public partial class ID : _Choice {
        public REF<_Choice>				Type;

        public override GoedelType _Tag () {
            return GoedelType.ID;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Type);
			}
		}

    public partial class REF : _Choice {
        public REF<_Choice>				Type;

        public override GoedelType _Tag () {
            return GoedelType.REF;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Type);
			}
		}

    public partial class Token : _Choice {
        public TOKEN<_Choice>			Type;

        public override GoedelType _Tag () {
            return GoedelType.Token;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
	        Output.Write (Type);
			}
		}

    public partial class String : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.String;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class Integer : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.Integer;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class Text : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.Text;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    public partial class Boolean : _Choice {

        public override GoedelType _Tag () {
            return GoedelType.Boolean;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override GoedelType _Tag () {
            return GoedelType._Label;
            }

		public override void Serialize (TextWriter Output, int Indent, bool tag) {
			Output.Write (Label);
			}
        }
//	}

//namespace Goedel.Registry {

    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Copyright_Start,
		Copyright__Date,				
		Copyright__Holder,				
		Copyright__License,				
		MITLicense_Start,
		BSD2License_Start,
		BSD3License_Start,
		ISCLicense_Start,
		Apache2License_Start,
		OtherLicense_Start,
		OtherLicense__Text,				
		Class_Start,
		Class__Namespace,				
		Class__Name,				
		Class__Entries,				
		TopType_Start,
		TopType__Id,				
		TopType__Entries,				
		Type_Start,
		Type__Id,				
		Type__Entries,				
		Entry_Start,
		Entry__Name,				
		Entry__Type,				
		Remark_Start,
		Remark__Text,				
		Options_Start,
		Options__Entries,				
		OptionEntry_Start,
		OptionEntry__Name,				
		OptionEntry__Type,				
		OptionEntry__Occurs,				
		Single_Start,
		Multiple_Start,
		List_Start,
		List__Type,				
		Choice_Start,
		Choice__Entries,				
		ChoiceREF_Start,
		ChoiceREF__ID,				
		ChoiceREF__Entries,				
		ID_Start,
		ID__Type,				
		REF_Start,
		REF__Type,				
		Token_Start,
		Token__Type,				
		String_Start,
		Integer_Start,
		Text_Start,
		Boolean_Start,
        }


    struct _StackItem {
        public StateCode   State;
        public GoedelSchema._Choice     Token;
        }

    public partial class Goedel : Parser{
        public List <GoedelSchema._Choice>        Top;
        public Registry	<GoedelSchema._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        GoedelSchema._Choice				Current;
        List <_StackItem>						Stack;
        TokenType								CurrentToken;
        Position								CurrentPosition;
        string									CurrentText;



        public Goedel() {
            Top = new List<GoedelSchema._Choice> () ;
            Registry = new Registry <GoedelSchema._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__TopTypeType = Registry.TYPE ("TopTypeType"); 
			TYPE__TypeType = Registry.TYPE ("TypeType"); 
			TYPE__IdType = Registry.TYPE ("IdType"); 
			TYPE__NamespaceType = Registry.TYPE ("NamespaceType"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 
			TYPE__NameType = Registry.TYPE ("NameType"); 
			TYPE__TokenType = Registry.TYPE ("TokenType"); 



            }



        TYPE<GoedelSchema._Choice> TYPE__TopTypeType ;
        TYPE<GoedelSchema._Choice> TYPE__TypeType ;
        TYPE<GoedelSchema._Choice> TYPE__IdType ;
        TYPE<GoedelSchema._Choice> TYPE__NamespaceType ;
        TYPE<GoedelSchema._Choice> TYPE__ClassType ;
        TYPE<GoedelSchema._Choice> TYPE__NameType ;
        TYPE<GoedelSchema._Choice> TYPE__TokenType ;

        private GoedelSchema._Choice New_Choice(string Label) {
            switch (Label) {

                case "Copyright": return NewCopyright();
                case "MITLicense": return NewMITLicense();
                case "BSD2License": return NewBSD2License();
                case "BSD3License": return NewBSD3License();
                case "ISCLicense": return NewISCLicense();
                case "Apache2License": return NewApache2License();
                case "OtherLicense": return NewOtherLicense();
                case "Class": return NewClass();
                case "TopType": return NewTopType();
                case "Type": return NewType();
                case "Entry": return NewEntry();
                case "Remark": return NewRemark();
                case "Options": return NewOptions();
                case "OptionEntry": return NewOptionEntry();
                case "Single": return NewSingle();
                case "Multiple": return NewMultiple();
                case "List": return NewList();
                case "Choice": return NewChoice();
                case "ChoiceREF": return NewChoiceREF();
                case "ID": return NewID();
                case "REF": return NewREF();
                case "Token": return NewToken();
                case "String": return NewString();
                case "Integer": return NewInteger();
                case "Text": return NewText();
                case "Boolean": return NewBoolean();

				}
            throw new Exception("Reserved word not recognized \"" + Label + "\"");
            }



        private GoedelSchema.Copyright NewCopyright() {
            GoedelSchema.Copyright result = new GoedelSchema.Copyright();
            Push (result);
            State = StateCode.Copyright_Start;
            return result;
            }


        private GoedelSchema.MITLicense NewMITLicense() {
            GoedelSchema.MITLicense result = new GoedelSchema.MITLicense();
            Push (result);
            State = StateCode.MITLicense_Start;
            return result;
            }


        private GoedelSchema.BSD2License NewBSD2License() {
            GoedelSchema.BSD2License result = new GoedelSchema.BSD2License();
            Push (result);
            State = StateCode.BSD2License_Start;
            return result;
            }


        private GoedelSchema.BSD3License NewBSD3License() {
            GoedelSchema.BSD3License result = new GoedelSchema.BSD3License();
            Push (result);
            State = StateCode.BSD3License_Start;
            return result;
            }


        private GoedelSchema.ISCLicense NewISCLicense() {
            GoedelSchema.ISCLicense result = new GoedelSchema.ISCLicense();
            Push (result);
            State = StateCode.ISCLicense_Start;
            return result;
            }


        private GoedelSchema.Apache2License NewApache2License() {
            GoedelSchema.Apache2License result = new GoedelSchema.Apache2License();
            Push (result);
            State = StateCode.Apache2License_Start;
            return result;
            }


        private GoedelSchema.OtherLicense NewOtherLicense() {
            GoedelSchema.OtherLicense result = new GoedelSchema.OtherLicense();
            Push (result);
            State = StateCode.OtherLicense_Start;
            return result;
            }


        private GoedelSchema.Class NewClass() {
            GoedelSchema.Class result = new GoedelSchema.Class();
            Push (result);
            State = StateCode.Class_Start;
            return result;
            }


        private GoedelSchema.TopType NewTopType() {
            GoedelSchema.TopType result = new GoedelSchema.TopType();
            Push (result);
            State = StateCode.TopType_Start;
            return result;
            }


        private GoedelSchema.Type NewType() {
            GoedelSchema.Type result = new GoedelSchema.Type();
            Push (result);
            State = StateCode.Type_Start;
            return result;
            }


        private GoedelSchema.Entry NewEntry() {
            GoedelSchema.Entry result = new GoedelSchema.Entry();
            Push (result);
            State = StateCode.Entry_Start;
            return result;
            }


        private GoedelSchema.Remark NewRemark() {
            GoedelSchema.Remark result = new GoedelSchema.Remark();
            Push (result);
            State = StateCode.Remark_Start;
            return result;
            }


        private GoedelSchema.Options NewOptions() {
            GoedelSchema.Options result = new GoedelSchema.Options();
            Push (result);
            State = StateCode.Options_Start;
            return result;
            }


        private GoedelSchema.OptionEntry NewOptionEntry() {
            GoedelSchema.OptionEntry result = new GoedelSchema.OptionEntry();
            Push (result);
            State = StateCode.OptionEntry_Start;
            return result;
            }


        private GoedelSchema.Single NewSingle() {
            GoedelSchema.Single result = new GoedelSchema.Single();
            Push (result);
            State = StateCode.Single_Start;
            return result;
            }


        private GoedelSchema.Multiple NewMultiple() {
            GoedelSchema.Multiple result = new GoedelSchema.Multiple();
            Push (result);
            State = StateCode.Multiple_Start;
            return result;
            }


        private GoedelSchema.List NewList() {
            GoedelSchema.List result = new GoedelSchema.List();
            Push (result);
            State = StateCode.List_Start;
            return result;
            }


        private GoedelSchema.Choice NewChoice() {
            GoedelSchema.Choice result = new GoedelSchema.Choice();
            Push (result);
            State = StateCode.Choice_Start;
            return result;
            }


        private GoedelSchema.ChoiceREF NewChoiceREF() {
            GoedelSchema.ChoiceREF result = new GoedelSchema.ChoiceREF();
            Push (result);
            State = StateCode.ChoiceREF_Start;
            return result;
            }


        private GoedelSchema.ID NewID() {
            GoedelSchema.ID result = new GoedelSchema.ID();
            Push (result);
            State = StateCode.ID_Start;
            return result;
            }


        private GoedelSchema.REF NewREF() {
            GoedelSchema.REF result = new GoedelSchema.REF();
            Push (result);
            State = StateCode.REF_Start;
            return result;
            }


        private GoedelSchema.Token NewToken() {
            GoedelSchema.Token result = new GoedelSchema.Token();
            Push (result);
            State = StateCode.Token_Start;
            return result;
            }


        private GoedelSchema.String NewString() {
            GoedelSchema.String result = new GoedelSchema.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private GoedelSchema.Integer NewInteger() {
            GoedelSchema.Integer result = new GoedelSchema.Integer();
            Push (result);
            State = StateCode.Integer_Start;
            return result;
            }


        private GoedelSchema.Text NewText() {
            GoedelSchema.Text result = new GoedelSchema.Text();
            Push (result);
            State = StateCode.Text_Start;
            return result;
            }


        private GoedelSchema.Boolean NewBoolean() {
            GoedelSchema.Boolean result = new GoedelSchema.Boolean();
            Push (result);
            State = StateCode.Boolean_Start;
            return result;
            }


        static GoedelSchema.GoedelType _Reserved(string Label) {
            switch (Label) {

                case "Copyright": return GoedelSchema.GoedelType.Copyright;
                case "MITLicense": return GoedelSchema.GoedelType.MITLicense;
                case "BSD2License": return GoedelSchema.GoedelType.BSD2License;
                case "BSD3License": return GoedelSchema.GoedelType.BSD3License;
                case "ISCLicense": return GoedelSchema.GoedelType.ISCLicense;
                case "Apache2License": return GoedelSchema.GoedelType.Apache2License;
                case "OtherLicense": return GoedelSchema.GoedelType.OtherLicense;
                case "Class": return GoedelSchema.GoedelType.Class;
                case "TopType": return GoedelSchema.GoedelType.TopType;
                case "Type": return GoedelSchema.GoedelType.Type;
                case "Entry": return GoedelSchema.GoedelType.Entry;
                case "Remark": return GoedelSchema.GoedelType.Remark;
                case "Options": return GoedelSchema.GoedelType.Options;
                case "OptionEntry": return GoedelSchema.GoedelType.OptionEntry;
                case "Single": return GoedelSchema.GoedelType.Single;
                case "Multiple": return GoedelSchema.GoedelType.Multiple;
                case "List": return GoedelSchema.GoedelType.List;
                case "Choice": return GoedelSchema.GoedelType.Choice;
                case "ChoiceREF": return GoedelSchema.GoedelType.ChoiceREF;
                case "ID": return GoedelSchema.GoedelType.ID;
                case "REF": return GoedelSchema.GoedelType.REF;
                case "Token": return GoedelSchema.GoedelType.Token;
                case "String": return GoedelSchema.GoedelType.String;
                case "Integer": return GoedelSchema.GoedelType.Integer;
                case "Text": return GoedelSchema.GoedelType.Text;
                case "Boolean": return GoedelSchema.GoedelType.Boolean;

                }
            return GoedelSchema.GoedelType._Bottom;
            }

		public void Serialize (TextWriter Output) {
			foreach (GoedelSchema._Choice Entry in Top) {
				Entry.Serialize (Output, 0, true);
				}
			}


        void Push (GoedelSchema._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {
            CurrentToken = Token;
            CurrentPosition = Position;
            CurrentText = Text;

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            GoedelSchema.GoedelType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == GoedelSchema.GoedelType.Copyright) |
									(LabelType == GoedelSchema.GoedelType.Class)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new Exception("Too Many Closing Braces");

                    case StateCode.Copyright_Start:
                        if (Token == TokenType.STRING) {
                            GoedelSchema.Copyright Current_Cast = (GoedelSchema.Copyright)Current;
                            Current_Cast.Date = Text;
                            State = StateCode.Copyright__Date;
                            break;
                            }
                        throw new Exception("Expected String");

                    case StateCode.Copyright__Date:
                        if (Token == TokenType.STRING) {
                            GoedelSchema.Copyright Current_Cast = (GoedelSchema.Copyright)Current;
                            Current_Cast.Holder = Text;
                            State = StateCode.Copyright__Holder;
                            break;
                            }
                        throw new Exception("Expected String");

                    case StateCode.Copyright__Holder:
                        if (Token == TokenType.LABEL) {
							GoedelSchema.Copyright Current_Cast = (GoedelSchema.Copyright)Current;
                            GoedelSchema.GoedelType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == GoedelSchema.GoedelType.MITLicense) |
									(LabelType == GoedelSchema.GoedelType.BSD2License) |
									(LabelType == GoedelSchema.GoedelType.BSD3License) |
									(LabelType == GoedelSchema.GoedelType.ISCLicense) |
									(LabelType == GoedelSchema.GoedelType.Apache2License) |
									(LabelType == GoedelSchema.GoedelType.OtherLicense) ) {
                                State = StateCode.Copyright__License;
                                Current_Cast.License = New_Choice(Text);
                                }
                            else {
                               throw new Exception("Parser Error Expected [MITLicense BSD2License BSD3License ISCLicense Apache2License OtherLicense ]");
                                }
                            break;
                            }
                        else throw new Exception("Parser Error Expected [MITLicense BSD2License BSD3License ISCLicense Apache2License OtherLicense ]");

                    case StateCode.Copyright__License:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.MITLicense_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.BSD2License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.BSD3License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.ISCLicense_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Apache2License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OtherLicense_Start:


                        if (Token == TokenType.BEGIN) {
                            State = StateCode.OtherLicense__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.OtherLicense__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            GoedelSchema.OtherLicense Current_Cast = (GoedelSchema.OtherLicense)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Exception("Expected Text");


                    case StateCode.Class_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.Class Current_Cast = (GoedelSchema.Class)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Class__Namespace;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.Class__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.Class Current_Cast = (GoedelSchema.Class)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Name;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.Class__Name:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Class__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Class__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							GoedelSchema.Class Current_Cast = (GoedelSchema.Class)Current;
                            GoedelSchema.GoedelType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == GoedelSchema.GoedelType.TopType) |
									(LabelType == GoedelSchema.GoedelType.Type) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Exception("Parser Error Expected [TopType Type ]");
								}
							}
                        break;


                    case StateCode.TopType_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.TopType Current_Cast = (GoedelSchema.TopType)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__TopTypeType, Current_Cast);
                            State = StateCode.TopType__Id;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.TopType__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.TopType__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.TopType__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            GoedelSchema.TopType Current_Cast = (GoedelSchema.TopType)Current;
                            Current_Cast.Entries.Add (NewEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Type_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.Type Current_Cast = (GoedelSchema.Type)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Type__Id;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.Type__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Type__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Type__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            GoedelSchema.Type Current_Cast = (GoedelSchema.Type)Current;
                            Current_Cast.Entries.Add (NewEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Entry_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.Entry Current_Cast = (GoedelSchema.Entry)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__NameType, Current_Cast);
                            State = StateCode.Entry__Name;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.Entry__Name:
                        if (Token == TokenType.LABEL) {
							GoedelSchema.Entry Current_Cast = (GoedelSchema.Entry)Current;
                            GoedelSchema.GoedelType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == GoedelSchema.GoedelType.List) |
									(LabelType == GoedelSchema.GoedelType.Choice) |
									(LabelType == GoedelSchema.GoedelType.ID) |
									(LabelType == GoedelSchema.GoedelType.REF) |
									(LabelType == GoedelSchema.GoedelType.Token) |
									(LabelType == GoedelSchema.GoedelType.String) |
									(LabelType == GoedelSchema.GoedelType.Text) |
									(LabelType == GoedelSchema.GoedelType.Integer) |
									(LabelType == GoedelSchema.GoedelType.Boolean) |
									(LabelType == GoedelSchema.GoedelType.ChoiceREF) |
									(LabelType == GoedelSchema.GoedelType.Options) |
									(LabelType == GoedelSchema.GoedelType.Remark) ) {
                                State = StateCode.Entry__Type;
                                Current_Cast.Type = New_Choice(Text);
                                }
                            else {
                                GoedelSchema._Label result = new GoedelSchema._Label();
                                result.Label = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                                Current_Cast.Type = result;
                                State = StateCode.Entry__Type;
                                }
                            break;
                            }
                        else if (Token == TokenType.LITERAL) {
                            GoedelSchema._Label result = new GoedelSchema._Label();
                            GoedelSchema.Entry Current_Cast = (GoedelSchema.Entry)Current;
                            result.Label = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            Current_Cast.Type = result;
                            State = StateCode.Entry__Type;
                            break;
                            }
                        else throw new Exception("Parser Error Expected [List Choice ID REF Token String Text Integer Boolean ChoiceREF Options Remark ]");

                    case StateCode.Entry__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Remark_Start:


                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Remark__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Remark__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            GoedelSchema.Remark Current_Cast = (GoedelSchema.Remark)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Exception("Expected Text");


                    case StateCode.Options_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Options__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Options__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            GoedelSchema.Options Current_Cast = (GoedelSchema.Options)Current;
                            Current_Cast.Entries.Add (NewOptionEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.OptionEntry_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.OptionEntry Current_Cast = (GoedelSchema.OptionEntry)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__NameType, Current_Cast);
                            State = StateCode.OptionEntry__Name;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.OptionEntry__Name:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.OptionEntry Current_Cast = (GoedelSchema.OptionEntry)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.OptionEntry__Type;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.OptionEntry__Type:
                        if (Token == TokenType.LABEL) {
							GoedelSchema.OptionEntry Current_Cast = (GoedelSchema.OptionEntry)Current;
                            GoedelSchema.GoedelType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == GoedelSchema.GoedelType.Single) |
									(LabelType == GoedelSchema.GoedelType.Multiple) ) {
                                State = StateCode.OptionEntry__Occurs;
                                Current_Cast.Occurs = New_Choice(Text);
                                }
                            else {
                               throw new Exception("Parser Error Expected [Single Multiple ]");
                                }
                            break;
                            }
                        else throw new Exception("Parser Error Expected [Single Multiple ]");

                    case StateCode.OptionEntry__Occurs:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Single_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Multiple_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.List_Start:
                        if (Token == TokenType.LABEL) {
							GoedelSchema.List Current_Cast = (GoedelSchema.List)Current;
                            GoedelSchema.GoedelType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == GoedelSchema.GoedelType.Choice) |
									(LabelType == GoedelSchema.GoedelType.ID) |
									(LabelType == GoedelSchema.GoedelType.REF) |
									(LabelType == GoedelSchema.GoedelType.Token) |
									(LabelType == GoedelSchema.GoedelType.String) |
									(LabelType == GoedelSchema.GoedelType.Text) |
									(LabelType == GoedelSchema.GoedelType.Integer) ) {
                                State = StateCode.List__Type;
                                Current_Cast.Type = New_Choice(Text);
                                }
                            else {
                                GoedelSchema._Label result = new GoedelSchema._Label();
                                result.Label = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                                Current_Cast.Type = result;
                                State = StateCode.List__Type;
                                }
                            break;
                            }
                        else if (Token == TokenType.LITERAL) {
                            GoedelSchema._Label result = new GoedelSchema._Label();
                            GoedelSchema.List Current_Cast = (GoedelSchema.List)Current;
                            result.Label = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            Current_Cast.Type = result;
                            State = StateCode.List__Type;
                            break;
                            }
                        else throw new Exception("Parser Error Expected [Choice ID REF Token String Text Integer ]");

                    case StateCode.List__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Choice_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Choice__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Choice__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.Choice Current_Cast = (GoedelSchema.Choice)Current;
                            Current_Cast.Entries.Add ( Registry.REF(Position, Text, TYPE__TypeType, Current_Cast ) );
                            break;
                            }

                        break;


                    case StateCode.ChoiceREF_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.ChoiceREF Current_Cast = (GoedelSchema.ChoiceREF)Current;
                            Current_Cast.ID = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.ChoiceREF__ID;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.ChoiceREF__ID:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.ChoiceREF__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.ChoiceREF__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.ChoiceREF Current_Cast = (GoedelSchema.ChoiceREF)Current;
                            Current_Cast.Entries.Add ( Registry.REF(Position, Text, TYPE__TypeType, Current_Cast ) );
                            break;
                            }

                        break;


                    case StateCode.ID_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.ID Current_Cast = (GoedelSchema.ID)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__IdType, Current_Cast);
                            State = StateCode.ID__Type;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.ID__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.REF_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.REF Current_Cast = (GoedelSchema.REF)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__IdType, Current_Cast);
                            State = StateCode.REF__Type;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.REF__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Token_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            GoedelSchema.Token Current_Cast = (GoedelSchema.Token)Current;
                            Current_Cast.Type = Registry.TOKEN(Position, Text, TYPE__TokenType, Current_Cast);
                            State = StateCode.Token__Type;
                            break;
                            }
                        throw new Exception("Expected LABEL or LITERAL");

                    case StateCode.Token__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.String_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Integer_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Text_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Boolean_Start:
                        Pop ();
                        Represent = true; 
                        break;

                    default:
                        throw new Exception("Unreachable code reached");
                    }
                }
            }
        }
	}


