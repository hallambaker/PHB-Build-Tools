#script 1.0
#license MITLicense
#pclass Goedel.Tool.Domainer Generate

#method GenerateCS Domainer Domainer
using System.Net;
using System.Collections.Generic;
namespace Goedel.DNS {

	public partial class DNS {
		// Dictionary of Type names to codes
		//
		// if (DictionaryType.ContainsKey("RR") {
		//    int value = dictionary["RR"];
		//    }
		static Dictionary <string, ushort> DictionaryType = new Dictionary <string, ushort> () {
#foreach (_Choice Toplevel in Domainer.Top)
#switchcast DomainerType Toplevel
#casecast RR RR
			{"#{RR.Id}", #{RR.Code}},
#casecast Q Q
			{"#{Q.Id}", #{Q.Code}},
#end switchcast
#end foreach
			{"*", 255} // End of list * = ALL
			} ;

		static Dictionary <ushort, string> DictionaryCode = new Dictionary <ushort, string> () {
#foreach (_Choice Toplevel in Domainer.Top)
#switchcast DomainerType Toplevel
#casecast RR RR
			{#{RR.Code}, "#{RR.Id}"},
#casecast Q Q
			{#{Q.Code}, "#{Q.Id}"},
#end switchcast
#end foreach
			{0, ""} // End of list * = ALL
			} ;


        public static DNSTypeCode TypeCode(string Tag) {
            if (Tag != null) {
                return (DNSTypeCode) DictionaryType[Tag];
                }
            return 0;
            }
        public static string TypeCode(int Code ) {
            return DictionaryCode[(ushort)Code];
            }
		}


	public enum DNSTypeCode : ushort {
#foreach (_Choice Toplevel in Domainer.Top)
#switchcast DomainerType Toplevel
#casecast RR RR
		#{RR.Id} = #{RR.Code},
#casecast Q Q
		#{Q.Id} = #{Q.Code},  // Used in Queries only
#casecast IG IG
		#{IG.Id} = #{IG.Code},  // Deprecated, NOT IMPLEMENTED
#end switchcast
#end foreach
		Unknown = 0
		}

	// All resource record classes are descended from DNSRR
	public abstract partial  class DNSRecord {
		public virtual DNSTypeCode			Code {
			get {return (0);} }		
		public virtual string	Label {
			get {return ("Unknown");} }	
		public virtual string	Description {
			get {return ("Record is not defined");} }
			
			
			
        public static DNSRecord Decode(DNSBufferIndex Index) {
			DNSRecord			DNSRecord;
			
			Domain				Domain;
			DNSTypeCode			RType;
			DNSClass			RClass;
			uint				TTL;
			int				RDLength;

            Domain = Index.ReadDomain ();
            RType = (DNSTypeCode)Index.ReadInt16 ();
            RClass = (DNSClass)Index.ReadInt16 ();
            TTL = Index.ReadInt32 ();
			RDLength = Index.ReadInt16 ();
			int NextRecord = Index.Pointer + RDLength;

            //Index.ReadL16Data (out RData);

			switch ((int) RType) {
#foreach (_Choice Toplevel in Domainer.Top)
#switchcast DomainerType Toplevel
#casecast RR RR
				case (#{RR.Code}) : {
					DNSRecord = DNSRecord_#{RR.Id}.Decode (Index, RDLength);
					break;
					}
#end switchcast
#end foreach
				default : {
					DNSRecord = DNSRecord_Unknown.Decode (Index, RDLength) ;
					break;
					}
				}
			DNSRecord.Domain = Domain;
			DNSRecord.RType = RType;
			DNSRecord.RClass = RClass;
			DNSRecord.TTL = TTL;
			Index.Pointer = NextRecord;

            return DNSRecord;
            }				

		public static DNSRecord Parse(string Tag, Parse Parse) {
			switch (Tag) {

#foreach (_Choice Toplevel in Domainer.Top)
#switchcast DomainerType Toplevel
#casecast RR RR
				case ("#{RR.Id}") : {
					return DNSRecord_#{RR.Id}.Parse (Parse);
					}
#end switchcast
#end foreach

				default : {
					return null;
					}
				}
			}

		}

		
	public partial class DNSRecord_Unknown : DNSRecord {
		//public DNSBufferIndex   RData;

		public static DNSRecord_Unknown Decode (DNSBufferIndex Index, int Length) {
			DNSRecord_Unknown NewRecord = new DNSRecord_Unknown (); 

			Index.ReadL16Data (out NewRecord.RData);

			return NewRecord;
			}
		}


#foreach (_Choice Toplevel in Domainer.Top)
#switchcast DomainerType Toplevel
#casecast RR RR

	// #{RR.Id} #{RR.Code} #{RR.Description}
	//     See #{RR.Reference}

	public class DNSRecord_#{RR.Id} : DNSRecord {

#foreach (_Choice Entry in RR.Entries)
#if (Entry.TypeCS != null)
		public #{Entry.TypeCS}   #{Entry.IdLabel}  ;
#end if
#end foreach

		public override DNSTypeCode		Code {
			get {return (DNSTypeCode.#{RR.Id});} }		
		public override string	Label {
			get {return ("#{RR.Id}");} }	
		public override string	Description {
			get {return ("#{RR.Description}");} }

        // Convert to canonical form
        public override string Canonical () {
			Canonicalize Canonicalize = new Canonicalize ("#{RR.Id}", Domain);
#foreach (_Choice Entry in RR.Entries)
#if (Entry.Tag != null)
			Canonicalize.#{Entry.Tag}  (#{Entry.IdLabel});
#end if
#end foreach
			return Canonicalize.Text;
            }

        public static DNSRecord_#{RR.Id} Parse(Parse Parse) {
			DNSRecord_#{RR.Id} NewRecord = new DNSRecord_#{RR.Id} () ;
			
#foreach (_Choice Entry in RR.Entries)
#if (Entry.Tag != null)
			NewRecord.#{Entry.IdLabel} = Parse.#{Entry.Tag}  ();
#end if
#end foreach

			return NewRecord;
            }

        // Convert to byte form
        public override void Encode(DNSBufferIndex Index) {
			//Encode Encode = new Encode ();
#foreach (_Choice Entry in RR.Entries)
#switchcast DomainerType Entry
#casecast IPv4 null
			Index.WriteIPv4 (#{Entry.IdLabel});
#casecast IPv6 null
			Index.WriteIPv6 (#{Entry.IdLabel});
#casecast Domain null
			Index.WriteDomain (#{Entry.IdLabel});
#casecast Mail null
			Index.WriteMail (#{Entry.IdLabel});
#casecast NodeID null
			Index.WriteInt64 (#{Entry.IdLabel});
#casecast Byte null
			Index.WriteByte (#{Entry.IdLabel});
#casecast Int16 null
			Index.WriteInt16 (#{Entry.IdLabel});
#casecast Int32 null
			Index.WriteInt32 (#{Entry.IdLabel});
#casecast Time32 null
			Index.WriteInt32 (#{Entry.IdLabel});
#casecast Time48 null
			Index.WriteInt48 (#{Entry.IdLabel});
#casecast String null
			Index.WriteString8 (#{Entry.IdLabel});
#casecast OptionalString null
			if (#{Entry.IdLabel} != null) {
				Index.WriteString8 (#{Entry.IdLabel});
				}
#casecast Strings null
			foreach (string s in #{Entry.IdLabel}) {
				Index.WriteString8 (s);
				}
#casecast StringX null
			Index.WriteString (#{Entry.IdLabel});
#casecast Binary null
			Index.WriteData (#{Entry.IdLabel});
#casecast Binary8 null
			Index.WriteByte ((byte)#{Entry.IdLabel}.Length);
			Index.WriteData (#{Entry.IdLabel});
#casecast Binary16 null
			Index.WriteInt16 (#{Entry.IdLabel}.Length);
			Index.WriteData (#{Entry.IdLabel});
#casecast LBinary Cast
			Index.Write (#{Cast.Length});
			Index.WriteData (#{Entry.IdLabel});
#casecast Hex null
			Index.WriteData (#{Entry.IdLabel});
#casecast Hex8 null
			Index.WriteByte ((byte)#{Entry.IdLabel}.Length);
			Index.WriteData (#{Entry.IdLabel});
#casecast Hex16 null
			Index.WriteInt16 (#{Entry.IdLabel}.Length);
			Index.WriteData (#{Entry.IdLabel});
#casecast OptionList null
			foreach (DNSOption opt in #{Entry.IdLabel}) {
				Index.WriteInt16 (opt.Code);
				Index.WriteInt16 (opt.Data.Length);
				Index.WriteData (opt.Data);
				}
#casecast Gateway null
#end switchcast
			//Encode.#{Entry.Tag}  (#{Entry.IdLabel});
#end foreach
            }

        // Convert from byte form
        public static  DNSRecord_#{RR.Id} Decode (DNSBufferIndex Index, int Length) {
			DNSRecord_#{RR.Id} NewRecord = new DNSRecord_#{RR.Id} () ;
			NewRecord.Start = Index.Pointer;

#foreach (_Choice Entry in RR.Entries)
#switchcast DomainerType Entry
#casecast Binary null
			NewRecord.#{Entry.IdLabel} = Index.ReadData (Length - (Index.Pointer - NewRecord.Start));
#casecast Binary8 null
			{
			int FieldLength = Index.ReadByte ();
			NewRecord.#{Entry.IdLabel} = Index.ReadData (FieldLength);
			}
#casecast Binary16 null
			{
			int FieldLength = Index.ReadInt16 ();
			NewRecord.#{Entry.IdLabel} = Index.ReadData (FieldLength);
			}
#casecast LBinary LBinary
			// Binary - length specified by #{LBinary.Length}
#casecast Hex null
			NewRecord.#{Entry.IdLabel} = Index.ReadData (Length - (Index.Pointer - NewRecord.Start));
#casecast Hex8 null
			{
			int FieldLength = Index.ReadByte ();
			NewRecord.#{Entry.IdLabel} = Index.ReadData (FieldLength);
			}
#casecast Hex16 null
			{
			int FieldLength = Index.ReadInt16 ();
			NewRecord.#{Entry.IdLabel} = Index.ReadData (FieldLength);
			}
#casecast Strings null
			NewRecord.#{Entry.IdLabel} = Index.ReadStrings (Length - (Index.Pointer - NewRecord.Start)) ;
#casecast OptionalString null
			// If there is space left in the record, the optional string will be represented as
			// an octet followed by the string data
			if (Length - (Index.Pointer - NewRecord.Start) > 0) {
				NewRecord.#{Entry.IdLabel} = Index.ReadString ();
				}
			else {
				NewRecord.#{Entry.IdLabel} = null;
				}
#casecast StringX null
			NewRecord.#{Entry.IdLabel} = Index.ReadString (Length - (Index.Pointer - NewRecord.Start));
#% break; } default: {
#if (Entry.Tag != null)
			NewRecord.#{Entry.IdLabel} = Index.Read#{Entry.Tag} ();
#end if
#end switchcast
#end foreach
			

			return NewRecord;
            }

		}
#end switchcast
#end foreach

	}


#end method
#end pclass
