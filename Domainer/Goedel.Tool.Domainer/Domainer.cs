
//  Copyright (c) Comodo Group Inc. by 2013
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;




//
// Namespace Goedel.Tool.Domainer
// Class Domainer
//


// Types
//   TopTypeType
//       Group
//       RR
//       Q
//       IG
//       NA
//   TypeType
//       Obsolete
//       Pseudo
//       Experimental
//       IPv4
//       IPv6
//       Domain
//       Mail
//       NodeID
//       Byte
//       Int16
//       Int32
//       Time32
//       Time48
//       String
//       Strings
//       OptionalString
//       StringX
//       Binary
//       Binary8
//       Binary16
//       LBinary
//       Hex
//       Hex8
//       Hex16
//       List
//       Alt
//       LByte
//       LInt16
//       OptionList
//       Gateway
//       Null
//       AltEntry
//   IdType
//       GroupT
//       RRT
//   NamespaceType
//       Goedel.Tool.Domainer
//   ClassType
//       Domainer
//   NameType
//       Id
//       Members
//       Code
//       Description
//       Reference
//       Entries
//       Length
//       Target
//       Choices
//       Reason
//       First
//       Last
//   TokenType
//       VarT
//       ReasonT

#pragma warning disable IDE0022, IDE0066, IDE1006, IDE0059
namespace Goedel.Tool.Domainer {


    public enum DomainerType {
        _Top,

        Group,
        RR,
        Obsolete,
        Pseudo,
        Experimental,
        IPv4,
        IPv6,
        Domain,
        Mail,
        NodeID,
        Byte,
        Int16,
        Int32,
        Time32,
        Time48,
        String,
        OptionalString,
        Strings,
        StringX,
        Binary,
        Binary8,
        Binary16,
        LBinary,
        LByte,
        LInt16,
        Hex,
        Hex8,
        Hex16,
        Null,
        OptionList,
        Gateway,
        List,
        Alt,
        AltEntry,
        Q,
        IG,
        NA,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public DomainerType _Tag ();

        public _Choice _Parent;
        public Domainer _Base;

		public abstract void Serialize (StructureWriter Output, bool tag);

    	public virtual void Init (_Choice parent) {
            _Parent = parent;
            _Base ??= parent?._Base;
			}

        

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice parent) {
			Init (parent);
            _Base = parent._Base;
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Group : _Choice {
        public ID<_Choice>				Id; 
        public List <REF<_Choice>>           Members = new List<REF<_Choice>> ();

        public override DomainerType _Tag () =>DomainerType.Group;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Group");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (REF<_Choice> _e in Members) {
				Output.WriteId ("Members", _e.ToString());
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Group");
				}			
			}
		}

    public partial class RR : _Choice {
        public ID<_Choice>				Id; 
		public int						Code;
		public string					Description;
		public string					Reference;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override DomainerType _Tag () =>DomainerType.RR;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("RR");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Code", Code);
			Output.WriteAttribute ("Description", Description);
			Output.WriteAttribute ("Reference", Reference);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("RR");
				}			
			}
		}

    public partial class Obsolete : _Choice {

        public override DomainerType _Tag () =>DomainerType.Obsolete;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Obsolete");
				}

			if (tag) {
				Output.EndElement ("Obsolete");
				}			
			}
		}

    public partial class Pseudo : _Choice {

        public override DomainerType _Tag () =>DomainerType.Pseudo;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Pseudo");
				}

			if (tag) {
				Output.EndElement ("Pseudo");
				}			
			}
		}

    public partial class Experimental : _Choice {

        public override DomainerType _Tag () =>DomainerType.Experimental;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Experimental");
				}

			if (tag) {
				Output.EndElement ("Experimental");
				}			
			}
		}

    public partial class IPv4 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.IPv4;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("IPv4");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("IPv4");
				}			
			}
		}

    public partial class IPv6 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.IPv6;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("IPv6");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("IPv6");
				}			
			}
		}

    public partial class Domain : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Domain;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Domain");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Domain");
				}			
			}
		}

    public partial class Mail : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Mail;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Mail");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Mail");
				}			
			}
		}

    public partial class NodeID : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.NodeID;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("NodeID");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("NodeID");
				}			
			}
		}

    public partial class Byte : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Byte;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Byte");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Byte");
				}			
			}
		}

    public partial class Int16 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Int16;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Int16");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Int16");
				}			
			}
		}

    public partial class Int32 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Int32;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Int32");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Int32");
				}			
			}
		}

    public partial class Time32 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Time32;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Time32");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Time32");
				}			
			}
		}

    public partial class Time48 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Time48;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Time48");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Time48");
				}			
			}
		}

    public partial class String : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.String;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class OptionalString : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.OptionalString;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("OptionalString");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("OptionalString");
				}			
			}
		}

    public partial class Strings : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Strings;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Strings");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Strings");
				}			
			}
		}

    public partial class StringX : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.StringX;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("StringX");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("StringX");
				}			
			}
		}

    public partial class Binary : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Binary;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binary");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Binary");
				}			
			}
		}

    public partial class Binary8 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Binary8;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binary8");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Binary8");
				}			
			}
		}

    public partial class Binary16 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Binary16;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binary16");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Binary16");
				}			
			}
		}

    public partial class LBinary : _Choice {
        public TOKEN<_Choice>			Length;
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.LBinary;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("LBinary");
				}

	        Output.WriteId ("Length", Length.ToString());
	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("LBinary");
				}			
			}
		}

    public partial class LByte : _Choice {
        public TOKEN<_Choice>			Target;
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.LByte;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("LByte");
				}

	        Output.WriteId ("Target", Target.ToString());
	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("LByte");
				}			
			}
		}

    public partial class LInt16 : _Choice {
        public TOKEN<_Choice>			Target;
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.LInt16;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("LInt16");
				}

	        Output.WriteId ("Target", Target.ToString());
	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("LInt16");
				}			
			}
		}

    public partial class Hex : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Hex;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Hex");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Hex");
				}			
			}
		}

    public partial class Hex8 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Hex8;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Hex8");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Hex8");
				}			
			}
		}

    public partial class Hex16 : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Hex16;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Hex16");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Hex16");
				}			
			}
		}

    public partial class Null : _Choice {

        public override DomainerType _Tag () =>DomainerType.Null;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Null");
				}

			if (tag) {
				Output.EndElement ("Null");
				}			
			}
		}

    public partial class OptionList : _Choice {
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.OptionList;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("OptionList");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("OptionList");
				}			
			}
		}

    public partial class Gateway : _Choice {
        public TOKEN<_Choice>			Code;
        public TOKEN<_Choice>			Id;

        public override DomainerType _Tag () =>DomainerType.Gateway;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Gateway");
				}

	        Output.WriteId ("Code", Code.ToString());
	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Gateway");
				}			
			}
		}

    public partial class List : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override DomainerType _Tag () =>DomainerType.List;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("List");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("List");
				}			
			}
		}

    public partial class Alt : _Choice {
        public TOKEN<_Choice>			Id;
        public List <AltEntry>           Entries = new List<AltEntry> ();

        public override DomainerType _Tag () =>DomainerType.Alt;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Alt");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (AltEntry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Alt");
				}			
			}
		}

    public partial class AltEntry : _Choice {
		public int						Code;
        public _Choice					Choices;

        public override DomainerType _Tag () =>DomainerType.AltEntry;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			Choices._InitChildren (this);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("AltEntry");
				}

			Output.WriteAttribute ("Code", Code);
	        Choices.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("AltEntry");
				}			
			}
		}

    public partial class Q : _Choice {
        public ID<_Choice>				Id; 
		public int						Code;
		public string					Description;
		public string					Reference;

        public override DomainerType _Tag () =>DomainerType.Q;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Q");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Code", Code);
			Output.WriteAttribute ("Description", Description);
			Output.WriteAttribute ("Reference", Reference);
			if (tag) {
				Output.EndElement ("Q");
				}			
			}
		}

    public partial class IG : _Choice {
        public ID<_Choice>				Id; 
		public int						Code;
		public string					Description;
		public string					Reference;

        public override DomainerType _Tag () =>DomainerType.IG;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("IG");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Code", Code);
			Output.WriteAttribute ("Description", Description);
			Output.WriteAttribute ("Reference", Reference);
			if (tag) {
				Output.EndElement ("IG");
				}			
			}
		}

    public partial class NA : _Choice {
        public TOKEN<_Choice>			Reason;
		public int						First;
		public int						Last;

        public override DomainerType _Tag () =>DomainerType.NA;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("NA");
				}

	        Output.WriteId ("Reason", Reason.ToString());
			Output.WriteAttribute ("First", First);
			Output.WriteAttribute ("Last", Last);
			if (tag) {
				Output.EndElement ("NA");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() =>  Label = null;

        public override DomainerType _Tag () => DomainerType._Label;

		public override void Serialize (StructureWriter Output, bool tag) =>Output.WriteId ("ID", Label.ToString());
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Group_Start,
		Group__Id,				
		Group__Members,				
		RR_Start,
		RR__Id,				
		RR__Code,				
		RR__Description,				
		RR__Reference,				
		RR__Entries,				
		Obsolete_Start,
		Pseudo_Start,
		Experimental_Start,
		IPv4_Start,
		IPv4__Id,				
		IPv6_Start,
		IPv6__Id,				
		Domain_Start,
		Domain__Id,				
		Mail_Start,
		Mail__Id,				
		NodeID_Start,
		NodeID__Id,				
		Byte_Start,
		Byte__Id,				
		Int16_Start,
		Int16__Id,				
		Int32_Start,
		Int32__Id,				
		Time32_Start,
		Time32__Id,				
		Time48_Start,
		Time48__Id,				
		String_Start,
		String__Id,				
		OptionalString_Start,
		OptionalString__Id,				
		Strings_Start,
		Strings__Id,				
		StringX_Start,
		StringX__Id,				
		Binary_Start,
		Binary__Id,				
		Binary8_Start,
		Binary8__Id,				
		Binary16_Start,
		Binary16__Id,				
		LBinary_Start,
		LBinary__Length,				
		LBinary__Id,				
		LByte_Start,
		LByte__Target,				
		LByte__Id,				
		LInt16_Start,
		LInt16__Target,				
		LInt16__Id,				
		Hex_Start,
		Hex__Id,				
		Hex8_Start,
		Hex8__Id,				
		Hex16_Start,
		Hex16__Id,				
		Null_Start,
		OptionList_Start,
		OptionList__Id,				
		Gateway_Start,
		Gateway__Code,				
		Gateway__Id,				
		List_Start,
		List__Id,				
		List__Entries,				
		Alt_Start,
		Alt__Id,				
		Alt__Entries,				
		AltEntry_Start,
		AltEntry__Code,				
		AltEntry__Choices,				
		Q_Start,
		Q__Id,				
		Q__Code,				
		Q__Description,				
		Q__Reference,				
		IG_Start,
		IG__Id,				
		IG__Code,				
		IG__Description,				
		IG__Reference,				
		NA_Start,
		NA__Reason,				
		NA__First,				
		NA__Last,				
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Tool.Domainer._Choice     Token;
        }

    public partial class Domainer : Goedel.Registry.Parser{
        public List <Goedel.Tool.Domainer._Choice>        Top;
        public Registry	<Goedel.Tool.Domainer._Choice>	Registry;

        public bool StartOfEntry {get;  private set;}

        StateCode								State;
        Goedel.Tool.Domainer._Choice				Current;
        List <_StackItem>						Stack;


        public static Domainer Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new Domainer() {
				Options = Options
				};

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
            Result.Init ();
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
                Entry._Base = this;
				Entry._InitChildren (null);
				}
			}

        public Domainer() {
            Top = new List<Goedel.Tool.Domainer._Choice> () ;
            Registry = new Registry <Goedel.Tool.Domainer._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            StartOfEntry = true;

			TYPE__GroupT = Registry.TYPE ("GroupT"); 
			TYPE__RRT = Registry.TYPE ("RRT"); 
			TYPE__VarT = Registry.TYPE ("VarT"); 
			TYPE__ReasonT = Registry.TYPE ("ReasonT"); 



            }



        public TYPE<Goedel.Tool.Domainer._Choice> TYPE__GroupT ;
        public TYPE<Goedel.Tool.Domainer._Choice> TYPE__RRT ;
        public TYPE<Goedel.Tool.Domainer._Choice> TYPE__VarT ;
        public TYPE<Goedel.Tool.Domainer._Choice> TYPE__ReasonT ;

        private Goedel.Tool.Domainer._Choice New_Choice(string Label) {
            switch (Label) {

                case "Group": return NewGroup();
                case "RR": return NewRR();
                case "Obsolete": return NewObsolete();
                case "Pseudo": return NewPseudo();
                case "Experimental": return NewExperimental();
                case "IPv4": return NewIPv4();
                case "IPv6": return NewIPv6();
                case "Domain": return NewDomain();
                case "Mail": return NewMail();
                case "NodeID": return NewNodeID();
                case "Byte": return NewByte();
                case "Int16": return NewInt16();
                case "Int32": return NewInt32();
                case "Time32": return NewTime32();
                case "Time48": return NewTime48();
                case "String": return NewString();
                case "OptionalString": return NewOptionalString();
                case "Strings": return NewStrings();
                case "StringX": return NewStringX();
                case "Binary": return NewBinary();
                case "Binary8": return NewBinary8();
                case "Binary16": return NewBinary16();
                case "LBinary": return NewLBinary();
                case "LByte": return NewLByte();
                case "LInt16": return NewLInt16();
                case "Hex": return NewHex();
                case "Hex8": return NewHex8();
                case "Hex16": return NewHex16();
                case "Null": return NewNull();
                case "OptionList": return NewOptionList();
                case "Gateway": return NewGateway();
                case "List": return NewList();
                case "Alt": return NewAlt();
                case "AltEntry": return NewAltEntry();
                case "Q": return NewQ();
                case "IG": return NewIG();
                case "NA": return NewNA();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Tool.Domainer.Group NewGroup() {
            Goedel.Tool.Domainer.Group result = new Goedel.Tool.Domainer.Group();
            Push (result);
            State = StateCode.Group_Start;
            return result;
            }


        private Goedel.Tool.Domainer.RR NewRR() {
            Goedel.Tool.Domainer.RR result = new Goedel.Tool.Domainer.RR();
            Push (result);
            State = StateCode.RR_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Obsolete NewObsolete() {
            Goedel.Tool.Domainer.Obsolete result = new Goedel.Tool.Domainer.Obsolete();
            Push (result);
            State = StateCode.Obsolete_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Pseudo NewPseudo() {
            Goedel.Tool.Domainer.Pseudo result = new Goedel.Tool.Domainer.Pseudo();
            Push (result);
            State = StateCode.Pseudo_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Experimental NewExperimental() {
            Goedel.Tool.Domainer.Experimental result = new Goedel.Tool.Domainer.Experimental();
            Push (result);
            State = StateCode.Experimental_Start;
            return result;
            }


        private Goedel.Tool.Domainer.IPv4 NewIPv4() {
            Goedel.Tool.Domainer.IPv4 result = new Goedel.Tool.Domainer.IPv4();
            Push (result);
            State = StateCode.IPv4_Start;
            return result;
            }


        private Goedel.Tool.Domainer.IPv6 NewIPv6() {
            Goedel.Tool.Domainer.IPv6 result = new Goedel.Tool.Domainer.IPv6();
            Push (result);
            State = StateCode.IPv6_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Domain NewDomain() {
            Goedel.Tool.Domainer.Domain result = new Goedel.Tool.Domainer.Domain();
            Push (result);
            State = StateCode.Domain_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Mail NewMail() {
            Goedel.Tool.Domainer.Mail result = new Goedel.Tool.Domainer.Mail();
            Push (result);
            State = StateCode.Mail_Start;
            return result;
            }


        private Goedel.Tool.Domainer.NodeID NewNodeID() {
            Goedel.Tool.Domainer.NodeID result = new Goedel.Tool.Domainer.NodeID();
            Push (result);
            State = StateCode.NodeID_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Byte NewByte() {
            Goedel.Tool.Domainer.Byte result = new Goedel.Tool.Domainer.Byte();
            Push (result);
            State = StateCode.Byte_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Int16 NewInt16() {
            Goedel.Tool.Domainer.Int16 result = new Goedel.Tool.Domainer.Int16();
            Push (result);
            State = StateCode.Int16_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Int32 NewInt32() {
            Goedel.Tool.Domainer.Int32 result = new Goedel.Tool.Domainer.Int32();
            Push (result);
            State = StateCode.Int32_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Time32 NewTime32() {
            Goedel.Tool.Domainer.Time32 result = new Goedel.Tool.Domainer.Time32();
            Push (result);
            State = StateCode.Time32_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Time48 NewTime48() {
            Goedel.Tool.Domainer.Time48 result = new Goedel.Tool.Domainer.Time48();
            Push (result);
            State = StateCode.Time48_Start;
            return result;
            }


        private Goedel.Tool.Domainer.String NewString() {
            Goedel.Tool.Domainer.String result = new Goedel.Tool.Domainer.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private Goedel.Tool.Domainer.OptionalString NewOptionalString() {
            Goedel.Tool.Domainer.OptionalString result = new Goedel.Tool.Domainer.OptionalString();
            Push (result);
            State = StateCode.OptionalString_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Strings NewStrings() {
            Goedel.Tool.Domainer.Strings result = new Goedel.Tool.Domainer.Strings();
            Push (result);
            State = StateCode.Strings_Start;
            return result;
            }


        private Goedel.Tool.Domainer.StringX NewStringX() {
            Goedel.Tool.Domainer.StringX result = new Goedel.Tool.Domainer.StringX();
            Push (result);
            State = StateCode.StringX_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Binary NewBinary() {
            Goedel.Tool.Domainer.Binary result = new Goedel.Tool.Domainer.Binary();
            Push (result);
            State = StateCode.Binary_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Binary8 NewBinary8() {
            Goedel.Tool.Domainer.Binary8 result = new Goedel.Tool.Domainer.Binary8();
            Push (result);
            State = StateCode.Binary8_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Binary16 NewBinary16() {
            Goedel.Tool.Domainer.Binary16 result = new Goedel.Tool.Domainer.Binary16();
            Push (result);
            State = StateCode.Binary16_Start;
            return result;
            }


        private Goedel.Tool.Domainer.LBinary NewLBinary() {
            Goedel.Tool.Domainer.LBinary result = new Goedel.Tool.Domainer.LBinary();
            Push (result);
            State = StateCode.LBinary_Start;
            return result;
            }


        private Goedel.Tool.Domainer.LByte NewLByte() {
            Goedel.Tool.Domainer.LByte result = new Goedel.Tool.Domainer.LByte();
            Push (result);
            State = StateCode.LByte_Start;
            return result;
            }


        private Goedel.Tool.Domainer.LInt16 NewLInt16() {
            Goedel.Tool.Domainer.LInt16 result = new Goedel.Tool.Domainer.LInt16();
            Push (result);
            State = StateCode.LInt16_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Hex NewHex() {
            Goedel.Tool.Domainer.Hex result = new Goedel.Tool.Domainer.Hex();
            Push (result);
            State = StateCode.Hex_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Hex8 NewHex8() {
            Goedel.Tool.Domainer.Hex8 result = new Goedel.Tool.Domainer.Hex8();
            Push (result);
            State = StateCode.Hex8_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Hex16 NewHex16() {
            Goedel.Tool.Domainer.Hex16 result = new Goedel.Tool.Domainer.Hex16();
            Push (result);
            State = StateCode.Hex16_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Null NewNull() {
            Goedel.Tool.Domainer.Null result = new Goedel.Tool.Domainer.Null();
            Push (result);
            State = StateCode.Null_Start;
            return result;
            }


        private Goedel.Tool.Domainer.OptionList NewOptionList() {
            Goedel.Tool.Domainer.OptionList result = new Goedel.Tool.Domainer.OptionList();
            Push (result);
            State = StateCode.OptionList_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Gateway NewGateway() {
            Goedel.Tool.Domainer.Gateway result = new Goedel.Tool.Domainer.Gateway();
            Push (result);
            State = StateCode.Gateway_Start;
            return result;
            }


        private Goedel.Tool.Domainer.List NewList() {
            Goedel.Tool.Domainer.List result = new Goedel.Tool.Domainer.List();
            Push (result);
            State = StateCode.List_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Alt NewAlt() {
            Goedel.Tool.Domainer.Alt result = new Goedel.Tool.Domainer.Alt();
            Push (result);
            State = StateCode.Alt_Start;
            return result;
            }


        private Goedel.Tool.Domainer.AltEntry NewAltEntry() {
            Goedel.Tool.Domainer.AltEntry result = new Goedel.Tool.Domainer.AltEntry();
            Push (result);
            State = StateCode.AltEntry_Start;
            return result;
            }


        private Goedel.Tool.Domainer.Q NewQ() {
            Goedel.Tool.Domainer.Q result = new Goedel.Tool.Domainer.Q();
            Push (result);
            State = StateCode.Q_Start;
            return result;
            }


        private Goedel.Tool.Domainer.IG NewIG() {
            Goedel.Tool.Domainer.IG result = new Goedel.Tool.Domainer.IG();
            Push (result);
            State = StateCode.IG_Start;
            return result;
            }


        private Goedel.Tool.Domainer.NA NewNA() {
            Goedel.Tool.Domainer.NA result = new Goedel.Tool.Domainer.NA();
            Push (result);
            State = StateCode.NA_Start;
            return result;
            }


        static Goedel.Tool.Domainer.DomainerType _Reserved(string Label) {
            switch (Label) {

                case "Group": return Goedel.Tool.Domainer.DomainerType.Group;
                case "RR": return Goedel.Tool.Domainer.DomainerType.RR;
                case "Obsolete": return Goedel.Tool.Domainer.DomainerType.Obsolete;
                case "Pseudo": return Goedel.Tool.Domainer.DomainerType.Pseudo;
                case "Experimental": return Goedel.Tool.Domainer.DomainerType.Experimental;
                case "IPv4": return Goedel.Tool.Domainer.DomainerType.IPv4;
                case "IPv6": return Goedel.Tool.Domainer.DomainerType.IPv6;
                case "Domain": return Goedel.Tool.Domainer.DomainerType.Domain;
                case "Mail": return Goedel.Tool.Domainer.DomainerType.Mail;
                case "NodeID": return Goedel.Tool.Domainer.DomainerType.NodeID;
                case "Byte": return Goedel.Tool.Domainer.DomainerType.Byte;
                case "Int16": return Goedel.Tool.Domainer.DomainerType.Int16;
                case "Int32": return Goedel.Tool.Domainer.DomainerType.Int32;
                case "Time32": return Goedel.Tool.Domainer.DomainerType.Time32;
                case "Time48": return Goedel.Tool.Domainer.DomainerType.Time48;
                case "String": return Goedel.Tool.Domainer.DomainerType.String;
                case "OptionalString": return Goedel.Tool.Domainer.DomainerType.OptionalString;
                case "Strings": return Goedel.Tool.Domainer.DomainerType.Strings;
                case "StringX": return Goedel.Tool.Domainer.DomainerType.StringX;
                case "Binary": return Goedel.Tool.Domainer.DomainerType.Binary;
                case "Binary8": return Goedel.Tool.Domainer.DomainerType.Binary8;
                case "Binary16": return Goedel.Tool.Domainer.DomainerType.Binary16;
                case "LBinary": return Goedel.Tool.Domainer.DomainerType.LBinary;
                case "LByte": return Goedel.Tool.Domainer.DomainerType.LByte;
                case "LInt16": return Goedel.Tool.Domainer.DomainerType.LInt16;
                case "Hex": return Goedel.Tool.Domainer.DomainerType.Hex;
                case "Hex8": return Goedel.Tool.Domainer.DomainerType.Hex8;
                case "Hex16": return Goedel.Tool.Domainer.DomainerType.Hex16;
                case "Null": return Goedel.Tool.Domainer.DomainerType.Null;
                case "OptionList": return Goedel.Tool.Domainer.DomainerType.OptionList;
                case "Gateway": return Goedel.Tool.Domainer.DomainerType.Gateway;
                case "List": return Goedel.Tool.Domainer.DomainerType.List;
                case "Alt": return Goedel.Tool.Domainer.DomainerType.Alt;
                case "AltEntry": return Goedel.Tool.Domainer.DomainerType.AltEntry;
                case "Q": return Goedel.Tool.Domainer.DomainerType.Q;
                case "IG": return Goedel.Tool.Domainer.DomainerType.IG;
                case "NA": return Goedel.Tool.Domainer.DomainerType.NA;

                }
            return Goedel.Tool.Domainer.DomainerType._Bottom;
            }


		public void Serialize (TextWriter Output)=> Serialize (Output, OutputFormat.Goedel);

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Tool.Domainer._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Tool.Domainer._Choice Token) {
            _StackItem Item = new _StackItem () {
					State = State,
					Token = Current
					};

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.AssertFalse (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.AssertFalse (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Tool.Domainer.DomainerType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Group) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.RR) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Q) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.IG) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.NA)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) { 
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Group_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Group Current_Cast = (Goedel.Tool.Domainer.Group)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__GroupT, Current_Cast);
                            State = StateCode.Group__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Group__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Group__Members;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Group__Members: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Group Current_Cast = (Goedel.Tool.Domainer.Group)Current;
                            Current_Cast.Members.Add ( Registry.REF(Position, Text, TYPE__RRT, Current_Cast ) );
                            break;
                            }

                        break;


                    case StateCode.RR_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.RR Current_Cast = (Goedel.Tool.Domainer.RR)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__RRT, Current_Cast);
                            State = StateCode.RR__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.RR__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Domainer.RR Current_Cast = (Goedel.Tool.Domainer.RR)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.RR__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.RR__Code:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Domainer.RR Current_Cast = (Goedel.Tool.Domainer.RR)Current;
                            Current_Cast.Description = Text;
                            State = StateCode.RR__Description;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.RR__Description:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Domainer.RR Current_Cast = (Goedel.Tool.Domainer.RR)Current;
                            Current_Cast.Reference = Text;
                            State = StateCode.RR__Reference;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.RR__Reference:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.RR__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.RR__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Domainer.RR Current_Cast = (Goedel.Tool.Domainer.RR)Current;
                            Goedel.Tool.Domainer.DomainerType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Obsolete) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Pseudo) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Experimental) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.IPv4) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.IPv6) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Domain) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Mail) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.NodeID) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Byte) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Int16) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Int32) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Time32) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Time48) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.String) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Strings) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.OptionalString) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.StringX) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Binary) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Binary8) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Binary16) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.LBinary) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Hex) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Hex8) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Hex16) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.List) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Alt) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.LByte) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.LInt16) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.OptionList) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Gateway) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Obsolete Pseudo Experimental IPv4 IPv6 Domain Mail NodeID Byte Int16 Int32 Time32 Time48 String Strings OptionalString StringX Binary Binary8 Binary16 LBinary Hex Hex8 Hex16 List Alt LByte LInt16 OptionList Gateway ]");
								}
							}
                        break;


                    case StateCode.Obsolete_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Pseudo_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Experimental_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.IPv4_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.IPv4 Current_Cast = (Goedel.Tool.Domainer.IPv4)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.IPv4__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.IPv4__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.IPv6_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.IPv6 Current_Cast = (Goedel.Tool.Domainer.IPv6)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.IPv6__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.IPv6__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Domain_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Domain Current_Cast = (Goedel.Tool.Domainer.Domain)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Domain__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Domain__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Mail_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Mail Current_Cast = (Goedel.Tool.Domainer.Mail)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Mail__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Mail__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.NodeID_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.NodeID Current_Cast = (Goedel.Tool.Domainer.NodeID)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.NodeID__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.NodeID__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Byte_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Byte Current_Cast = (Goedel.Tool.Domainer.Byte)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Byte__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Byte__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Int16_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Int16 Current_Cast = (Goedel.Tool.Domainer.Int16)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Int16__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Int16__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Int32_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Int32 Current_Cast = (Goedel.Tool.Domainer.Int32)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Int32__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Int32__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Time32_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Time32 Current_Cast = (Goedel.Tool.Domainer.Time32)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Time32__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Time32__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Time48_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Time48 Current_Cast = (Goedel.Tool.Domainer.Time48)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Time48__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Time48__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.String_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.String Current_Cast = (Goedel.Tool.Domainer.String)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.String__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.String__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OptionalString_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.OptionalString Current_Cast = (Goedel.Tool.Domainer.OptionalString)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.OptionalString__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.OptionalString__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Strings_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Strings Current_Cast = (Goedel.Tool.Domainer.Strings)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Strings__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Strings__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.StringX_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.StringX Current_Cast = (Goedel.Tool.Domainer.StringX)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.StringX__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.StringX__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Binary_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Binary Current_Cast = (Goedel.Tool.Domainer.Binary)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Binary__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Binary__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Binary8_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Binary8 Current_Cast = (Goedel.Tool.Domainer.Binary8)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Binary8__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Binary8__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Binary16_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Binary16 Current_Cast = (Goedel.Tool.Domainer.Binary16)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Binary16__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Binary16__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.LBinary_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.LBinary Current_Cast = (Goedel.Tool.Domainer.LBinary)Current;
                            Current_Cast.Length = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.LBinary__Length;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.LBinary__Length:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.LBinary Current_Cast = (Goedel.Tool.Domainer.LBinary)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.LBinary__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.LBinary__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.LByte_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.LByte Current_Cast = (Goedel.Tool.Domainer.LByte)Current;
                            Current_Cast.Target = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.LByte__Target;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.LByte__Target:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.LByte Current_Cast = (Goedel.Tool.Domainer.LByte)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.LByte__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.LByte__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.LInt16_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.LInt16 Current_Cast = (Goedel.Tool.Domainer.LInt16)Current;
                            Current_Cast.Target = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.LInt16__Target;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.LInt16__Target:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.LInt16 Current_Cast = (Goedel.Tool.Domainer.LInt16)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.LInt16__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.LInt16__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Hex_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Hex Current_Cast = (Goedel.Tool.Domainer.Hex)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Hex__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Hex__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Hex8_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Hex8 Current_Cast = (Goedel.Tool.Domainer.Hex8)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Hex8__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Hex8__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Hex16_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Hex16 Current_Cast = (Goedel.Tool.Domainer.Hex16)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Hex16__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Hex16__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Null_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OptionList_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.OptionList Current_Cast = (Goedel.Tool.Domainer.OptionList)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.OptionList__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.OptionList__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Gateway_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Gateway Current_Cast = (Goedel.Tool.Domainer.Gateway)Current;
                            Current_Cast.Code = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Gateway__Code;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Gateway__Code:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Gateway Current_Cast = (Goedel.Tool.Domainer.Gateway)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Gateway__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Gateway__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.List_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.List Current_Cast = (Goedel.Tool.Domainer.List)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.List__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.List__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.List__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.List__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Domainer.List Current_Cast = (Goedel.Tool.Domainer.List)Current;
                            Goedel.Tool.Domainer.DomainerType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Domainer.DomainerType.IPv4) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.IPv6) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Domain) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Mail) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Byte) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Int16) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Int32) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.String) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Strings) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Binary) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Binary8) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Binary16) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.LBinary) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Hex) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Hex8) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Hex16) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [IPv4 IPv6 Domain Mail Byte Int16 Int32 String Strings Binary Binary8 Binary16 LBinary Hex Hex8 Hex16 ]");
								}
							}
                        break;


                    case StateCode.Alt_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Alt Current_Cast = (Goedel.Tool.Domainer.Alt)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__VarT, Current_Cast);
                            State = StateCode.Alt__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Alt__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Alt__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Alt__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.Domainer.Alt Current_Cast = (Goedel.Tool.Domainer.Alt)Current;
                            Current_Cast.Entries.Add (NewAltEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.AltEntry_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Domainer.AltEntry Current_Cast = (Goedel.Tool.Domainer.AltEntry)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.AltEntry__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.AltEntry__Code:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.Domainer.AltEntry Current_Cast = (Goedel.Tool.Domainer.AltEntry)Current;
                            Goedel.Tool.Domainer.DomainerType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Null) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.IPv4) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.IPv6) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Domain) |
									(LabelType == Goedel.Tool.Domainer.DomainerType.Mail) ) {
                                State = StateCode.AltEntry__Choices;
                                Current_Cast.Choices = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [Null IPv4 IPv6 Domain Mail ]");
                                }
                            break;
                            }
                        else { 
						    throw new Expected("Parser Error Expected [Null IPv4 IPv6 Domain Mail ]");
                            }

                    case StateCode.AltEntry__Choices:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Q_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.Q Current_Cast = (Goedel.Tool.Domainer.Q)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__RRT, Current_Cast);
                            State = StateCode.Q__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Q__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Domainer.Q Current_Cast = (Goedel.Tool.Domainer.Q)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.Q__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Q__Code:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Domainer.Q Current_Cast = (Goedel.Tool.Domainer.Q)Current;
                            Current_Cast.Description = Text;
                            State = StateCode.Q__Description;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Q__Description:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Domainer.Q Current_Cast = (Goedel.Tool.Domainer.Q)Current;
                            Current_Cast.Reference = Text;
                            State = StateCode.Q__Reference;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Q__Reference:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.IG_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.IG Current_Cast = (Goedel.Tool.Domainer.IG)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__RRT, Current_Cast);
                            State = StateCode.IG__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.IG__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Domainer.IG Current_Cast = (Goedel.Tool.Domainer.IG)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.IG__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.IG__Code:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Domainer.IG Current_Cast = (Goedel.Tool.Domainer.IG)Current;
                            Current_Cast.Description = Text;
                            State = StateCode.IG__Description;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.IG__Description:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Domainer.IG Current_Cast = (Goedel.Tool.Domainer.IG)Current;
                            Current_Cast.Reference = Text;
                            State = StateCode.IG__Reference;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.IG__Reference:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.NA_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Domainer.NA Current_Cast = (Goedel.Tool.Domainer.NA)Current;
                            Current_Cast.Reason = Registry.TOKEN(Position, Text, TYPE__ReasonT, Current_Cast);
                            State = StateCode.NA__Reason;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.NA__Reason:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Domainer.NA Current_Cast = (Goedel.Tool.Domainer.NA)Current;
                            Current_Cast.First = Convert.ToInt32(Text);
                            State = StateCode.NA__First;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.NA__First:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Domainer.NA Current_Cast = (Goedel.Tool.Domainer.NA)Current;
                            Current_Cast.Last = Convert.ToInt32(Text);
                            State = StateCode.NA__Last;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.NA__Last:
                        Pop ();
                        Represent = true; 
                        break;

                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}
#pragma warning restore IDE0022	

