<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <title>Automating the Build Process</title>
</head>
<body>

    <h1>
        Automating the build environment</h1>
    <p>
        At this point the build process for our documentation and implementation 
        involves quite a few manual steps. We should automate these steps before going 
        further.</p>
    <p>
        If we are using a makefile, writing rules for using a synthesizer is as easy as 
        writing rules for any other tool. The original Unix system developers used a 
        large number of special purpose tools to build the system.</p>
    <p>
        Using custom tools in Visual Studio is not quite so straightforward. In theory 
        Visual Studio can be extended to support custom tools like ProtoGen. In practive 
        the process is characterized by phrases such as &#39;undocumented&#39;, &#39;no error 
        reports&#39; and &#39;unreliable&#39;. Following the same installation procedure on the same 
        machine sometimes works and sometimes does not and neither Visual Studio nor the 
        platform provides any feedback on why the process is not working.</p>
    <p>
        The approach to build automation I have found works best in Visual Studio is to 
        write a batch file containing the instructions to run the code generators and 
        add a command to call the batch file as a pre-build command. The Confirmation 
        project has the following entry in the Pre-Build event command line:</p>
    <p>
        call &quot;$(ProjectDir)Make.bat&quot;
    </p>
    <p>
        This approach usually works but does have one very important &#39;gotcha&#39; to watch 
        out for. If performing an incremental build (F5), the Pre-Build event is only 
        run if Visual Studio thinks there is work to be done. Visual Studio will not run 
        the batch file if the only files that have changed are the inputs to the 
        synthesizer.</p>
    <p>
        The batch file contains the commands to build the code:</p>
    <pre>SETLOCAL
@echo "Current Directory %cd%"
@echo "Batch file is in %~dp0"
cd %~dp0

protogen Confirmation.Protocol /xml Confirmation.xml /cs Confirmation.cs  /lazy

exit /b 0</pre>

    <p>
        The first four lines set the working directory for the batch file to the 
        directory that the batch file is located in. The final line returns the code 
        &#39;success&#39; to Visual Studio. The build actions are specified inbetween.</p>
    <p>
        Like most tools built using Goedel, ProtoGen and gscript support the /lazy 
        option which tells the tool to only run if either the input file or the tool 
        itself have been changed since the output files were generated. This avoids 
        unnecesary delays in full builds.</p>
    <p>
        Visual Studio does not provide a way to distinguish a partial build from a 
        rebuild in a pre-build action. So if the lazy option is specified the tools will 
        not run even in the case of a rebuild.</p>
    <p>
        One of the less desirable features of the .NET environment is that it only 
        supports dynamic linking of object libraries. This makes tool installation 
        unnecessarily complex, particularly when different tools might be using 
        different versions of the same linked libraries. Many years ago system memory 
        was a scarce resource and sharing dynamic libraries between processes could 
        dramatically improve performance. Splitting a program file into three separate 
        executables to shave a few hundred Kb of memory makes little sense today.</p>
    <p>
        To avoid the inconvenience of having to deal with executables with separate 
        executable libraries I use a free tool written by Microsoft Research that 
        packages an executable program and its dependent libraries into a single 
        executable file. A post-build action calls the packaging tool and causes it to 
        package the executable up and write it out to my tools directory.</p>
    <p>
        Running .NET programs on Unix systems poses a further challenge as the CLR code 
        generated by Visual Studio or Mono requires the CIL runtime to execute. 
        Fortunately, there is a handy tool called
        <a href="http://linux.die.net/man/1/mkbundle">mkbundle</a> in the Mono toolset 
        which can take a CLR executable and convert it to a native Unix executable with 
        all the necessary support libraries statically linked.</p>

</body>
</html>
