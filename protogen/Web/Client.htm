<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Calling the Service as a client</title>
</head>
<body>

<h1>Calling the Service as a client</h1>

    <p>
        Having written a service, the obvious next step is to call it from another 
        program as a client. This is a three step process:</p>
    <ul>
        <li>Create a service connection</li>
        <li>Perform the desired transactions</li>
        <li>Close the service connection</li>
    </ul>
    <p>
        In the C# language binding the service connection is represented by an object 
        named after the service it connects to. To access the Enquirer service we create 
        a new object of the Enquirer class and tell it the DNS name of the service to 
        connect to:</p>
    <pre>Enquirer Client = new Enquirer (&quot;example.com&quot;)</pre>
    <p>
        By default the client will attempt to discover the service using the DNS SRV, 
        AAAA and A records giving the highest priority to returned SRV records and the 
        lowest to A records.</p>
    <p>
        In the case of the Enquirer protocol, the SRV prefix is defined to be 
        _owcp-enquirer._tcp and the default URI stem is /.well-known/owcp-enquirer.
    </p>
    <p>
        If the service requires authentication the caller must provide the necessary 
        authentication credentials:</p>
    <pre>Client.Credential (Id, Secret);</pre>
    <p>
        Note that at this point we have only provided the Enquirer object with the 
        information necessary to establish a connection. The client will not attempt to 
        connect to the service until we send it a request for a transaction:</p>
    <pre>ConfirmationRequest Request = new ConfirmationRequest;
Request.Account = &quot;<a href="mailto:alice@example.com">alice@example.com</a>&quot;;
Request.Text = &quot;Confirm payment of $42.21 to MG Spares?&quot;;
Request.Options = {&quot;Accept&quot;, &quot;Reject&quot;};
ConfirmationResponse = Client.Confirmation (Request);</pre>
    <p>
        The API calls generated by the ProtoGen C# generator are blocking so the client 
        will wait until either the service returns a response or the transaction times 
        out.
    </p>
    <p>
        The C# generator does not generate non-blocking methods because C# allows us to 
        call any function asynchronously by wrapping it in a delegate and using the 
        BeginInvoke and EndInvoke methods to begin the transaction and collect the 
        result.</p>
    <p>
        Once the transaction is complete we can close the service connection by calling 
        the Dispose() method on the client or let the C# garbage collection system do 
        the work for us. We can make sure that the garbage collection disposes of the 
        client object when we have finished using it with the using statement:</p>
    <pre>using (Enquirer Client = new Enquirer (&quot;example.com&quot;)) {
    ConfirmationRequest Request = new ConfirmationRequest;
    Request.Account = &quot;<a href="mailto:alice@example.com">alice@example.com</a>&quot;;
    Request.Text = &quot;Confirm payment of $42.21 to MG Spares?&quot;;
    Request.Options = {&quot;Accept&quot;, &quot;Reject&quot;};
    ConfirmationResponse = Client.Confirmation (Request);
    }</pre>

</body>
</html>
