
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;


//
// Namespace ProtoGen
// Class ProtoStruct
//


// Types
//   TopTypeType
//       Protocol
//       Mapping
//   TypeType
//       Section
//       Service
//       Transaction
//       Message
//       Structure
//       Description
//       Using
//       Extern
//       Enumeration
//       Success
//       Warning
//       Error
//       Status
//       Abstract
//       Inherits
//       External
//       Boolean
//       Integer
//       Binary
//       Float
//       Label
//       Name
//       String
//       URI
//       DateTime
//       Struct
//       TStruct
//       Enum
//       Authentication
//       Format
//       Decimal
//       Select
//       ABNF
//       Tag
//       Required
//       Multiple
//       Default
//       LengthBits
//       LengthFixed
//       Quoted
//       Constraint
//       TaggedType
//       Tagged
//       Require
//       Brief
//       Command
//       OptionSet
//       Enumerate
//       Parameter
//       Option
//       Include
//       Case
//       Maximum
//       Minimum
//       EnumerationEntry
//       Root
//       Language
//       C
//       CS
//       Binding
//       Stubs
//   IdType
//       Top
//       MessageT
//       ClassT
//       StructureT
//       ConstraintType
//       EnumerationType
//       EnumerationLabel
//       ClassType
//       CommandType
//       TypeType
//       OptionSetType
//   NamespaceType
//       ProtoGen
//   ClassType
//       ProtoStruct
//   NameType
//       Namespace
//       Id
//       Prefix
//       Entries
//       Level
//       Title
//       Discovery
//       WellKnown
//       Request
//       Response
//       Class
//       Mechanism
//       Text1
//       Ref
//       Text
//       Options
//       Type
//       Code
//       Value
//       Bits
//       Bytes
//       MappingType
//       For
//   TokenType
//       NamespaceT
//       PrefixT
//       NamespaceType
//       AuthenticationT
//       Variable
//       FormatT
//       PType
//       StatusT
//       CaseType

namespace ProtoGen {


    public enum ProtoStructType {
        _Top,

        Protocol,
        Using,
        Extern,
        Section,
        Service,
        Transaction,
        Message,
        Authentication,
        Structure,
        Description,
        ABNF,
        Abstract,
        Inherits,
        Request,
        Response,
        External,
        Tag,
        Boolean,
        Integer,
        Decimal,
        Float,
        Binary,
        Label,
        Name,
        String,
        Constraint,
        URI,
        DateTime,
        TStruct,
        Struct,
        Enum,
        Select,
        TaggedType,
        Format,
        Tagged,
        Required,
        Multiple,
        Quoted,
        Require,
        Class,
        Command,
        Brief,
        Parameter,
        Status,
        Success,
        Error,
        Warning,
        Option,
        Include,
        OptionSet,
        Enumerate,
        Case,
        Type,
        Default,
        Maximum,
        Minimum,
        LengthBits,
        LengthFixed,
        Enumeration,
        EnumerationEntry,
        Mapping,
        Root,
        Language,
        C,
        CS,
        Stubs,
        Prefix,
        Binding,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public ProtoStructType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);
        }



    public partial class Protocol : _Choice {
        public TOKEN<_Choice>			Namespace;
        public ID<_Choice>				Id; 
        public TOKEN<_Choice>			Prefix;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Protocol;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Protocol");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
	        Output.WriteId ("Prefix", Prefix.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Protocol");
				}			
			}
		}

    public partial class Using : _Choice {
        public TOKEN<_Choice>			Id;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Using;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Using");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Using");
				}			
			}
		}

    public partial class Extern : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Extern;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Extern");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Extern");
				}			
			}
		}

    public partial class Section : _Choice {
		public int						Level;
		public string					Title;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Section;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Section");
				}

			Output.WriteAttribute ("Level", Level);
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Section");
				}			
			}
		}

    public partial class Service : _Choice {
        public ID<_Choice>				Id; 
		public string					Discovery;
		public string					WellKnown;
        public REF<_Choice>				Request;
        public REF<_Choice>				Response;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Service;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Service");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Discovery", Discovery);
			Output.WriteAttribute ("WellKnown", WellKnown);
	        Output.WriteId ("Request", Request.ToString());
	        Output.WriteId ("Response", Response.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Service");
				}			
			}
		}

    public partial class Transaction : _Choice {
        public REF<_Choice>				Class;
        public ID<_Choice>				Id; 
        public REF<_Choice>				Request;
        public REF<_Choice>				Response;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Transaction;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Transaction");
				}

	        Output.WriteId ("Class", Class.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
	        Output.WriteId ("Request", Request.ToString());
	        Output.WriteId ("Response", Response.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Transaction");
				}			
			}
		}

    public partial class Message : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Message;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Message");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Message");
				}			
			}
		}

    public partial class Authentication : _Choice {
        public TOKEN<_Choice>			Mechanism;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Authentication;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Authentication");
				}

	        Output.WriteId ("Mechanism", Mechanism.ToString());
			if (tag) {
				Output.EndElement ("Authentication");
				}			
			}
		}

    public partial class Structure : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Structure;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Structure");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Structure");
				}			
			}
		}

    public partial class Description : _Choice {
		public List <System.String>			Text1 = new List <System.String> (); 

        public override ProtoStructType _Tag () {
            return ProtoStructType.Description;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Description");
				}

			foreach (string _s in Text1) {
				Output.WriteAttribute ("Text1",_s);
				}
			if (tag) {
				Output.EndElement ("Description");
				}			
			}
		}

    public partial class ABNF : _Choice {
		public List <System.String>			Text1 = new List <System.String> (); 

        public override ProtoStructType _Tag () {
            return ProtoStructType.ABNF;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("ABNF");
				}

			foreach (string _s in Text1) {
				Output.WriteAttribute ("Text1",_s);
				}
			if (tag) {
				Output.EndElement ("ABNF");
				}			
			}
		}

    public partial class Abstract : _Choice {

        public override ProtoStructType _Tag () {
            return ProtoStructType.Abstract;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Abstract");
				}

			if (tag) {
				Output.EndElement ("Abstract");
				}			
			}
		}

    public partial class Inherits : _Choice {
        public REF<_Choice>				Ref;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Inherits;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Inherits");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("Inherits");
				}			
			}
		}

    public partial class Request : _Choice {
        public REF<_Choice>				Ref;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Request;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Request");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("Request");
				}			
			}
		}

    public partial class Response : _Choice {
        public REF<_Choice>				Ref;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Response;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Response");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("Response");
				}			
			}
		}

    public partial class External : _Choice {
        public TOKEN<_Choice>			Ref;

        public override ProtoStructType _Tag () {
            return ProtoStructType.External;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("External");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("External");
				}			
			}
		}

    public partial class Tag : _Choice {
		public string					Text;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Tag;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Tag");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Tag");
				}			
			}
		}

    public partial class Boolean : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Boolean;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Boolean");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Boolean");
				}			
			}
		}

    public partial class Integer : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Integer;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Integer");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Integer");
				}			
			}
		}

    public partial class Decimal : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Decimal;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Decimal");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Decimal");
				}			
			}
		}

    public partial class Float : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Float;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Float");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Float");
				}			
			}
		}

    public partial class Binary : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Binary;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binary");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Binary");
				}			
			}
		}

    public partial class Label : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Label");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Label");
				}			
			}
		}

    public partial class Name : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Name;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Name");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Name");
				}			
			}
		}

    public partial class String : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.String;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class Constraint : _Choice {
        public REF<_Choice>				Id;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Constraint;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Constraint");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Constraint");
				}			
			}
		}

    public partial class URI : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.URI;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("URI");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("URI");
				}			
			}
		}

    public partial class DateTime : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.DateTime;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("DateTime");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("DateTime");
				}			
			}
		}

    public partial class TStruct : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.TStruct;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("TStruct");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("TStruct");
				}			
			}
		}

    public partial class Struct : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Struct;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Struct");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Struct");
				}			
			}
		}

    public partial class Enum : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Enum;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enum");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enum");
				}			
			}
		}

    public partial class Select : _Choice {
        public TOKEN<_Choice>			Tag;
        public TOKEN<_Choice>			Id;
        public List <TaggedType>           Entries = new List<TaggedType> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Select;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Select");
				}

	        Output.WriteId ("Tag", Tag.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (TaggedType _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Select");
				}			
			}
		}

    public partial class TaggedType : _Choice {
        public REF<_Choice>				Tag;
        public REF<_Choice>				Type;

        public override ProtoStructType _Tag () {
            return ProtoStructType.TaggedType;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("TaggedType");
				}

	        Output.WriteId ("Tag", Tag.ToString());
	        Output.WriteId ("Type", Type.ToString());
			if (tag) {
				Output.EndElement ("TaggedType");
				}			
			}
		}

    public partial class Format : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Format;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Format");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Format");
				}			
			}
		}

    public partial class Tagged : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Tagged;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Tagged");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Tagged");
				}			
			}
		}

    public partial class Required : _Choice {

        public override ProtoStructType _Tag () {
            return ProtoStructType.Required;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Required");
				}

			if (tag) {
				Output.EndElement ("Required");
				}			
			}
		}

    public partial class Multiple : _Choice {

        public override ProtoStructType _Tag () {
            return ProtoStructType.Multiple;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Multiple");
				}

			if (tag) {
				Output.EndElement ("Multiple");
				}			
			}
		}

    public partial class Quoted : _Choice {

        public override ProtoStructType _Tag () {
            return ProtoStructType.Quoted;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Quoted");
				}

			if (tag) {
				Output.EndElement ("Quoted");
				}			
			}
		}

    public partial class Require : _Choice {
        public REF<_Choice>				Id;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Require;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Require");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Require");
				}			
			}
		}

    public partial class Class : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Class;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Class");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Class");
				}			
			}
		}

    public partial class Command : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Command;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Command");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Command");
				}			
			}
		}

    public partial class Brief : _Choice {
		public string					Text;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Brief;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Brief");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Brief");
				}			
			}
		}

    public partial class Parameter : _Choice {
        public TOKEN<_Choice>			Name;
		public string					Text;
        public REF<_Choice>				Type;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Parameter;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Parameter");
				}

	        Output.WriteId ("Name", Name.ToString());
			Output.WriteAttribute ("Text", Text);
	        Output.WriteId ("Type", Type.ToString());
			if (tag) {
				Output.EndElement ("Parameter");
				}			
			}
		}

    public partial class Status : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Status;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Status");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Status");
				}			
			}
		}

    public partial class Success : _Choice {
        public TOKEN<_Choice>			Id;
		public int						Code;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Success;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Success");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Code", Code);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Success");
				}			
			}
		}

    public partial class Error : _Choice {
        public TOKEN<_Choice>			Id;
		public int						Code;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Error;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Error");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Code", Code);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Error");
				}			
			}
		}

    public partial class Warning : _Choice {
        public TOKEN<_Choice>			Id;
		public int						Code;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Warning;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Warning");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Code", Code);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Warning");
				}			
			}
		}

    public partial class Option : _Choice {
        public TOKEN<_Choice>			Name;
		public string					Command;
        public REF<_Choice>				Type;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Option;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Option");
				}

	        Output.WriteId ("Name", Name.ToString());
			Output.WriteAttribute ("Command", Command);
	        Output.WriteId ("Type", Type.ToString());
			if (tag) {
				Output.EndElement ("Option");
				}			
			}
		}

    public partial class Include : _Choice {
        public REF<_Choice>				Id;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Include;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Include");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Include");
				}			
			}
		}

    public partial class OptionSet : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.OptionSet;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("OptionSet");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("OptionSet");
				}			
			}
		}

    public partial class Enumerate : _Choice {
        public ID<_Choice>				Id; 
        public List <Case>           Entries = new List<Case> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Enumerate;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enumerate");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (Case _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enumerate");
				}			
			}
		}

    public partial class Case : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Case;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Case");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			if (tag) {
				Output.EndElement ("Case");
				}			
			}
		}

    public partial class Type : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Text;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Type;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Type");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Type");
				}			
			}
		}

    public partial class Default : _Choice {
		public string					Value;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Default;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Default");
				}

			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Default");
				}			
			}
		}

    public partial class Maximum : _Choice {
		public int						Value;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Maximum;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Maximum");
				}

			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Maximum");
				}			
			}
		}

    public partial class Minimum : _Choice {
		public int						Value;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Minimum;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Minimum");
				}

			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Minimum");
				}			
			}
		}

    public partial class LengthBits : _Choice {
		public int						Bits;

        public override ProtoStructType _Tag () {
            return ProtoStructType.LengthBits;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("LengthBits");
				}

			Output.WriteAttribute ("Bits", Bits);
			if (tag) {
				Output.EndElement ("LengthBits");
				}			
			}
		}

    public partial class LengthFixed : _Choice {
		public int						Bytes;

        public override ProtoStructType _Tag () {
            return ProtoStructType.LengthFixed;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("LengthFixed");
				}

			Output.WriteAttribute ("Bytes", Bytes);
			if (tag) {
				Output.EndElement ("LengthFixed");
				}			
			}
		}

    public partial class Enumeration : _Choice {
        public ID<_Choice>				Name; 
		public int						Maximum;
        public List <EnumerationEntry>           Entries = new List<EnumerationEntry> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.Enumeration;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enumeration");
				}

	        Output.WriteId ("Name", Name.ToString()); 
			Output.WriteAttribute ("Maximum", Maximum);
			Output.StartList ("");
			foreach (EnumerationEntry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enumeration");
				}			
			}
		}

    public partial class EnumerationEntry : _Choice {
        public ID<_Choice>				Id; 
		public int						Code;

        public override ProtoStructType _Tag () {
            return ProtoStructType.EnumerationEntry;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("EnumerationEntry");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Code", Code);
			if (tag) {
				Output.EndElement ("EnumerationEntry");
				}			
			}
		}

    public partial class Mapping : _Choice {
        public Name					Id;
        public _Choice					MappingType;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Mapping;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Mapping");
				}

	        MappingType.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Mapping");
				}			
			}
		}

    public partial class Root : _Choice {
        public TOKEN<_Choice>			Namespace;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Root;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Root");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
			if (tag) {
				Output.EndElement ("Root");
				}			
			}
		}

    public partial class Language : _Choice {
        public _Choice					For;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Language;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Language");
				}

	        For.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Language");
				}			
			}
		}

    public partial class C : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.C;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("C");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("C");
				}			
			}
		}

    public partial class CS : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () {
            return ProtoStructType.CS;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("CS");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("CS");
				}			
			}
		}

    public partial class Stubs : _Choice {

        public override ProtoStructType _Tag () {
            return ProtoStructType.Stubs;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Stubs");
				}

			if (tag) {
				Output.EndElement ("Stubs");
				}			
			}
		}

    public partial class Prefix : _Choice {
        public TOKEN<_Choice>			Tag;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Prefix;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Prefix");
				}

	        Output.WriteId ("Tag", Tag.ToString());
			if (tag) {
				Output.EndElement ("Prefix");
				}			
			}
		}

    public partial class Binding : _Choice {
		public string					Mapping;
        public _Choice					Type;

        public override ProtoStructType _Tag () {
            return ProtoStructType.Binding;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binding");
				}

			Output.WriteAttribute ("Mapping", Mapping);
	        Type.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Binding");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override ProtoStructType _Tag () {
            return ProtoStructType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }
//	}

//namespace Goedel.Registry {

    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Protocol_Start,
		Protocol__Namespace,				
		Protocol__Id,				
		Protocol__Prefix,				
		Protocol__Entries,				
		Using_Start,
		Using__Id,				
		Extern_Start,
		Extern__Id,				
		Extern__Entries,				
		Section_Start,
		Section__Level,				
		Section__Title,				
		Section__Entries,				
		Service_Start,
		Service__Id,				
		Service__Discovery,				
		Service__WellKnown,				
		Service__Request,				
		Service__Response,				
		Service__Entries,				
		Transaction_Start,
		Transaction__Class,				
		Transaction__Id,				
		Transaction__Request,				
		Transaction__Response,				
		Transaction__Entries,				
		Message_Start,
		Message__Id,				
		Message__Entries,				
		Authentication_Start,
		Authentication__Mechanism,				
		Structure_Start,
		Structure__Id,				
		Structure__Entries,				
		Description_Start,
		Description__Text1,				
		ABNF_Start,
		ABNF__Text1,				
		Abstract_Start,
		Inherits_Start,
		Inherits__Ref,				
		Request_Start,
		Request__Ref,				
		Response_Start,
		Response__Ref,				
		External_Start,
		External__Ref,				
		Tag_Start,
		Tag__Text,				
		Boolean_Start,
		Boolean__Id,				
		Boolean__Options,				
		Integer_Start,
		Integer__Id,				
		Integer__Options,				
		Decimal_Start,
		Decimal__Id,				
		Decimal__Options,				
		Float_Start,
		Float__Id,				
		Float__Options,				
		Binary_Start,
		Binary__Id,				
		Binary__Options,				
		Label_Start,
		Label__Id,				
		Label__Options,				
		Name_Start,
		Name__Id,				
		Name__Options,				
		String_Start,
		String__Id,				
		String__Options,				
		Constraint_Start,
		Constraint__Id,				
		URI_Start,
		URI__Id,				
		URI__Options,				
		DateTime_Start,
		DateTime__Id,				
		DateTime__Options,				
		TStruct_Start,
		TStruct__Type,				
		TStruct__Id,				
		TStruct__Options,				
		Struct_Start,
		Struct__Type,				
		Struct__Id,				
		Struct__Options,				
		Enum_Start,
		Enum__Type,				
		Enum__Id,				
		Enum__Options,				
		Select_Start,
		Select__Tag,				
		Select__Id,				
		Select__Entries,				
		TaggedType_Start,
		TaggedType__Tag,				
		TaggedType__Type,				
		Format_Start,
		Format__Id,				
		Format__Options,				
		Tagged_Start,
		Tagged__Type,				
		Tagged__Id,				
		Tagged__Options,				
		Required_Start,
		Multiple_Start,
		Quoted_Start,
		Require_Start,
		Require__Id,				
		Class_Start,
		Class__Id,				
		Class__Entries,				
		Command_Start,
		Command__Id,				
		Command__Tag,				
		Command__Entries,				
		Brief_Start,
		Brief__Text,				
		Parameter_Start,
		Parameter__Name,				
		Parameter__Text,				
		Parameter__Type,				
		Status_Start,
		Status__Id,				
		Status__Entries,				
		Success_Start,
		Success__Id,				
		Success__Code,				
		Success__Entries,				
		Error_Start,
		Error__Id,				
		Error__Code,				
		Error__Entries,				
		Warning_Start,
		Warning__Id,				
		Warning__Code,				
		Warning__Entries,				
		Option_Start,
		Option__Name,				
		Option__Command,				
		Option__Type,				
		Include_Start,
		Include__Id,				
		OptionSet_Start,
		OptionSet__Id,				
		OptionSet__Options,				
		Enumerate_Start,
		Enumerate__Id,				
		Enumerate__Entries,				
		Case_Start,
		Case__Id,				
		Case__Tag,				
		Type_Start,
		Type__Id,				
		Type__Text,				
		Default_Start,
		Default__Value,				
		Maximum_Start,
		Maximum__Value,				
		Minimum_Start,
		Minimum__Value,				
		LengthBits_Start,
		LengthBits__Bits,				
		LengthFixed_Start,
		LengthFixed__Bytes,				
		Enumeration_Start,
		Enumeration__Name,				
		Enumeration__Maximum,				
		Enumeration__Entries,				
		EnumerationEntry_Start,
		EnumerationEntry__Id,				
		EnumerationEntry__Code,				
		Mapping_Start,
		Mapping__Id,				
		Mapping__MappingType,				
		Root_Start,
		Root__Namespace,				
		Language_Start,
		Language__For,				
		C_Start,
		C__Entries,				
		CS_Start,
		CS__Entries,				
		Stubs_Start,
		Prefix_Start,
		Prefix__Tag,				
		Binding_Start,
		Binding__Mapping,				
		Binding__Type,				
        }


    struct _StackItem {
        public StateCode   State;
        public ProtoGen._Choice     Token;
        }

    public partial class ProtoStruct : Goedel.Registry.Parser{
        public List <ProtoGen._Choice>        Top;
        public Registry	<ProtoGen._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        ProtoGen._Choice				Current;
        List <_StackItem>						Stack;
        TokenType								CurrentToken;
        Position								CurrentPosition;
        string									CurrentText;


        public static ProtoStruct Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new ProtoStruct();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }

            return Result;
            }


        public ProtoStruct() {
            Top = new List<ProtoGen._Choice> () ;
            Registry = new Registry <ProtoGen._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__Top = Registry.TYPE ("Top"); 
			TYPE__MessageT = Registry.TYPE ("MessageT"); 
			TYPE__ClassT = Registry.TYPE ("ClassT"); 
			TYPE__StructureT = Registry.TYPE ("StructureT"); 
			TYPE__ConstraintType = Registry.TYPE ("ConstraintType"); 
			TYPE__EnumerationType = Registry.TYPE ("EnumerationType"); 
			TYPE__EnumerationLabel = Registry.TYPE ("EnumerationLabel"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 
			TYPE__CommandType = Registry.TYPE ("CommandType"); 
			TYPE__TypeType = Registry.TYPE ("TypeType"); 
			TYPE__OptionSetType = Registry.TYPE ("OptionSetType"); 
			TYPE__NamespaceT = Registry.TYPE ("NamespaceT"); 
			TYPE__PrefixT = Registry.TYPE ("PrefixT"); 
			TYPE__NamespaceType = Registry.TYPE ("NamespaceType"); 
			TYPE__AuthenticationT = Registry.TYPE ("AuthenticationT"); 
			TYPE__Variable = Registry.TYPE ("Variable"); 
			TYPE__FormatT = Registry.TYPE ("FormatT"); 
			TYPE__PType = Registry.TYPE ("PType"); 
			TYPE__StatusT = Registry.TYPE ("StatusT"); 
			TYPE__CaseType = Registry.TYPE ("CaseType"); 



            }



        public TYPE<ProtoGen._Choice> TYPE__Top ;
        public TYPE<ProtoGen._Choice> TYPE__MessageT ;
        public TYPE<ProtoGen._Choice> TYPE__ClassT ;
        public TYPE<ProtoGen._Choice> TYPE__StructureT ;
        public TYPE<ProtoGen._Choice> TYPE__ConstraintType ;
        public TYPE<ProtoGen._Choice> TYPE__EnumerationType ;
        public TYPE<ProtoGen._Choice> TYPE__EnumerationLabel ;
        public TYPE<ProtoGen._Choice> TYPE__ClassType ;
        public TYPE<ProtoGen._Choice> TYPE__CommandType ;
        public TYPE<ProtoGen._Choice> TYPE__TypeType ;
        public TYPE<ProtoGen._Choice> TYPE__OptionSetType ;
        public TYPE<ProtoGen._Choice> TYPE__NamespaceT ;
        public TYPE<ProtoGen._Choice> TYPE__PrefixT ;
        public TYPE<ProtoGen._Choice> TYPE__NamespaceType ;
        public TYPE<ProtoGen._Choice> TYPE__AuthenticationT ;
        public TYPE<ProtoGen._Choice> TYPE__Variable ;
        public TYPE<ProtoGen._Choice> TYPE__FormatT ;
        public TYPE<ProtoGen._Choice> TYPE__PType ;
        public TYPE<ProtoGen._Choice> TYPE__StatusT ;
        public TYPE<ProtoGen._Choice> TYPE__CaseType ;

        private ProtoGen._Choice New_Choice(string Label) {
            switch (Label) {

                case "Protocol": return NewProtocol();
                case "Using": return NewUsing();
                case "Extern": return NewExtern();
                case "Section": return NewSection();
                case "Service": return NewService();
                case "Transaction": return NewTransaction();
                case "Message": return NewMessage();
                case "Authentication": return NewAuthentication();
                case "Structure": return NewStructure();
                case "Description": return NewDescription();
                case "ABNF": return NewABNF();
                case "Abstract": return NewAbstract();
                case "Inherits": return NewInherits();
                case "Request": return NewRequest();
                case "Response": return NewResponse();
                case "External": return NewExternal();
                case "Tag": return NewTag();
                case "Boolean": return NewBoolean();
                case "Integer": return NewInteger();
                case "Decimal": return NewDecimal();
                case "Float": return NewFloat();
                case "Binary": return NewBinary();
                case "Label": return NewLabel();
                case "Name": return NewName();
                case "String": return NewString();
                case "Constraint": return NewConstraint();
                case "URI": return NewURI();
                case "DateTime": return NewDateTime();
                case "TStruct": return NewTStruct();
                case "Struct": return NewStruct();
                case "Enum": return NewEnum();
                case "Select": return NewSelect();
                case "TaggedType": return NewTaggedType();
                case "Format": return NewFormat();
                case "Tagged": return NewTagged();
                case "Required": return NewRequired();
                case "Multiple": return NewMultiple();
                case "Quoted": return NewQuoted();
                case "Require": return NewRequire();
                case "Class": return NewClass();
                case "Command": return NewCommand();
                case "Brief": return NewBrief();
                case "Parameter": return NewParameter();
                case "Status": return NewStatus();
                case "Success": return NewSuccess();
                case "Error": return NewError();
                case "Warning": return NewWarning();
                case "Option": return NewOption();
                case "Include": return NewInclude();
                case "OptionSet": return NewOptionSet();
                case "Enumerate": return NewEnumerate();
                case "Case": return NewCase();
                case "Type": return NewType();
                case "Default": return NewDefault();
                case "Maximum": return NewMaximum();
                case "Minimum": return NewMinimum();
                case "LengthBits": return NewLengthBits();
                case "LengthFixed": return NewLengthFixed();
                case "Enumeration": return NewEnumeration();
                case "EnumerationEntry": return NewEnumerationEntry();
                case "Mapping": return NewMapping();
                case "Root": return NewRoot();
                case "Language": return NewLanguage();
                case "C": return NewC();
                case "CS": return NewCS();
                case "Stubs": return NewStubs();
                case "Prefix": return NewPrefix();
                case "Binding": return NewBinding();

				}
            throw new System.Exception ("Reserved word not recognized \"" + Label + "\"");
            }



        private ProtoGen.Protocol NewProtocol() {
            ProtoGen.Protocol result = new ProtoGen.Protocol();
            Push (result);
            State = StateCode.Protocol_Start;
            return result;
            }


        private ProtoGen.Using NewUsing() {
            ProtoGen.Using result = new ProtoGen.Using();
            Push (result);
            State = StateCode.Using_Start;
            return result;
            }


        private ProtoGen.Extern NewExtern() {
            ProtoGen.Extern result = new ProtoGen.Extern();
            Push (result);
            State = StateCode.Extern_Start;
            return result;
            }


        private ProtoGen.Section NewSection() {
            ProtoGen.Section result = new ProtoGen.Section();
            Push (result);
            State = StateCode.Section_Start;
            return result;
            }


        private ProtoGen.Service NewService() {
            ProtoGen.Service result = new ProtoGen.Service();
            Push (result);
            State = StateCode.Service_Start;
            return result;
            }


        private ProtoGen.Transaction NewTransaction() {
            ProtoGen.Transaction result = new ProtoGen.Transaction();
            Push (result);
            State = StateCode.Transaction_Start;
            return result;
            }


        private ProtoGen.Message NewMessage() {
            ProtoGen.Message result = new ProtoGen.Message();
            Push (result);
            State = StateCode.Message_Start;
            return result;
            }


        private ProtoGen.Authentication NewAuthentication() {
            ProtoGen.Authentication result = new ProtoGen.Authentication();
            Push (result);
            State = StateCode.Authentication_Start;
            return result;
            }


        private ProtoGen.Structure NewStructure() {
            ProtoGen.Structure result = new ProtoGen.Structure();
            Push (result);
            State = StateCode.Structure_Start;
            return result;
            }


        private ProtoGen.Description NewDescription() {
            ProtoGen.Description result = new ProtoGen.Description();
            Push (result);
            State = StateCode.Description_Start;
            return result;
            }


        private ProtoGen.ABNF NewABNF() {
            ProtoGen.ABNF result = new ProtoGen.ABNF();
            Push (result);
            State = StateCode.ABNF_Start;
            return result;
            }


        private ProtoGen.Abstract NewAbstract() {
            ProtoGen.Abstract result = new ProtoGen.Abstract();
            Push (result);
            State = StateCode.Abstract_Start;
            return result;
            }


        private ProtoGen.Inherits NewInherits() {
            ProtoGen.Inherits result = new ProtoGen.Inherits();
            Push (result);
            State = StateCode.Inherits_Start;
            return result;
            }


        private ProtoGen.Request NewRequest() {
            ProtoGen.Request result = new ProtoGen.Request();
            Push (result);
            State = StateCode.Request_Start;
            return result;
            }


        private ProtoGen.Response NewResponse() {
            ProtoGen.Response result = new ProtoGen.Response();
            Push (result);
            State = StateCode.Response_Start;
            return result;
            }


        private ProtoGen.External NewExternal() {
            ProtoGen.External result = new ProtoGen.External();
            Push (result);
            State = StateCode.External_Start;
            return result;
            }


        private ProtoGen.Tag NewTag() {
            ProtoGen.Tag result = new ProtoGen.Tag();
            Push (result);
            State = StateCode.Tag_Start;
            return result;
            }


        private ProtoGen.Boolean NewBoolean() {
            ProtoGen.Boolean result = new ProtoGen.Boolean();
            Push (result);
            State = StateCode.Boolean_Start;
            return result;
            }


        private ProtoGen.Integer NewInteger() {
            ProtoGen.Integer result = new ProtoGen.Integer();
            Push (result);
            State = StateCode.Integer_Start;
            return result;
            }


        private ProtoGen.Decimal NewDecimal() {
            ProtoGen.Decimal result = new ProtoGen.Decimal();
            Push (result);
            State = StateCode.Decimal_Start;
            return result;
            }


        private ProtoGen.Float NewFloat() {
            ProtoGen.Float result = new ProtoGen.Float();
            Push (result);
            State = StateCode.Float_Start;
            return result;
            }


        private ProtoGen.Binary NewBinary() {
            ProtoGen.Binary result = new ProtoGen.Binary();
            Push (result);
            State = StateCode.Binary_Start;
            return result;
            }


        private ProtoGen.Label NewLabel() {
            ProtoGen.Label result = new ProtoGen.Label();
            Push (result);
            State = StateCode.Label_Start;
            return result;
            }


        private ProtoGen.Name NewName() {
            ProtoGen.Name result = new ProtoGen.Name();
            Push (result);
            State = StateCode.Name_Start;
            return result;
            }


        private ProtoGen.String NewString() {
            ProtoGen.String result = new ProtoGen.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private ProtoGen.Constraint NewConstraint() {
            ProtoGen.Constraint result = new ProtoGen.Constraint();
            Push (result);
            State = StateCode.Constraint_Start;
            return result;
            }


        private ProtoGen.URI NewURI() {
            ProtoGen.URI result = new ProtoGen.URI();
            Push (result);
            State = StateCode.URI_Start;
            return result;
            }


        private ProtoGen.DateTime NewDateTime() {
            ProtoGen.DateTime result = new ProtoGen.DateTime();
            Push (result);
            State = StateCode.DateTime_Start;
            return result;
            }


        private ProtoGen.TStruct NewTStruct() {
            ProtoGen.TStruct result = new ProtoGen.TStruct();
            Push (result);
            State = StateCode.TStruct_Start;
            return result;
            }


        private ProtoGen.Struct NewStruct() {
            ProtoGen.Struct result = new ProtoGen.Struct();
            Push (result);
            State = StateCode.Struct_Start;
            return result;
            }


        private ProtoGen.Enum NewEnum() {
            ProtoGen.Enum result = new ProtoGen.Enum();
            Push (result);
            State = StateCode.Enum_Start;
            return result;
            }


        private ProtoGen.Select NewSelect() {
            ProtoGen.Select result = new ProtoGen.Select();
            Push (result);
            State = StateCode.Select_Start;
            return result;
            }


        private ProtoGen.TaggedType NewTaggedType() {
            ProtoGen.TaggedType result = new ProtoGen.TaggedType();
            Push (result);
            State = StateCode.TaggedType_Start;
            return result;
            }


        private ProtoGen.Format NewFormat() {
            ProtoGen.Format result = new ProtoGen.Format();
            Push (result);
            State = StateCode.Format_Start;
            return result;
            }


        private ProtoGen.Tagged NewTagged() {
            ProtoGen.Tagged result = new ProtoGen.Tagged();
            Push (result);
            State = StateCode.Tagged_Start;
            return result;
            }


        private ProtoGen.Required NewRequired() {
            ProtoGen.Required result = new ProtoGen.Required();
            Push (result);
            State = StateCode.Required_Start;
            return result;
            }


        private ProtoGen.Multiple NewMultiple() {
            ProtoGen.Multiple result = new ProtoGen.Multiple();
            Push (result);
            State = StateCode.Multiple_Start;
            return result;
            }


        private ProtoGen.Quoted NewQuoted() {
            ProtoGen.Quoted result = new ProtoGen.Quoted();
            Push (result);
            State = StateCode.Quoted_Start;
            return result;
            }


        private ProtoGen.Require NewRequire() {
            ProtoGen.Require result = new ProtoGen.Require();
            Push (result);
            State = StateCode.Require_Start;
            return result;
            }


        private ProtoGen.Class NewClass() {
            ProtoGen.Class result = new ProtoGen.Class();
            Push (result);
            State = StateCode.Class_Start;
            return result;
            }


        private ProtoGen.Command NewCommand() {
            ProtoGen.Command result = new ProtoGen.Command();
            Push (result);
            State = StateCode.Command_Start;
            return result;
            }


        private ProtoGen.Brief NewBrief() {
            ProtoGen.Brief result = new ProtoGen.Brief();
            Push (result);
            State = StateCode.Brief_Start;
            return result;
            }


        private ProtoGen.Parameter NewParameter() {
            ProtoGen.Parameter result = new ProtoGen.Parameter();
            Push (result);
            State = StateCode.Parameter_Start;
            return result;
            }


        private ProtoGen.Status NewStatus() {
            ProtoGen.Status result = new ProtoGen.Status();
            Push (result);
            State = StateCode.Status_Start;
            return result;
            }


        private ProtoGen.Success NewSuccess() {
            ProtoGen.Success result = new ProtoGen.Success();
            Push (result);
            State = StateCode.Success_Start;
            return result;
            }


        private ProtoGen.Error NewError() {
            ProtoGen.Error result = new ProtoGen.Error();
            Push (result);
            State = StateCode.Error_Start;
            return result;
            }


        private ProtoGen.Warning NewWarning() {
            ProtoGen.Warning result = new ProtoGen.Warning();
            Push (result);
            State = StateCode.Warning_Start;
            return result;
            }


        private ProtoGen.Option NewOption() {
            ProtoGen.Option result = new ProtoGen.Option();
            Push (result);
            State = StateCode.Option_Start;
            return result;
            }


        private ProtoGen.Include NewInclude() {
            ProtoGen.Include result = new ProtoGen.Include();
            Push (result);
            State = StateCode.Include_Start;
            return result;
            }


        private ProtoGen.OptionSet NewOptionSet() {
            ProtoGen.OptionSet result = new ProtoGen.OptionSet();
            Push (result);
            State = StateCode.OptionSet_Start;
            return result;
            }


        private ProtoGen.Enumerate NewEnumerate() {
            ProtoGen.Enumerate result = new ProtoGen.Enumerate();
            Push (result);
            State = StateCode.Enumerate_Start;
            return result;
            }


        private ProtoGen.Case NewCase() {
            ProtoGen.Case result = new ProtoGen.Case();
            Push (result);
            State = StateCode.Case_Start;
            return result;
            }


        private ProtoGen.Type NewType() {
            ProtoGen.Type result = new ProtoGen.Type();
            Push (result);
            State = StateCode.Type_Start;
            return result;
            }


        private ProtoGen.Default NewDefault() {
            ProtoGen.Default result = new ProtoGen.Default();
            Push (result);
            State = StateCode.Default_Start;
            return result;
            }


        private ProtoGen.Maximum NewMaximum() {
            ProtoGen.Maximum result = new ProtoGen.Maximum();
            Push (result);
            State = StateCode.Maximum_Start;
            return result;
            }


        private ProtoGen.Minimum NewMinimum() {
            ProtoGen.Minimum result = new ProtoGen.Minimum();
            Push (result);
            State = StateCode.Minimum_Start;
            return result;
            }


        private ProtoGen.LengthBits NewLengthBits() {
            ProtoGen.LengthBits result = new ProtoGen.LengthBits();
            Push (result);
            State = StateCode.LengthBits_Start;
            return result;
            }


        private ProtoGen.LengthFixed NewLengthFixed() {
            ProtoGen.LengthFixed result = new ProtoGen.LengthFixed();
            Push (result);
            State = StateCode.LengthFixed_Start;
            return result;
            }


        private ProtoGen.Enumeration NewEnumeration() {
            ProtoGen.Enumeration result = new ProtoGen.Enumeration();
            Push (result);
            State = StateCode.Enumeration_Start;
            return result;
            }


        private ProtoGen.EnumerationEntry NewEnumerationEntry() {
            ProtoGen.EnumerationEntry result = new ProtoGen.EnumerationEntry();
            Push (result);
            State = StateCode.EnumerationEntry_Start;
            return result;
            }


        private ProtoGen.Mapping NewMapping() {
            ProtoGen.Mapping result = new ProtoGen.Mapping();
            Push (result);
            State = StateCode.Mapping_Start;
            return result;
            }


        private ProtoGen.Root NewRoot() {
            ProtoGen.Root result = new ProtoGen.Root();
            Push (result);
            State = StateCode.Root_Start;
            return result;
            }


        private ProtoGen.Language NewLanguage() {
            ProtoGen.Language result = new ProtoGen.Language();
            Push (result);
            State = StateCode.Language_Start;
            return result;
            }


        private ProtoGen.C NewC() {
            ProtoGen.C result = new ProtoGen.C();
            Push (result);
            State = StateCode.C_Start;
            return result;
            }


        private ProtoGen.CS NewCS() {
            ProtoGen.CS result = new ProtoGen.CS();
            Push (result);
            State = StateCode.CS_Start;
            return result;
            }


        private ProtoGen.Stubs NewStubs() {
            ProtoGen.Stubs result = new ProtoGen.Stubs();
            Push (result);
            State = StateCode.Stubs_Start;
            return result;
            }


        private ProtoGen.Prefix NewPrefix() {
            ProtoGen.Prefix result = new ProtoGen.Prefix();
            Push (result);
            State = StateCode.Prefix_Start;
            return result;
            }


        private ProtoGen.Binding NewBinding() {
            ProtoGen.Binding result = new ProtoGen.Binding();
            Push (result);
            State = StateCode.Binding_Start;
            return result;
            }


        static ProtoGen.ProtoStructType _Reserved(string Label) {
            switch (Label) {

                case "Protocol": return ProtoGen.ProtoStructType.Protocol;
                case "Using": return ProtoGen.ProtoStructType.Using;
                case "Extern": return ProtoGen.ProtoStructType.Extern;
                case "Section": return ProtoGen.ProtoStructType.Section;
                case "Service": return ProtoGen.ProtoStructType.Service;
                case "Transaction": return ProtoGen.ProtoStructType.Transaction;
                case "Message": return ProtoGen.ProtoStructType.Message;
                case "Authentication": return ProtoGen.ProtoStructType.Authentication;
                case "Structure": return ProtoGen.ProtoStructType.Structure;
                case "Description": return ProtoGen.ProtoStructType.Description;
                case "ABNF": return ProtoGen.ProtoStructType.ABNF;
                case "Abstract": return ProtoGen.ProtoStructType.Abstract;
                case "Inherits": return ProtoGen.ProtoStructType.Inherits;
                case "Request": return ProtoGen.ProtoStructType.Request;
                case "Response": return ProtoGen.ProtoStructType.Response;
                case "External": return ProtoGen.ProtoStructType.External;
                case "Tag": return ProtoGen.ProtoStructType.Tag;
                case "Boolean": return ProtoGen.ProtoStructType.Boolean;
                case "Integer": return ProtoGen.ProtoStructType.Integer;
                case "Decimal": return ProtoGen.ProtoStructType.Decimal;
                case "Float": return ProtoGen.ProtoStructType.Float;
                case "Binary": return ProtoGen.ProtoStructType.Binary;
                case "Label": return ProtoGen.ProtoStructType.Label;
                case "Name": return ProtoGen.ProtoStructType.Name;
                case "String": return ProtoGen.ProtoStructType.String;
                case "Constraint": return ProtoGen.ProtoStructType.Constraint;
                case "URI": return ProtoGen.ProtoStructType.URI;
                case "DateTime": return ProtoGen.ProtoStructType.DateTime;
                case "TStruct": return ProtoGen.ProtoStructType.TStruct;
                case "Struct": return ProtoGen.ProtoStructType.Struct;
                case "Enum": return ProtoGen.ProtoStructType.Enum;
                case "Select": return ProtoGen.ProtoStructType.Select;
                case "TaggedType": return ProtoGen.ProtoStructType.TaggedType;
                case "Format": return ProtoGen.ProtoStructType.Format;
                case "Tagged": return ProtoGen.ProtoStructType.Tagged;
                case "Required": return ProtoGen.ProtoStructType.Required;
                case "Multiple": return ProtoGen.ProtoStructType.Multiple;
                case "Quoted": return ProtoGen.ProtoStructType.Quoted;
                case "Require": return ProtoGen.ProtoStructType.Require;
                case "Class": return ProtoGen.ProtoStructType.Class;
                case "Command": return ProtoGen.ProtoStructType.Command;
                case "Brief": return ProtoGen.ProtoStructType.Brief;
                case "Parameter": return ProtoGen.ProtoStructType.Parameter;
                case "Status": return ProtoGen.ProtoStructType.Status;
                case "Success": return ProtoGen.ProtoStructType.Success;
                case "Error": return ProtoGen.ProtoStructType.Error;
                case "Warning": return ProtoGen.ProtoStructType.Warning;
                case "Option": return ProtoGen.ProtoStructType.Option;
                case "Include": return ProtoGen.ProtoStructType.Include;
                case "OptionSet": return ProtoGen.ProtoStructType.OptionSet;
                case "Enumerate": return ProtoGen.ProtoStructType.Enumerate;
                case "Case": return ProtoGen.ProtoStructType.Case;
                case "Type": return ProtoGen.ProtoStructType.Type;
                case "Default": return ProtoGen.ProtoStructType.Default;
                case "Maximum": return ProtoGen.ProtoStructType.Maximum;
                case "Minimum": return ProtoGen.ProtoStructType.Minimum;
                case "LengthBits": return ProtoGen.ProtoStructType.LengthBits;
                case "LengthFixed": return ProtoGen.ProtoStructType.LengthFixed;
                case "Enumeration": return ProtoGen.ProtoStructType.Enumeration;
                case "EnumerationEntry": return ProtoGen.ProtoStructType.EnumerationEntry;
                case "Mapping": return ProtoGen.ProtoStructType.Mapping;
                case "Root": return ProtoGen.ProtoStructType.Root;
                case "Language": return ProtoGen.ProtoStructType.Language;
                case "C": return ProtoGen.ProtoStructType.C;
                case "CS": return ProtoGen.ProtoStructType.CS;
                case "Stubs": return ProtoGen.ProtoStructType.Stubs;
                case "Prefix": return ProtoGen.ProtoStructType.Prefix;
                case "Binding": return ProtoGen.ProtoStructType.Binding;

                }
            return ProtoGen.ProtoStructType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (ProtoGen._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (ProtoGen._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new System.Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {
            CurrentToken = Token;
            CurrentPosition = Position;
            CurrentText = Text;

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new System.Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == ProtoGen.ProtoStructType.Protocol) |
									(LabelType == ProtoGen.ProtoStructType.Class) |
									(LabelType == ProtoGen.ProtoStructType.Mapping)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new System.Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new System.Exception("Too Many Closing Braces");

                    case StateCode.Protocol_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Protocol Current_Cast = (ProtoGen.Protocol)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__NamespaceT, Current_Cast);
                            State = StateCode.Protocol__Namespace;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Protocol__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Protocol Current_Cast = (ProtoGen.Protocol)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__Top, Current_Cast);
                            State = StateCode.Protocol__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Protocol__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Protocol Current_Cast = (ProtoGen.Protocol)Current;
                            Current_Cast.Prefix = Registry.TOKEN(Position, Text, TYPE__PrefixT, Current_Cast);
                            State = StateCode.Protocol__Prefix;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Protocol__Prefix:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Protocol__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Protocol__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Protocol Current_Cast = (ProtoGen.Protocol)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Section) |
									(LabelType == ProtoGen.ProtoStructType.Service) |
									(LabelType == ProtoGen.ProtoStructType.Transaction) |
									(LabelType == ProtoGen.ProtoStructType.Message) |
									(LabelType == ProtoGen.ProtoStructType.Structure) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Using) |
									(LabelType == ProtoGen.ProtoStructType.Extern) |
									(LabelType == ProtoGen.ProtoStructType.Enumeration) |
									(LabelType == ProtoGen.ProtoStructType.Success) |
									(LabelType == ProtoGen.ProtoStructType.Warning) |
									(LabelType == ProtoGen.ProtoStructType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Section Service Transaction Message Structure Description Using Extern Enumeration Success Warning Error ]");
								}
							}
                        break;


                    case StateCode.Using_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Using Current_Cast = (ProtoGen.Using)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Using__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Using__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Extern_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Extern Current_Cast = (ProtoGen.Extern)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Extern__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Extern__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Extern__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Extern__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Extern Current_Cast = (ProtoGen.Extern)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Section_Start:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.Section Current_Cast = (ProtoGen.Section)Current;
                            Current_Cast.Level = Convert.ToInt32(Text);
                            State = StateCode.Section__Level;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Section__Level:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Section Current_Cast = (ProtoGen.Section)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Section__Title;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Section__Title:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Section__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Section__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Section Current_Cast = (ProtoGen.Section)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Service_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Service Current_Cast = (ProtoGen.Service)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ClassT, Current_Cast);
                            State = StateCode.Service__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Service__Id:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Service Current_Cast = (ProtoGen.Service)Current;
                            Current_Cast.Discovery = Text;
                            State = StateCode.Service__Discovery;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Service__Discovery:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Service Current_Cast = (ProtoGen.Service)Current;
                            Current_Cast.WellKnown = Text;
                            State = StateCode.Service__WellKnown;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Service__WellKnown:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Service Current_Cast = (ProtoGen.Service)Current;
                            Current_Cast.Request = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Service__Request;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Service__Request:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Service Current_Cast = (ProtoGen.Service)Current;
                            Current_Cast.Response = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Service__Response;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Service__Response:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Service__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Service__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Service Current_Cast = (ProtoGen.Service)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Status) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description Status ]");
								}
							}
                        break;


                    case StateCode.Transaction_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Transaction Current_Cast = (ProtoGen.Transaction)Current;
                            Current_Cast.Class = Registry.REF(Position, Text, TYPE__ClassT, Current_Cast);
                            State = StateCode.Transaction__Class;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Class:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Transaction Current_Cast = (ProtoGen.Transaction)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Transaction__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Transaction Current_Cast = (ProtoGen.Transaction)Current;
                            Current_Cast.Request = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Transaction__Request;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Request:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Transaction Current_Cast = (ProtoGen.Transaction)Current;
                            Current_Cast.Response = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Transaction__Response;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Response:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Transaction__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Transaction__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Transaction Current_Cast = (ProtoGen.Transaction)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Status) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description Status ]");
								}
							}
                        break;


                    case StateCode.Message_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Message Current_Cast = (ProtoGen.Message)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Message__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Message__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Message__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Message__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Message Current_Cast = (ProtoGen.Message)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Abstract) |
									(LabelType == ProtoGen.ProtoStructType.Inherits) |
									(LabelType == ProtoGen.ProtoStructType.External) |
									(LabelType == ProtoGen.ProtoStructType.Boolean) |
									(LabelType == ProtoGen.ProtoStructType.Integer) |
									(LabelType == ProtoGen.ProtoStructType.Binary) |
									(LabelType == ProtoGen.ProtoStructType.Float) |
									(LabelType == ProtoGen.ProtoStructType.Label) |
									(LabelType == ProtoGen.ProtoStructType.Name) |
									(LabelType == ProtoGen.ProtoStructType.String) |
									(LabelType == ProtoGen.ProtoStructType.URI) |
									(LabelType == ProtoGen.ProtoStructType.DateTime) |
									(LabelType == ProtoGen.ProtoStructType.Struct) |
									(LabelType == ProtoGen.ProtoStructType.TStruct) |
									(LabelType == ProtoGen.ProtoStructType.Enum) |
									(LabelType == ProtoGen.ProtoStructType.Status) |
									(LabelType == ProtoGen.ProtoStructType.Authentication) |
									(LabelType == ProtoGen.ProtoStructType.Format) |
									(LabelType == ProtoGen.ProtoStructType.Decimal) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description Abstract Inherits External Boolean Integer Binary Float Label Name String URI DateTime Struct TStruct Enum Status Authentication Format Decimal ]");
								}
							}
                        break;


                    case StateCode.Authentication_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Authentication Current_Cast = (ProtoGen.Authentication)Current;
                            Current_Cast.Mechanism = Registry.TOKEN(Position, Text, TYPE__AuthenticationT, Current_Cast);
                            State = StateCode.Authentication__Mechanism;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Authentication__Mechanism:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Structure_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Structure Current_Cast = (ProtoGen.Structure)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.Structure__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Structure__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Structure__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Structure__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Structure Current_Cast = (ProtoGen.Structure)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Abstract) |
									(LabelType == ProtoGen.ProtoStructType.Inherits) |
									(LabelType == ProtoGen.ProtoStructType.External) |
									(LabelType == ProtoGen.ProtoStructType.Boolean) |
									(LabelType == ProtoGen.ProtoStructType.Integer) |
									(LabelType == ProtoGen.ProtoStructType.Binary) |
									(LabelType == ProtoGen.ProtoStructType.Float) |
									(LabelType == ProtoGen.ProtoStructType.Label) |
									(LabelType == ProtoGen.ProtoStructType.Name) |
									(LabelType == ProtoGen.ProtoStructType.String) |
									(LabelType == ProtoGen.ProtoStructType.URI) |
									(LabelType == ProtoGen.ProtoStructType.DateTime) |
									(LabelType == ProtoGen.ProtoStructType.Struct) |
									(LabelType == ProtoGen.ProtoStructType.TStruct) |
									(LabelType == ProtoGen.ProtoStructType.Enum) |
									(LabelType == ProtoGen.ProtoStructType.Format) |
									(LabelType == ProtoGen.ProtoStructType.Decimal) |
									(LabelType == ProtoGen.ProtoStructType.Select) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description Abstract Inherits External Boolean Integer Binary Float Label Name String URI DateTime Struct TStruct Enum Format Decimal Select ]");
								}
							}
                        break;


                    case StateCode.Description_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Description__Text1;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Description__Text1:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            ProtoGen.Description Current_Cast = (ProtoGen.Description)Current;
                            Current_Cast.Text1.Add (Text);
                            break;							
                            }
                       throw new System.Exception("Expected Text");


                    case StateCode.ABNF_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.ABNF__Text1;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.ABNF__Text1:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            ProtoGen.ABNF Current_Cast = (ProtoGen.ABNF)Current;
                            Current_Cast.Text1.Add (Text);
                            break;							
                            }
                       throw new System.Exception("Expected Text");


                    case StateCode.Abstract_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Inherits_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Inherits Current_Cast = (ProtoGen.Inherits)Current;
                            Current_Cast.Ref = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Inherits__Ref;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Inherits__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Request_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Request Current_Cast = (ProtoGen.Request)Current;
                            Current_Cast.Ref = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Request__Ref;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Request__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Response_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Response Current_Cast = (ProtoGen.Response)Current;
                            Current_Cast.Ref = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Response__Ref;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Response__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.External_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.External Current_Cast = (ProtoGen.External)Current;
                            Current_Cast.Ref = Registry.TOKEN(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.External__Ref;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.External__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Tag_Start:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Tag Current_Cast = (ProtoGen.Tag)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Tag__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Tag__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Boolean_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Boolean Current_Cast = (ProtoGen.Boolean)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Boolean__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Boolean__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Boolean__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Boolean__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Boolean Current_Cast = (ProtoGen.Boolean)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default ]");
								}
							}
                        break;


                    case StateCode.Integer_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Integer Current_Cast = (ProtoGen.Integer)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Integer__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Integer__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Integer__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Integer__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Integer Current_Cast = (ProtoGen.Integer)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default LengthBits Tag ]");
								}
							}
                        break;


                    case StateCode.Decimal_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Decimal Current_Cast = (ProtoGen.Decimal)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Decimal__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Decimal__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Decimal__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Decimal__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Decimal Current_Cast = (ProtoGen.Decimal)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.Float_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Float Current_Cast = (ProtoGen.Float)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Float__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Float__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Float__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Float__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Float Current_Cast = (ProtoGen.Float)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.Binary_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Binary Current_Cast = (ProtoGen.Binary)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Binary__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Binary__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Binary__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Binary__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Binary Current_Cast = (ProtoGen.Binary)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == ProtoGen.ProtoStructType.LengthFixed) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default LengthBits LengthFixed Tag ]");
								}
							}
                        break;


                    case StateCode.Label_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Label Current_Cast = (ProtoGen.Label)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Label__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Label__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Label__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Label__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Label Current_Cast = (ProtoGen.Label)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.Name_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Name Current_Cast = (ProtoGen.Name)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Name__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Name__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Name__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Name__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Name Current_Cast = (ProtoGen.Name)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.String_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.String Current_Cast = (ProtoGen.String)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.String__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.String__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.String__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.String__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.String Current_Cast = (ProtoGen.String)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.Quoted) |
									(LabelType == ProtoGen.ProtoStructType.Constraint) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default Quoted Constraint Tag ]");
								}
							}
                        break;


                    case StateCode.Constraint_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Constraint Current_Cast = (ProtoGen.Constraint)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ConstraintType, Current_Cast);
                            State = StateCode.Constraint__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Constraint__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.URI_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.URI Current_Cast = (ProtoGen.URI)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.URI__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.URI__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.URI__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.URI__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.URI Current_Cast = (ProtoGen.URI)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.DateTime_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.DateTime Current_Cast = (ProtoGen.DateTime)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.DateTime__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.DateTime__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.DateTime__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.DateTime__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.DateTime Current_Cast = (ProtoGen.DateTime)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Default) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.TStruct_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.TStruct Current_Cast = (ProtoGen.TStruct)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.TStruct__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.TStruct__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.TStruct Current_Cast = (ProtoGen.TStruct)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.TStruct__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.TStruct__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.TStruct__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.TStruct__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.TStruct Current_Cast = (ProtoGen.TStruct)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description LengthBits Tag ]");
								}
							}
                        break;


                    case StateCode.Struct_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Struct Current_Cast = (ProtoGen.Struct)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.Struct__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Struct__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Struct Current_Cast = (ProtoGen.Struct)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Struct__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Struct__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Struct__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Struct__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Struct Current_Cast = (ProtoGen.Struct)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description LengthBits Tag ]");
								}
							}
                        break;


                    case StateCode.Enum_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Enum Current_Cast = (ProtoGen.Enum)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__EnumerationType, Current_Cast);
                            State = StateCode.Enum__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Enum__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Enum Current_Cast = (ProtoGen.Enum)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Enum__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Enum__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enum__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enum__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Enum Current_Cast = (ProtoGen.Enum)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description Tag ]");
								}
							}
                        break;


                    case StateCode.Select_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Select Current_Cast = (ProtoGen.Select)Current;
                            Current_Cast.Tag = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Select__Tag;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Select__Tag:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Select Current_Cast = (ProtoGen.Select)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Select__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Select__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Select__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Select__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            ProtoGen.Select Current_Cast = (ProtoGen.Select)Current;
                            Current_Cast.Entries.Add (NewTaggedType ());
                            Represent = true;
                            }

                        break;


                    case StateCode.TaggedType_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.TaggedType Current_Cast = (ProtoGen.TaggedType)Current;
                            Current_Cast.Tag = Registry.REF(Position, Text, TYPE__EnumerationLabel, Current_Cast);
                            State = StateCode.TaggedType__Tag;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.TaggedType__Tag:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.TaggedType Current_Cast = (ProtoGen.TaggedType)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.TaggedType__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.TaggedType__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Format_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Format Current_Cast = (ProtoGen.Format)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FormatT, Current_Cast);
                            State = StateCode.Format__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Format__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Format__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Format__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Format Current_Cast = (ProtoGen.Format)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) |
									(LabelType == ProtoGen.ProtoStructType.ABNF) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description ABNF ]");
								}
							}
                        break;


                    case StateCode.Tagged_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Tagged Current_Cast = (ProtoGen.Tagged)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Tagged__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Tagged__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Tagged Current_Cast = (ProtoGen.Tagged)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Tagged__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Tagged__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Tagged__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Tagged__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Tagged Current_Cast = (ProtoGen.Tagged)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Required) |
									(LabelType == ProtoGen.ProtoStructType.Multiple) |
									(LabelType == ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Required Multiple Description ]");
								}
							}
                        break;


                    case StateCode.Required_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Multiple_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Quoted_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Require_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Require Current_Cast = (ProtoGen.Require)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Require__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Require__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Class_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Class Current_Cast = (ProtoGen.Class)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Class__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Class__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Class__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Class Current_Cast = (ProtoGen.Class)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Brief) |
									(LabelType == ProtoGen.ProtoStructType.Command) |
									(LabelType == ProtoGen.ProtoStructType.OptionSet) |
									(LabelType == ProtoGen.ProtoStructType.Enumerate) |
									(LabelType == ProtoGen.ProtoStructType.Type) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief Command OptionSet Enumerate Type ]");
								}
							}
                        break;


                    case StateCode.Command_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Command Current_Cast = (ProtoGen.Command)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__CommandType, Current_Cast);
                            State = StateCode.Command__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Command__Id:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Command Current_Cast = (ProtoGen.Command)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Command__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Command__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Command__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Command__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Command Current_Cast = (ProtoGen.Command)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Brief) |
									(LabelType == ProtoGen.ProtoStructType.Parameter) |
									(LabelType == ProtoGen.ProtoStructType.Option) |
									(LabelType == ProtoGen.ProtoStructType.Include) |
									(LabelType == ProtoGen.ProtoStructType.Default) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Brief Parameter Option Include Default ]");
								}
							}
                        break;


                    case StateCode.Brief_Start:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Brief Current_Cast = (ProtoGen.Brief)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Brief__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Brief__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Parameter_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Parameter Current_Cast = (ProtoGen.Parameter)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__PType, Current_Cast);
                            State = StateCode.Parameter__Name;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Name:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Parameter Current_Cast = (ProtoGen.Parameter)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Parameter__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Parameter__Text:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Parameter Current_Cast = (ProtoGen.Parameter)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Parameter__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Status_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Status Current_Cast = (ProtoGen.Status)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Status__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Status__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Status__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Status__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Status Current_Cast = (ProtoGen.Status)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Success_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Success Current_Cast = (ProtoGen.Success)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Success__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Success__Id:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.Success Current_Cast = (ProtoGen.Success)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.Success__Code;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Success__Code:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Success__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Success__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Success Current_Cast = (ProtoGen.Success)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Error_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Error Current_Cast = (ProtoGen.Error)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Error__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Error__Id:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.Error Current_Cast = (ProtoGen.Error)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.Error__Code;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Error__Code:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Error__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Error__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Error Current_Cast = (ProtoGen.Error)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Warning_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Warning Current_Cast = (ProtoGen.Warning)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Warning__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Warning__Id:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.Warning Current_Cast = (ProtoGen.Warning)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.Warning__Code;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Warning__Code:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Warning__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Warning__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.Warning Current_Cast = (ProtoGen.Warning)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Option_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Option Current_Cast = (ProtoGen.Option)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__PType, Current_Cast);
                            State = StateCode.Option__Name;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Option__Name:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Option Current_Cast = (ProtoGen.Option)Current;
                            Current_Cast.Command = Text;
                            State = StateCode.Option__Command;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Option__Command:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Option Current_Cast = (ProtoGen.Option)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Option__Type;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Option__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Include_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Include Current_Cast = (ProtoGen.Include)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__OptionSetType, Current_Cast);
                            State = StateCode.Include__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Include__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OptionSet_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.OptionSet Current_Cast = (ProtoGen.OptionSet)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__OptionSetType, Current_Cast);
                            State = StateCode.OptionSet__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.OptionSet__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.OptionSet__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.OptionSet__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.OptionSet Current_Cast = (ProtoGen.OptionSet)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Option) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Option ]");
								}
							}
                        break;


                    case StateCode.Enumerate_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Enumerate Current_Cast = (ProtoGen.Enumerate)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Enumerate__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Enumerate__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enumerate__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enumerate__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            ProtoGen.Enumerate Current_Cast = (ProtoGen.Enumerate)Current;
                            Current_Cast.Entries.Add (NewCase ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Case_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Case Current_Cast = (ProtoGen.Case)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__CaseType, Current_Cast);
                            State = StateCode.Case__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Case__Id:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Case Current_Cast = (ProtoGen.Case)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Case__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Case__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Type_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Type Current_Cast = (ProtoGen.Type)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Type__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Type__Id:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Type Current_Cast = (ProtoGen.Type)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Type__Text;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Type__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Default_Start:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Default Current_Cast = (ProtoGen.Default)Current;
                            Current_Cast.Value = Text;
                            State = StateCode.Default__Value;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Default__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Maximum_Start:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.Maximum Current_Cast = (ProtoGen.Maximum)Current;
                            Current_Cast.Value = Convert.ToInt32(Text);
                            State = StateCode.Maximum__Value;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Maximum__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Minimum_Start:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.Minimum Current_Cast = (ProtoGen.Minimum)Current;
                            Current_Cast.Value = Convert.ToInt32(Text);
                            State = StateCode.Minimum__Value;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Minimum__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.LengthBits_Start:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.LengthBits Current_Cast = (ProtoGen.LengthBits)Current;
                            Current_Cast.Bits = Convert.ToInt32(Text);
                            State = StateCode.LengthBits__Bits;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.LengthBits__Bits:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.LengthFixed_Start:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.LengthFixed Current_Cast = (ProtoGen.LengthFixed)Current;
                            Current_Cast.Bytes = Convert.ToInt32(Text);
                            State = StateCode.LengthFixed__Bytes;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.LengthFixed__Bytes:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Enumeration_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Enumeration Current_Cast = (ProtoGen.Enumeration)Current;
                            Current_Cast.Name = Registry.ID(Position, Text, TYPE__EnumerationType, Current_Cast);
                            State = StateCode.Enumeration__Name;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Enumeration__Name:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.Enumeration Current_Cast = (ProtoGen.Enumeration)Current;
                            Current_Cast.Maximum = Convert.ToInt32(Text);
                            State = StateCode.Enumeration__Maximum;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.Enumeration__Maximum:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enumeration__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enumeration__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            ProtoGen.Enumeration Current_Cast = (ProtoGen.Enumeration)Current;
                            Current_Cast.Entries.Add (NewEnumerationEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.EnumerationEntry_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.EnumerationEntry Current_Cast = (ProtoGen.EnumerationEntry)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__EnumerationLabel, Current_Cast);
                            State = StateCode.EnumerationEntry__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.EnumerationEntry__Id:
                        if (Token == TokenType.INTEGER) {
                            ProtoGen.EnumerationEntry Current_Cast = (ProtoGen.EnumerationEntry)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.EnumerationEntry__Code;
                            break;
                            }
                        throw new System.Exception("Expected Integer");

                    case StateCode.EnumerationEntry__Code:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Mapping_Start:
						// Parser transition for _Label $$$$$

                    case StateCode.Mapping__Id:
                        if (Token == TokenType.LABEL) {
							ProtoGen.Mapping Current_Cast = (ProtoGen.Mapping)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Root) |
									(LabelType == ProtoGen.ProtoStructType.Language) ) {
                                State = StateCode.Mapping__MappingType;
                                Current_Cast.MappingType = New_Choice(Text);
                                }
                            else {
                               throw new System.Exception("Parser Error Expected [Root Language ]");
                                }
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Root Language ]");

                    case StateCode.Mapping__MappingType:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Root_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Root Current_Cast = (ProtoGen.Root)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Root__Namespace;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Root__Namespace:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Language_Start:
                        if (Token == TokenType.LABEL) {
							ProtoGen.Language Current_Cast = (ProtoGen.Language)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.C) |
									(LabelType == ProtoGen.ProtoStructType.CS) ) {
                                State = StateCode.Language__For;
                                Current_Cast.For = New_Choice(Text);
                                }
                            else {
                               throw new System.Exception("Parser Error Expected [C CS ]");
                                }
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [C CS ]");

                    case StateCode.Language__For:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.C_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.C__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.C__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.C Current_Cast = (ProtoGen.C)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Prefix) |
									(LabelType == ProtoGen.ProtoStructType.Binding) |
									(LabelType == ProtoGen.ProtoStructType.Stubs) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Prefix Binding Stubs ]");
								}
							}
                        break;


                    case StateCode.CS_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.CS__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.CS__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							ProtoGen.CS Current_Cast = (ProtoGen.CS)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Binding) |
									(LabelType == ProtoGen.ProtoStructType.Stubs) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Binding Stubs ]");
								}
							}
                        break;


                    case StateCode.Stubs_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Prefix_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            ProtoGen.Prefix Current_Cast = (ProtoGen.Prefix)Current;
                            Current_Cast.Tag = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Prefix__Tag;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Prefix__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Binding_Start:
                        if (Token == TokenType.STRING) {
                            ProtoGen.Binding Current_Cast = (ProtoGen.Binding)Current;
                            Current_Cast.Mapping = Text;
                            State = StateCode.Binding__Mapping;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Binding__Mapping:
                        if (Token == TokenType.LABEL) {
							ProtoGen.Binding Current_Cast = (ProtoGen.Binding)Current;
                            ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == ProtoGen.ProtoStructType.Boolean) |
									(LabelType == ProtoGen.ProtoStructType.Integer) |
									(LabelType == ProtoGen.ProtoStructType.Binary) |
									(LabelType == ProtoGen.ProtoStructType.Float) |
									(LabelType == ProtoGen.ProtoStructType.Label) |
									(LabelType == ProtoGen.ProtoStructType.Name) |
									(LabelType == ProtoGen.ProtoStructType.String) |
									(LabelType == ProtoGen.ProtoStructType.URI) |
									(LabelType == ProtoGen.ProtoStructType.DateTime) ) {
                                State = StateCode.Binding__Type;
                                Current_Cast.Type = New_Choice(Text);
                                }
                            else {
                               throw new System.Exception("Parser Error Expected [Boolean Integer Binary Float Label Name String URI DateTime ]");
                                }
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Boolean Integer Binary Float Label Name String URI DateTime ]");

                    case StateCode.Binding__Type:
                        Pop ();
                        Represent = true; 
                        break;

                    default:
                        throw new System.Exception("Unreachable code reached");
                    }
                }
            }
        }
	}


