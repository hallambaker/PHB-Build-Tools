
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;




//
// Namespace Goedel.Tool.ProtoGen
// Class ProtoStruct
//


// Types
//   TopTypeType
//       Protocol
//       Mapping
//   TypeType
//       Section
//       Service
//       Transaction
//       Message
//       Structure
//       Description
//       Using
//       Extern
//       Enumeration
//       Success
//       Warning
//       Error
//       Inherits
//       Status
//       Abstract
//       External
//       Boolean
//       Integer
//       Binary
//       Float
//       Label
//       Name
//       String
//       URI
//       DateTime
//       Struct
//       TStruct
//       Enum
//       Authentication
//       Format
//       Decimal
//       Funct
//       Param
//       Select
//       ABNF
//       Tag
//       Required
//       Multiple
//       Default
//       LengthBits
//       LengthFixed
//       Quoted
//       Constraint
//       TaggedType
//       Tagged
//       Require
//       Brief
//       Command
//       OptionSet
//       Enumerate
//       Parameter
//       Option
//       Include
//       Case
//       Maximum
//       Minimum
//       EnumerationEntry
//       Root
//       Language
//       C
//       CS
//       Binding
//       Stubs
//   IdType
//       Top
//       MessageT
//       ClassT
//       StructureT
//       ConstraintType
//       EnumerationType
//       EnumerationLabel
//       ClassType
//       CommandType
//       TypeType
//       OptionSetType
//   NamespaceType
//       Goedel.Tool.ProtoGen
//   ClassType
//       ProtoStruct
//   NameType
//       Namespace
//       Id
//       Prefix
//       Entries
//       Level
//       Title
//       Discovery
//       WellKnown
//       Request
//       Response
//       Class
//       Mechanism
//       Text1
//       Ref
//       Text
//       Options
//       Outer
//       Inner
//       Type
//       Code
//       Value
//       Bits
//       Bytes
//       MappingType
//       For
//   TokenType
//       NamespaceT
//       PrefixT
//       NamespaceType
//       AuthenticationT
//       Variable
//       FormatT
//       PType
//       StatusT
//       CaseType

#pragma warning disable IDE0022
namespace Goedel.Tool.ProtoGen {


    public enum ProtoStructType {
        _Top,

        Protocol,
        Using,
        Extern,
        Section,
        Service,
        Transaction,
        Message,
        Authentication,
        Structure,
        Description,
        ABNF,
        Abstract,
        Inherits,
        Request,
        Response,
        External,
        Tag,
        Boolean,
        Integer,
        Decimal,
        Float,
        Binary,
        Label,
        Name,
        String,
        Constraint,
        URI,
        DateTime,
        Param,
        Funct,
        TStruct,
        Struct,
        Enum,
        Select,
        TaggedType,
        Format,
        Tagged,
        Required,
        Multiple,
        Quoted,
        Require,
        Class,
        Command,
        Brief,
        Parameter,
        Status,
        Success,
        Error,
        Warning,
        Option,
        Include,
        OptionSet,
        Enumerate,
        Case,
        Type,
        Default,
        Maximum,
        Minimum,
        LengthBits,
        LengthFixed,
        Enumeration,
        EnumerationEntry,
        Mapping,
        Root,
        Language,
        C,
        CS,
        Stubs,
        Prefix,
        Binding,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public ProtoStructType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);

		public virtual void Init (_Choice Parent) {
			}

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice Parent) {
			Init (Parent);
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Protocol : _Choice {
        public TOKEN<_Choice>			Namespace;
        public ID<_Choice>				Id; 
        public TOKEN<_Choice>			Prefix;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Protocol;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Protocol");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
	        Output.WriteId ("Prefix", Prefix.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Protocol");
				}			
			}
		}

    public partial class Using : _Choice {
        public TOKEN<_Choice>			Id;

        public override ProtoStructType _Tag () =>ProtoStructType.Using;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Using");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Using");
				}			
			}
		}

    public partial class Extern : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Extern;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Extern");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Extern");
				}			
			}
		}

    public partial class Section : _Choice {
		public int						Level;
		public string					Title;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Section;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Section");
				}

			Output.WriteAttribute ("Level", Level);
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Section");
				}			
			}
		}

    public partial class Service : _Choice {
        public ID<_Choice>				Id; 
		public string					Discovery;
		public string					WellKnown;
        public REF<_Choice>				Request;
        public REF<_Choice>				Response;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Service;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Service");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Discovery", Discovery);
			Output.WriteAttribute ("WellKnown", WellKnown);
	        Output.WriteId ("Request", Request.ToString());
	        Output.WriteId ("Response", Response.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Service");
				}			
			}
		}

    public partial class Transaction : _Choice {
        public REF<_Choice>				Class;
        public ID<_Choice>				Id; 
        public REF<_Choice>				Request;
        public REF<_Choice>				Response;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Transaction;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Transaction");
				}

	        Output.WriteId ("Class", Class.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
	        Output.WriteId ("Request", Request.ToString());
	        Output.WriteId ("Response", Response.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Transaction");
				}			
			}
		}

    public partial class Message : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Message;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Message");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Message");
				}			
			}
		}

    public partial class Authentication : _Choice {
        public TOKEN<_Choice>			Mechanism;

        public override ProtoStructType _Tag () =>ProtoStructType.Authentication;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Authentication");
				}

	        Output.WriteId ("Mechanism", Mechanism.ToString());
			if (tag) {
				Output.EndElement ("Authentication");
				}			
			}
		}

    public partial class Structure : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Structure;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Structure");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Structure");
				}			
			}
		}

    public partial class Description : _Choice {
		public List <System.String>			Text1 = new List <System.String> (); 

        public override ProtoStructType _Tag () =>ProtoStructType.Description;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Description");
				}

			foreach (string _s in Text1) {
				Output.WriteAttribute ("Text1",_s);
				}
			if (tag) {
				Output.EndElement ("Description");
				}			
			}
		}

    public partial class ABNF : _Choice {
		public List <System.String>			Text1 = new List <System.String> (); 

        public override ProtoStructType _Tag () =>ProtoStructType.ABNF;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("ABNF");
				}

			foreach (string _s in Text1) {
				Output.WriteAttribute ("Text1",_s);
				}
			if (tag) {
				Output.EndElement ("ABNF");
				}			
			}
		}

    public partial class Abstract : _Choice {

        public override ProtoStructType _Tag () =>ProtoStructType.Abstract;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Abstract");
				}

			if (tag) {
				Output.EndElement ("Abstract");
				}			
			}
		}

    public partial class Inherits : _Choice {
        public REF<_Choice>				Ref;

        public override ProtoStructType _Tag () =>ProtoStructType.Inherits;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Inherits");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("Inherits");
				}			
			}
		}

    public partial class Request : _Choice {
        public REF<_Choice>				Ref;

        public override ProtoStructType _Tag () =>ProtoStructType.Request;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Request");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("Request");
				}			
			}
		}

    public partial class Response : _Choice {
        public REF<_Choice>				Ref;

        public override ProtoStructType _Tag () =>ProtoStructType.Response;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Response");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("Response");
				}			
			}
		}

    public partial class External : _Choice {
        public TOKEN<_Choice>			Ref;

        public override ProtoStructType _Tag () =>ProtoStructType.External;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("External");
				}

	        Output.WriteId ("Ref", Ref.ToString());
			if (tag) {
				Output.EndElement ("External");
				}			
			}
		}

    public partial class Tag : _Choice {
		public string					Text;

        public override ProtoStructType _Tag () =>ProtoStructType.Tag;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Tag");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Tag");
				}			
			}
		}

    public partial class Boolean : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Boolean;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Boolean");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Boolean");
				}			
			}
		}

    public partial class Integer : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Integer;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Integer");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Integer");
				}			
			}
		}

    public partial class Decimal : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Decimal;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Decimal");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Decimal");
				}			
			}
		}

    public partial class Float : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Float;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Float");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Float");
				}			
			}
		}

    public partial class Binary : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Binary;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binary");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Binary");
				}			
			}
		}

    public partial class Label : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Label;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Label");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Label");
				}			
			}
		}

    public partial class Name : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Name;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Name");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Name");
				}			
			}
		}

    public partial class String : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.String;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class Constraint : _Choice {
        public REF<_Choice>				Id;

        public override ProtoStructType _Tag () =>ProtoStructType.Constraint;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Constraint");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Constraint");
				}			
			}
		}

    public partial class URI : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.URI;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("URI");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("URI");
				}			
			}
		}

    public partial class DateTime : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.DateTime;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("DateTime");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("DateTime");
				}			
			}
		}

    public partial class Param : _Choice {
        public TOKEN<_Choice>			Id;

        public override ProtoStructType _Tag () =>ProtoStructType.Param;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Param");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Param");
				}			
			}
		}

    public partial class Funct : _Choice {
        public REF<_Choice>				Outer;
        public REF<_Choice>				Inner;

        public override ProtoStructType _Tag () =>ProtoStructType.Funct;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Funct");
				}

	        Output.WriteId ("Outer", Outer.ToString());
	        Output.WriteId ("Inner", Inner.ToString());
			if (tag) {
				Output.EndElement ("Funct");
				}			
			}
		}

    public partial class TStruct : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.TStruct;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("TStruct");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("TStruct");
				}			
			}
		}

    public partial class Struct : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Struct;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Struct");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Struct");
				}			
			}
		}

    public partial class Enum : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Enum;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enum");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enum");
				}			
			}
		}

    public partial class Select : _Choice {
        public TOKEN<_Choice>			Tag;
        public TOKEN<_Choice>			Id;
        public List <TaggedType>           Entries = new List<TaggedType> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Select;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Select");
				}

	        Output.WriteId ("Tag", Tag.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (TaggedType _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Select");
				}			
			}
		}

    public partial class TaggedType : _Choice {
        public REF<_Choice>				Tag;
        public REF<_Choice>				Type;

        public override ProtoStructType _Tag () =>ProtoStructType.TaggedType;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("TaggedType");
				}

	        Output.WriteId ("Tag", Tag.ToString());
	        Output.WriteId ("Type", Type.ToString());
			if (tag) {
				Output.EndElement ("TaggedType");
				}			
			}
		}

    public partial class Format : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Format;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Format");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Format");
				}			
			}
		}

    public partial class Tagged : _Choice {
        public REF<_Choice>				Type;
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Tagged;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Tagged");
				}

	        Output.WriteId ("Type", Type.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Tagged");
				}			
			}
		}

    public partial class Required : _Choice {

        public override ProtoStructType _Tag () =>ProtoStructType.Required;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Required");
				}

			if (tag) {
				Output.EndElement ("Required");
				}			
			}
		}

    public partial class Multiple : _Choice {

        public override ProtoStructType _Tag () =>ProtoStructType.Multiple;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Multiple");
				}

			if (tag) {
				Output.EndElement ("Multiple");
				}			
			}
		}

    public partial class Quoted : _Choice {

        public override ProtoStructType _Tag () =>ProtoStructType.Quoted;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Quoted");
				}

			if (tag) {
				Output.EndElement ("Quoted");
				}			
			}
		}

    public partial class Require : _Choice {
        public REF<_Choice>				Id;

        public override ProtoStructType _Tag () =>ProtoStructType.Require;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Require");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Require");
				}			
			}
		}

    public partial class Class : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Class;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Class");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Class");
				}			
			}
		}

    public partial class Command : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Command;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Command");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Command");
				}			
			}
		}

    public partial class Brief : _Choice {
		public string					Text;

        public override ProtoStructType _Tag () =>ProtoStructType.Brief;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Brief");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Brief");
				}			
			}
		}

    public partial class Parameter : _Choice {
        public TOKEN<_Choice>			Name;
		public string					Text;
        public REF<_Choice>				Type;

        public override ProtoStructType _Tag () =>ProtoStructType.Parameter;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Parameter");
				}

	        Output.WriteId ("Name", Name.ToString());
			Output.WriteAttribute ("Text", Text);
	        Output.WriteId ("Type", Type.ToString());
			if (tag) {
				Output.EndElement ("Parameter");
				}			
			}
		}

    public partial class Status : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Status;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Status");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Status");
				}			
			}
		}

    public partial class Success : _Choice {
        public TOKEN<_Choice>			Id;
		public int						Code;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Success;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Success");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Code", Code);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Success");
				}			
			}
		}

    public partial class Error : _Choice {
        public TOKEN<_Choice>			Id;
		public int						Code;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Error;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Error");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Code", Code);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Error");
				}			
			}
		}

    public partial class Warning : _Choice {
        public TOKEN<_Choice>			Id;
		public int						Code;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Warning;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Warning");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Code", Code);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Warning");
				}			
			}
		}

    public partial class Option : _Choice {
        public TOKEN<_Choice>			Name;
		public string					Command;
        public REF<_Choice>				Type;

        public override ProtoStructType _Tag () =>ProtoStructType.Option;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Option");
				}

	        Output.WriteId ("Name", Name.ToString());
			Output.WriteAttribute ("Command", Command);
	        Output.WriteId ("Type", Type.ToString());
			if (tag) {
				Output.EndElement ("Option");
				}			
			}
		}

    public partial class Include : _Choice {
        public REF<_Choice>				Id;

        public override ProtoStructType _Tag () =>ProtoStructType.Include;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Include");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Include");
				}			
			}
		}

    public partial class OptionSet : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Options = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.OptionSet;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("OptionSet");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("OptionSet");
				}			
			}
		}

    public partial class Enumerate : _Choice {
        public ID<_Choice>				Id; 
        public List <Case>           Entries = new List<Case> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Enumerate;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enumerate");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (Case _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enumerate");
				}			
			}
		}

    public partial class Case : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;

        public override ProtoStructType _Tag () =>ProtoStructType.Case;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Case");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			if (tag) {
				Output.EndElement ("Case");
				}			
			}
		}

    public partial class Type : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Text;

        public override ProtoStructType _Tag () =>ProtoStructType.Type;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Type");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Type");
				}			
			}
		}

    public partial class Default : _Choice {
		public string					Value;

        public override ProtoStructType _Tag () =>ProtoStructType.Default;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Default");
				}

			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Default");
				}			
			}
		}

    public partial class Maximum : _Choice {
		public int						Value;

        public override ProtoStructType _Tag () =>ProtoStructType.Maximum;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Maximum");
				}

			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Maximum");
				}			
			}
		}

    public partial class Minimum : _Choice {
		public int						Value;

        public override ProtoStructType _Tag () =>ProtoStructType.Minimum;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Minimum");
				}

			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Minimum");
				}			
			}
		}

    public partial class LengthBits : _Choice {
		public int						Bits;

        public override ProtoStructType _Tag () =>ProtoStructType.LengthBits;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("LengthBits");
				}

			Output.WriteAttribute ("Bits", Bits);
			if (tag) {
				Output.EndElement ("LengthBits");
				}			
			}
		}

    public partial class LengthFixed : _Choice {
		public int						Bytes;

        public override ProtoStructType _Tag () =>ProtoStructType.LengthFixed;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("LengthFixed");
				}

			Output.WriteAttribute ("Bytes", Bytes);
			if (tag) {
				Output.EndElement ("LengthFixed");
				}			
			}
		}

    public partial class Enumeration : _Choice {
        public ID<_Choice>				Name; 
		public int						Maximum;
        public List <EnumerationEntry>           Entries = new List<EnumerationEntry> ();

        public override ProtoStructType _Tag () =>ProtoStructType.Enumeration;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enumeration");
				}

	        Output.WriteId ("Name", Name.ToString()); 
			Output.WriteAttribute ("Maximum", Maximum);
			Output.StartList ("");
			foreach (EnumerationEntry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enumeration");
				}			
			}
		}

    public partial class EnumerationEntry : _Choice {
        public ID<_Choice>				Id; 
		public int						Code;

        public override ProtoStructType _Tag () =>ProtoStructType.EnumerationEntry;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("EnumerationEntry");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Code", Code);
			if (tag) {
				Output.EndElement ("EnumerationEntry");
				}			
			}
		}

    public partial class Mapping : _Choice {
        public Name					Id;
        public _Choice					MappingType;

        public override ProtoStructType _Tag () =>ProtoStructType.Mapping;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			Id._InitChildren (this);
			MappingType._InitChildren (this);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Mapping");
				}

	        MappingType.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Mapping");
				}			
			}
		}

    public partial class Root : _Choice {
        public TOKEN<_Choice>			Namespace;

        public override ProtoStructType _Tag () =>ProtoStructType.Root;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Root");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
			if (tag) {
				Output.EndElement ("Root");
				}			
			}
		}

    public partial class Language : _Choice {
        public _Choice					For;

        public override ProtoStructType _Tag () =>ProtoStructType.Language;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			For._InitChildren (this);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Language");
				}

	        For.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Language");
				}			
			}
		}

    public partial class C : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.C;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("C");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("C");
				}			
			}
		}

    public partial class CS : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ProtoStructType _Tag () =>ProtoStructType.CS;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("CS");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("CS");
				}			
			}
		}

    public partial class Stubs : _Choice {

        public override ProtoStructType _Tag () =>ProtoStructType.Stubs;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Stubs");
				}

			if (tag) {
				Output.EndElement ("Stubs");
				}			
			}
		}

    public partial class Prefix : _Choice {
        public TOKEN<_Choice>			Tag;

        public override ProtoStructType _Tag () =>ProtoStructType.Prefix;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Prefix");
				}

	        Output.WriteId ("Tag", Tag.ToString());
			if (tag) {
				Output.EndElement ("Prefix");
				}			
			}
		}

    public partial class Binding : _Choice {
		public string					Mapping;
        public _Choice					Type;

        public override ProtoStructType _Tag () =>ProtoStructType.Binding;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			Type._InitChildren (this);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binding");
				}

			Output.WriteAttribute ("Mapping", Mapping);
	        Type.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Binding");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() =>  Label = null;

        public override ProtoStructType _Tag () => ProtoStructType._Label;

		public override void Serialize (StructureWriter Output, bool tag) =>Output.WriteId ("ID", Label.ToString());
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Protocol_Start,
		Protocol__Namespace,				
		Protocol__Id,				
		Protocol__Prefix,				
		Protocol__Entries,				
		Using_Start,
		Using__Id,				
		Extern_Start,
		Extern__Id,				
		Extern__Entries,				
		Section_Start,
		Section__Level,				
		Section__Title,				
		Section__Entries,				
		Service_Start,
		Service__Id,				
		Service__Discovery,				
		Service__WellKnown,				
		Service__Request,				
		Service__Response,				
		Service__Entries,				
		Transaction_Start,
		Transaction__Class,				
		Transaction__Id,				
		Transaction__Request,				
		Transaction__Response,				
		Transaction__Entries,				
		Message_Start,
		Message__Id,				
		Message__Entries,				
		Authentication_Start,
		Authentication__Mechanism,				
		Structure_Start,
		Structure__Id,				
		Structure__Entries,				
		Description_Start,
		Description__Text1,				
		ABNF_Start,
		ABNF__Text1,				
		Abstract_Start,
		Inherits_Start,
		Inherits__Ref,				
		Request_Start,
		Request__Ref,				
		Response_Start,
		Response__Ref,				
		External_Start,
		External__Ref,				
		Tag_Start,
		Tag__Text,				
		Boolean_Start,
		Boolean__Id,				
		Boolean__Options,				
		Integer_Start,
		Integer__Id,				
		Integer__Options,				
		Decimal_Start,
		Decimal__Id,				
		Decimal__Options,				
		Float_Start,
		Float__Id,				
		Float__Options,				
		Binary_Start,
		Binary__Id,				
		Binary__Options,				
		Label_Start,
		Label__Id,				
		Label__Options,				
		Name_Start,
		Name__Id,				
		Name__Options,				
		String_Start,
		String__Id,				
		String__Options,				
		Constraint_Start,
		Constraint__Id,				
		URI_Start,
		URI__Id,				
		URI__Options,				
		DateTime_Start,
		DateTime__Id,				
		DateTime__Options,				
		Param_Start,
		Param__Id,				
		Funct_Start,
		Funct__Outer,				
		Funct__Inner,				
		TStruct_Start,
		TStruct__Type,				
		TStruct__Id,				
		TStruct__Options,				
		Struct_Start,
		Struct__Type,				
		Struct__Id,				
		Struct__Options,				
		Enum_Start,
		Enum__Type,				
		Enum__Id,				
		Enum__Options,				
		Select_Start,
		Select__Tag,				
		Select__Id,				
		Select__Entries,				
		TaggedType_Start,
		TaggedType__Tag,				
		TaggedType__Type,				
		Format_Start,
		Format__Id,				
		Format__Options,				
		Tagged_Start,
		Tagged__Type,				
		Tagged__Id,				
		Tagged__Options,				
		Required_Start,
		Multiple_Start,
		Quoted_Start,
		Require_Start,
		Require__Id,				
		Class_Start,
		Class__Id,				
		Class__Entries,				
		Command_Start,
		Command__Id,				
		Command__Tag,				
		Command__Entries,				
		Brief_Start,
		Brief__Text,				
		Parameter_Start,
		Parameter__Name,				
		Parameter__Text,				
		Parameter__Type,				
		Status_Start,
		Status__Id,				
		Status__Entries,				
		Success_Start,
		Success__Id,				
		Success__Code,				
		Success__Entries,				
		Error_Start,
		Error__Id,				
		Error__Code,				
		Error__Entries,				
		Warning_Start,
		Warning__Id,				
		Warning__Code,				
		Warning__Entries,				
		Option_Start,
		Option__Name,				
		Option__Command,				
		Option__Type,				
		Include_Start,
		Include__Id,				
		OptionSet_Start,
		OptionSet__Id,				
		OptionSet__Options,				
		Enumerate_Start,
		Enumerate__Id,				
		Enumerate__Entries,				
		Case_Start,
		Case__Id,				
		Case__Tag,				
		Type_Start,
		Type__Id,				
		Type__Text,				
		Default_Start,
		Default__Value,				
		Maximum_Start,
		Maximum__Value,				
		Minimum_Start,
		Minimum__Value,				
		LengthBits_Start,
		LengthBits__Bits,				
		LengthFixed_Start,
		LengthFixed__Bytes,				
		Enumeration_Start,
		Enumeration__Name,				
		Enumeration__Maximum,				
		Enumeration__Entries,				
		EnumerationEntry_Start,
		EnumerationEntry__Id,				
		EnumerationEntry__Code,				
		Mapping_Start,
		Mapping__Id,				
		Mapping__MappingType,				
		Root_Start,
		Root__Namespace,				
		Language_Start,
		Language__For,				
		C_Start,
		C__Entries,				
		CS_Start,
		CS__Entries,				
		Stubs_Start,
		Prefix_Start,
		Prefix__Tag,				
		Binding_Start,
		Binding__Mapping,				
		Binding__Type,				
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Tool.ProtoGen._Choice     Token;
        }

    public partial class ProtoStruct : Goedel.Registry.Parser{
        public List <Goedel.Tool.ProtoGen._Choice>        Top;
        public Registry	<Goedel.Tool.ProtoGen._Choice>	Registry;

        public bool StartOfEntry {get;  private set;}

        StateCode								State;
        Goedel.Tool.ProtoGen._Choice				Current;
        List <_StackItem>						Stack;


        public static ProtoStruct Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new ProtoStruct() {
				Options = Options
				};

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
				Entry._InitChildren (null);
				}
			}

        public ProtoStruct() {
            Top = new List<Goedel.Tool.ProtoGen._Choice> () ;
            Registry = new Registry <Goedel.Tool.ProtoGen._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            StartOfEntry = true;

			TYPE__Top = Registry.TYPE ("Top"); 
			TYPE__MessageT = Registry.TYPE ("MessageT"); 
			TYPE__ClassT = Registry.TYPE ("ClassT"); 
			TYPE__StructureT = Registry.TYPE ("StructureT"); 
			TYPE__ConstraintType = Registry.TYPE ("ConstraintType"); 
			TYPE__EnumerationType = Registry.TYPE ("EnumerationType"); 
			TYPE__EnumerationLabel = Registry.TYPE ("EnumerationLabel"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 
			TYPE__CommandType = Registry.TYPE ("CommandType"); 
			TYPE__TypeType = Registry.TYPE ("TypeType"); 
			TYPE__OptionSetType = Registry.TYPE ("OptionSetType"); 
			TYPE__NamespaceT = Registry.TYPE ("NamespaceT"); 
			TYPE__PrefixT = Registry.TYPE ("PrefixT"); 
			TYPE__NamespaceType = Registry.TYPE ("NamespaceType"); 
			TYPE__AuthenticationT = Registry.TYPE ("AuthenticationT"); 
			TYPE__Variable = Registry.TYPE ("Variable"); 
			TYPE__FormatT = Registry.TYPE ("FormatT"); 
			TYPE__PType = Registry.TYPE ("PType"); 
			TYPE__StatusT = Registry.TYPE ("StatusT"); 
			TYPE__CaseType = Registry.TYPE ("CaseType"); 



            }



        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__Top ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__MessageT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__ClassT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__StructureT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__ConstraintType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__EnumerationType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__EnumerationLabel ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__ClassType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__CommandType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__TypeType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__OptionSetType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__NamespaceT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__PrefixT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__NamespaceType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__AuthenticationT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__Variable ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__FormatT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__PType ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__StatusT ;
        public TYPE<Goedel.Tool.ProtoGen._Choice> TYPE__CaseType ;

        private Goedel.Tool.ProtoGen._Choice New_Choice(string Label) {
            switch (Label) {

                case "Protocol": return NewProtocol();
                case "Using": return NewUsing();
                case "Extern": return NewExtern();
                case "Section": return NewSection();
                case "Service": return NewService();
                case "Transaction": return NewTransaction();
                case "Message": return NewMessage();
                case "Authentication": return NewAuthentication();
                case "Structure": return NewStructure();
                case "Description": return NewDescription();
                case "ABNF": return NewABNF();
                case "Abstract": return NewAbstract();
                case "Inherits": return NewInherits();
                case "Request": return NewRequest();
                case "Response": return NewResponse();
                case "External": return NewExternal();
                case "Tag": return NewTag();
                case "Boolean": return NewBoolean();
                case "Integer": return NewInteger();
                case "Decimal": return NewDecimal();
                case "Float": return NewFloat();
                case "Binary": return NewBinary();
                case "Label": return NewLabel();
                case "Name": return NewName();
                case "String": return NewString();
                case "Constraint": return NewConstraint();
                case "URI": return NewURI();
                case "DateTime": return NewDateTime();
                case "Param": return NewParam();
                case "Funct": return NewFunct();
                case "TStruct": return NewTStruct();
                case "Struct": return NewStruct();
                case "Enum": return NewEnum();
                case "Select": return NewSelect();
                case "TaggedType": return NewTaggedType();
                case "Format": return NewFormat();
                case "Tagged": return NewTagged();
                case "Required": return NewRequired();
                case "Multiple": return NewMultiple();
                case "Quoted": return NewQuoted();
                case "Require": return NewRequire();
                case "Class": return NewClass();
                case "Command": return NewCommand();
                case "Brief": return NewBrief();
                case "Parameter": return NewParameter();
                case "Status": return NewStatus();
                case "Success": return NewSuccess();
                case "Error": return NewError();
                case "Warning": return NewWarning();
                case "Option": return NewOption();
                case "Include": return NewInclude();
                case "OptionSet": return NewOptionSet();
                case "Enumerate": return NewEnumerate();
                case "Case": return NewCase();
                case "Type": return NewType();
                case "Default": return NewDefault();
                case "Maximum": return NewMaximum();
                case "Minimum": return NewMinimum();
                case "LengthBits": return NewLengthBits();
                case "LengthFixed": return NewLengthFixed();
                case "Enumeration": return NewEnumeration();
                case "EnumerationEntry": return NewEnumerationEntry();
                case "Mapping": return NewMapping();
                case "Root": return NewRoot();
                case "Language": return NewLanguage();
                case "C": return NewC();
                case "CS": return NewCS();
                case "Stubs": return NewStubs();
                case "Prefix": return NewPrefix();
                case "Binding": return NewBinding();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Tool.ProtoGen.Protocol NewProtocol() {
            Goedel.Tool.ProtoGen.Protocol result = new Goedel.Tool.ProtoGen.Protocol();
            Push (result);
            State = StateCode.Protocol_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Using NewUsing() {
            Goedel.Tool.ProtoGen.Using result = new Goedel.Tool.ProtoGen.Using();
            Push (result);
            State = StateCode.Using_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Extern NewExtern() {
            Goedel.Tool.ProtoGen.Extern result = new Goedel.Tool.ProtoGen.Extern();
            Push (result);
            State = StateCode.Extern_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Section NewSection() {
            Goedel.Tool.ProtoGen.Section result = new Goedel.Tool.ProtoGen.Section();
            Push (result);
            State = StateCode.Section_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Service NewService() {
            Goedel.Tool.ProtoGen.Service result = new Goedel.Tool.ProtoGen.Service();
            Push (result);
            State = StateCode.Service_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Transaction NewTransaction() {
            Goedel.Tool.ProtoGen.Transaction result = new Goedel.Tool.ProtoGen.Transaction();
            Push (result);
            State = StateCode.Transaction_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Message NewMessage() {
            Goedel.Tool.ProtoGen.Message result = new Goedel.Tool.ProtoGen.Message();
            Push (result);
            State = StateCode.Message_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Authentication NewAuthentication() {
            Goedel.Tool.ProtoGen.Authentication result = new Goedel.Tool.ProtoGen.Authentication();
            Push (result);
            State = StateCode.Authentication_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Structure NewStructure() {
            Goedel.Tool.ProtoGen.Structure result = new Goedel.Tool.ProtoGen.Structure();
            Push (result);
            State = StateCode.Structure_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Description NewDescription() {
            Goedel.Tool.ProtoGen.Description result = new Goedel.Tool.ProtoGen.Description();
            Push (result);
            State = StateCode.Description_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.ABNF NewABNF() {
            Goedel.Tool.ProtoGen.ABNF result = new Goedel.Tool.ProtoGen.ABNF();
            Push (result);
            State = StateCode.ABNF_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Abstract NewAbstract() {
            Goedel.Tool.ProtoGen.Abstract result = new Goedel.Tool.ProtoGen.Abstract();
            Push (result);
            State = StateCode.Abstract_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Inherits NewInherits() {
            Goedel.Tool.ProtoGen.Inherits result = new Goedel.Tool.ProtoGen.Inherits();
            Push (result);
            State = StateCode.Inherits_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Request NewRequest() {
            Goedel.Tool.ProtoGen.Request result = new Goedel.Tool.ProtoGen.Request();
            Push (result);
            State = StateCode.Request_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Response NewResponse() {
            Goedel.Tool.ProtoGen.Response result = new Goedel.Tool.ProtoGen.Response();
            Push (result);
            State = StateCode.Response_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.External NewExternal() {
            Goedel.Tool.ProtoGen.External result = new Goedel.Tool.ProtoGen.External();
            Push (result);
            State = StateCode.External_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Tag NewTag() {
            Goedel.Tool.ProtoGen.Tag result = new Goedel.Tool.ProtoGen.Tag();
            Push (result);
            State = StateCode.Tag_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Boolean NewBoolean() {
            Goedel.Tool.ProtoGen.Boolean result = new Goedel.Tool.ProtoGen.Boolean();
            Push (result);
            State = StateCode.Boolean_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Integer NewInteger() {
            Goedel.Tool.ProtoGen.Integer result = new Goedel.Tool.ProtoGen.Integer();
            Push (result);
            State = StateCode.Integer_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Decimal NewDecimal() {
            Goedel.Tool.ProtoGen.Decimal result = new Goedel.Tool.ProtoGen.Decimal();
            Push (result);
            State = StateCode.Decimal_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Float NewFloat() {
            Goedel.Tool.ProtoGen.Float result = new Goedel.Tool.ProtoGen.Float();
            Push (result);
            State = StateCode.Float_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Binary NewBinary() {
            Goedel.Tool.ProtoGen.Binary result = new Goedel.Tool.ProtoGen.Binary();
            Push (result);
            State = StateCode.Binary_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Label NewLabel() {
            Goedel.Tool.ProtoGen.Label result = new Goedel.Tool.ProtoGen.Label();
            Push (result);
            State = StateCode.Label_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Name NewName() {
            Goedel.Tool.ProtoGen.Name result = new Goedel.Tool.ProtoGen.Name();
            Push (result);
            State = StateCode.Name_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.String NewString() {
            Goedel.Tool.ProtoGen.String result = new Goedel.Tool.ProtoGen.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Constraint NewConstraint() {
            Goedel.Tool.ProtoGen.Constraint result = new Goedel.Tool.ProtoGen.Constraint();
            Push (result);
            State = StateCode.Constraint_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.URI NewURI() {
            Goedel.Tool.ProtoGen.URI result = new Goedel.Tool.ProtoGen.URI();
            Push (result);
            State = StateCode.URI_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.DateTime NewDateTime() {
            Goedel.Tool.ProtoGen.DateTime result = new Goedel.Tool.ProtoGen.DateTime();
            Push (result);
            State = StateCode.DateTime_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Param NewParam() {
            Goedel.Tool.ProtoGen.Param result = new Goedel.Tool.ProtoGen.Param();
            Push (result);
            State = StateCode.Param_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Funct NewFunct() {
            Goedel.Tool.ProtoGen.Funct result = new Goedel.Tool.ProtoGen.Funct();
            Push (result);
            State = StateCode.Funct_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.TStruct NewTStruct() {
            Goedel.Tool.ProtoGen.TStruct result = new Goedel.Tool.ProtoGen.TStruct();
            Push (result);
            State = StateCode.TStruct_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Struct NewStruct() {
            Goedel.Tool.ProtoGen.Struct result = new Goedel.Tool.ProtoGen.Struct();
            Push (result);
            State = StateCode.Struct_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Enum NewEnum() {
            Goedel.Tool.ProtoGen.Enum result = new Goedel.Tool.ProtoGen.Enum();
            Push (result);
            State = StateCode.Enum_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Select NewSelect() {
            Goedel.Tool.ProtoGen.Select result = new Goedel.Tool.ProtoGen.Select();
            Push (result);
            State = StateCode.Select_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.TaggedType NewTaggedType() {
            Goedel.Tool.ProtoGen.TaggedType result = new Goedel.Tool.ProtoGen.TaggedType();
            Push (result);
            State = StateCode.TaggedType_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Format NewFormat() {
            Goedel.Tool.ProtoGen.Format result = new Goedel.Tool.ProtoGen.Format();
            Push (result);
            State = StateCode.Format_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Tagged NewTagged() {
            Goedel.Tool.ProtoGen.Tagged result = new Goedel.Tool.ProtoGen.Tagged();
            Push (result);
            State = StateCode.Tagged_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Required NewRequired() {
            Goedel.Tool.ProtoGen.Required result = new Goedel.Tool.ProtoGen.Required();
            Push (result);
            State = StateCode.Required_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Multiple NewMultiple() {
            Goedel.Tool.ProtoGen.Multiple result = new Goedel.Tool.ProtoGen.Multiple();
            Push (result);
            State = StateCode.Multiple_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Quoted NewQuoted() {
            Goedel.Tool.ProtoGen.Quoted result = new Goedel.Tool.ProtoGen.Quoted();
            Push (result);
            State = StateCode.Quoted_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Require NewRequire() {
            Goedel.Tool.ProtoGen.Require result = new Goedel.Tool.ProtoGen.Require();
            Push (result);
            State = StateCode.Require_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Class NewClass() {
            Goedel.Tool.ProtoGen.Class result = new Goedel.Tool.ProtoGen.Class();
            Push (result);
            State = StateCode.Class_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Command NewCommand() {
            Goedel.Tool.ProtoGen.Command result = new Goedel.Tool.ProtoGen.Command();
            Push (result);
            State = StateCode.Command_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Brief NewBrief() {
            Goedel.Tool.ProtoGen.Brief result = new Goedel.Tool.ProtoGen.Brief();
            Push (result);
            State = StateCode.Brief_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Parameter NewParameter() {
            Goedel.Tool.ProtoGen.Parameter result = new Goedel.Tool.ProtoGen.Parameter();
            Push (result);
            State = StateCode.Parameter_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Status NewStatus() {
            Goedel.Tool.ProtoGen.Status result = new Goedel.Tool.ProtoGen.Status();
            Push (result);
            State = StateCode.Status_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Success NewSuccess() {
            Goedel.Tool.ProtoGen.Success result = new Goedel.Tool.ProtoGen.Success();
            Push (result);
            State = StateCode.Success_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Error NewError() {
            Goedel.Tool.ProtoGen.Error result = new Goedel.Tool.ProtoGen.Error();
            Push (result);
            State = StateCode.Error_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Warning NewWarning() {
            Goedel.Tool.ProtoGen.Warning result = new Goedel.Tool.ProtoGen.Warning();
            Push (result);
            State = StateCode.Warning_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Option NewOption() {
            Goedel.Tool.ProtoGen.Option result = new Goedel.Tool.ProtoGen.Option();
            Push (result);
            State = StateCode.Option_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Include NewInclude() {
            Goedel.Tool.ProtoGen.Include result = new Goedel.Tool.ProtoGen.Include();
            Push (result);
            State = StateCode.Include_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.OptionSet NewOptionSet() {
            Goedel.Tool.ProtoGen.OptionSet result = new Goedel.Tool.ProtoGen.OptionSet();
            Push (result);
            State = StateCode.OptionSet_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Enumerate NewEnumerate() {
            Goedel.Tool.ProtoGen.Enumerate result = new Goedel.Tool.ProtoGen.Enumerate();
            Push (result);
            State = StateCode.Enumerate_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Case NewCase() {
            Goedel.Tool.ProtoGen.Case result = new Goedel.Tool.ProtoGen.Case();
            Push (result);
            State = StateCode.Case_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Type NewType() {
            Goedel.Tool.ProtoGen.Type result = new Goedel.Tool.ProtoGen.Type();
            Push (result);
            State = StateCode.Type_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Default NewDefault() {
            Goedel.Tool.ProtoGen.Default result = new Goedel.Tool.ProtoGen.Default();
            Push (result);
            State = StateCode.Default_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Maximum NewMaximum() {
            Goedel.Tool.ProtoGen.Maximum result = new Goedel.Tool.ProtoGen.Maximum();
            Push (result);
            State = StateCode.Maximum_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Minimum NewMinimum() {
            Goedel.Tool.ProtoGen.Minimum result = new Goedel.Tool.ProtoGen.Minimum();
            Push (result);
            State = StateCode.Minimum_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.LengthBits NewLengthBits() {
            Goedel.Tool.ProtoGen.LengthBits result = new Goedel.Tool.ProtoGen.LengthBits();
            Push (result);
            State = StateCode.LengthBits_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.LengthFixed NewLengthFixed() {
            Goedel.Tool.ProtoGen.LengthFixed result = new Goedel.Tool.ProtoGen.LengthFixed();
            Push (result);
            State = StateCode.LengthFixed_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Enumeration NewEnumeration() {
            Goedel.Tool.ProtoGen.Enumeration result = new Goedel.Tool.ProtoGen.Enumeration();
            Push (result);
            State = StateCode.Enumeration_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.EnumerationEntry NewEnumerationEntry() {
            Goedel.Tool.ProtoGen.EnumerationEntry result = new Goedel.Tool.ProtoGen.EnumerationEntry();
            Push (result);
            State = StateCode.EnumerationEntry_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Mapping NewMapping() {
            Goedel.Tool.ProtoGen.Mapping result = new Goedel.Tool.ProtoGen.Mapping();
            Push (result);
            State = StateCode.Mapping_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Root NewRoot() {
            Goedel.Tool.ProtoGen.Root result = new Goedel.Tool.ProtoGen.Root();
            Push (result);
            State = StateCode.Root_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Language NewLanguage() {
            Goedel.Tool.ProtoGen.Language result = new Goedel.Tool.ProtoGen.Language();
            Push (result);
            State = StateCode.Language_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.C NewC() {
            Goedel.Tool.ProtoGen.C result = new Goedel.Tool.ProtoGen.C();
            Push (result);
            State = StateCode.C_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.CS NewCS() {
            Goedel.Tool.ProtoGen.CS result = new Goedel.Tool.ProtoGen.CS();
            Push (result);
            State = StateCode.CS_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Stubs NewStubs() {
            Goedel.Tool.ProtoGen.Stubs result = new Goedel.Tool.ProtoGen.Stubs();
            Push (result);
            State = StateCode.Stubs_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Prefix NewPrefix() {
            Goedel.Tool.ProtoGen.Prefix result = new Goedel.Tool.ProtoGen.Prefix();
            Push (result);
            State = StateCode.Prefix_Start;
            return result;
            }


        private Goedel.Tool.ProtoGen.Binding NewBinding() {
            Goedel.Tool.ProtoGen.Binding result = new Goedel.Tool.ProtoGen.Binding();
            Push (result);
            State = StateCode.Binding_Start;
            return result;
            }


        static Goedel.Tool.ProtoGen.ProtoStructType _Reserved(string Label) {
            switch (Label) {

                case "Protocol": return Goedel.Tool.ProtoGen.ProtoStructType.Protocol;
                case "Using": return Goedel.Tool.ProtoGen.ProtoStructType.Using;
                case "Extern": return Goedel.Tool.ProtoGen.ProtoStructType.Extern;
                case "Section": return Goedel.Tool.ProtoGen.ProtoStructType.Section;
                case "Service": return Goedel.Tool.ProtoGen.ProtoStructType.Service;
                case "Transaction": return Goedel.Tool.ProtoGen.ProtoStructType.Transaction;
                case "Message": return Goedel.Tool.ProtoGen.ProtoStructType.Message;
                case "Authentication": return Goedel.Tool.ProtoGen.ProtoStructType.Authentication;
                case "Structure": return Goedel.Tool.ProtoGen.ProtoStructType.Structure;
                case "Description": return Goedel.Tool.ProtoGen.ProtoStructType.Description;
                case "ABNF": return Goedel.Tool.ProtoGen.ProtoStructType.ABNF;
                case "Abstract": return Goedel.Tool.ProtoGen.ProtoStructType.Abstract;
                case "Inherits": return Goedel.Tool.ProtoGen.ProtoStructType.Inherits;
                case "Request": return Goedel.Tool.ProtoGen.ProtoStructType.Request;
                case "Response": return Goedel.Tool.ProtoGen.ProtoStructType.Response;
                case "External": return Goedel.Tool.ProtoGen.ProtoStructType.External;
                case "Tag": return Goedel.Tool.ProtoGen.ProtoStructType.Tag;
                case "Boolean": return Goedel.Tool.ProtoGen.ProtoStructType.Boolean;
                case "Integer": return Goedel.Tool.ProtoGen.ProtoStructType.Integer;
                case "Decimal": return Goedel.Tool.ProtoGen.ProtoStructType.Decimal;
                case "Float": return Goedel.Tool.ProtoGen.ProtoStructType.Float;
                case "Binary": return Goedel.Tool.ProtoGen.ProtoStructType.Binary;
                case "Label": return Goedel.Tool.ProtoGen.ProtoStructType.Label;
                case "Name": return Goedel.Tool.ProtoGen.ProtoStructType.Name;
                case "String": return Goedel.Tool.ProtoGen.ProtoStructType.String;
                case "Constraint": return Goedel.Tool.ProtoGen.ProtoStructType.Constraint;
                case "URI": return Goedel.Tool.ProtoGen.ProtoStructType.URI;
                case "DateTime": return Goedel.Tool.ProtoGen.ProtoStructType.DateTime;
                case "Param": return Goedel.Tool.ProtoGen.ProtoStructType.Param;
                case "Funct": return Goedel.Tool.ProtoGen.ProtoStructType.Funct;
                case "TStruct": return Goedel.Tool.ProtoGen.ProtoStructType.TStruct;
                case "Struct": return Goedel.Tool.ProtoGen.ProtoStructType.Struct;
                case "Enum": return Goedel.Tool.ProtoGen.ProtoStructType.Enum;
                case "Select": return Goedel.Tool.ProtoGen.ProtoStructType.Select;
                case "TaggedType": return Goedel.Tool.ProtoGen.ProtoStructType.TaggedType;
                case "Format": return Goedel.Tool.ProtoGen.ProtoStructType.Format;
                case "Tagged": return Goedel.Tool.ProtoGen.ProtoStructType.Tagged;
                case "Required": return Goedel.Tool.ProtoGen.ProtoStructType.Required;
                case "Multiple": return Goedel.Tool.ProtoGen.ProtoStructType.Multiple;
                case "Quoted": return Goedel.Tool.ProtoGen.ProtoStructType.Quoted;
                case "Require": return Goedel.Tool.ProtoGen.ProtoStructType.Require;
                case "Class": return Goedel.Tool.ProtoGen.ProtoStructType.Class;
                case "Command": return Goedel.Tool.ProtoGen.ProtoStructType.Command;
                case "Brief": return Goedel.Tool.ProtoGen.ProtoStructType.Brief;
                case "Parameter": return Goedel.Tool.ProtoGen.ProtoStructType.Parameter;
                case "Status": return Goedel.Tool.ProtoGen.ProtoStructType.Status;
                case "Success": return Goedel.Tool.ProtoGen.ProtoStructType.Success;
                case "Error": return Goedel.Tool.ProtoGen.ProtoStructType.Error;
                case "Warning": return Goedel.Tool.ProtoGen.ProtoStructType.Warning;
                case "Option": return Goedel.Tool.ProtoGen.ProtoStructType.Option;
                case "Include": return Goedel.Tool.ProtoGen.ProtoStructType.Include;
                case "OptionSet": return Goedel.Tool.ProtoGen.ProtoStructType.OptionSet;
                case "Enumerate": return Goedel.Tool.ProtoGen.ProtoStructType.Enumerate;
                case "Case": return Goedel.Tool.ProtoGen.ProtoStructType.Case;
                case "Type": return Goedel.Tool.ProtoGen.ProtoStructType.Type;
                case "Default": return Goedel.Tool.ProtoGen.ProtoStructType.Default;
                case "Maximum": return Goedel.Tool.ProtoGen.ProtoStructType.Maximum;
                case "Minimum": return Goedel.Tool.ProtoGen.ProtoStructType.Minimum;
                case "LengthBits": return Goedel.Tool.ProtoGen.ProtoStructType.LengthBits;
                case "LengthFixed": return Goedel.Tool.ProtoGen.ProtoStructType.LengthFixed;
                case "Enumeration": return Goedel.Tool.ProtoGen.ProtoStructType.Enumeration;
                case "EnumerationEntry": return Goedel.Tool.ProtoGen.ProtoStructType.EnumerationEntry;
                case "Mapping": return Goedel.Tool.ProtoGen.ProtoStructType.Mapping;
                case "Root": return Goedel.Tool.ProtoGen.ProtoStructType.Root;
                case "Language": return Goedel.Tool.ProtoGen.ProtoStructType.Language;
                case "C": return Goedel.Tool.ProtoGen.ProtoStructType.C;
                case "CS": return Goedel.Tool.ProtoGen.ProtoStructType.CS;
                case "Stubs": return Goedel.Tool.ProtoGen.ProtoStructType.Stubs;
                case "Prefix": return Goedel.Tool.ProtoGen.ProtoStructType.Prefix;
                case "Binding": return Goedel.Tool.ProtoGen.ProtoStructType.Binding;

                }
            return Goedel.Tool.ProtoGen.ProtoStructType._Bottom;
            }


		public void Serialize (TextWriter Output)=> Serialize (Output, OutputFormat.Goedel);

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Tool.ProtoGen._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Tool.ProtoGen._Choice Token) {
            _StackItem Item = new _StackItem () {
					State = State,
					Token = Current
					};

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.False (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.False (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Protocol) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Class) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Mapping)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Protocol_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Protocol Current_Cast = (Goedel.Tool.ProtoGen.Protocol)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__NamespaceT, Current_Cast);
                            State = StateCode.Protocol__Namespace;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Protocol__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Protocol Current_Cast = (Goedel.Tool.ProtoGen.Protocol)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__Top, Current_Cast);
                            State = StateCode.Protocol__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Protocol__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Protocol Current_Cast = (Goedel.Tool.ProtoGen.Protocol)Current;
                            Current_Cast.Prefix = Registry.TOKEN(Position, Text, TYPE__PrefixT, Current_Cast);
                            State = StateCode.Protocol__Prefix;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Protocol__Prefix:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Protocol__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Protocol__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Protocol Current_Cast = (Goedel.Tool.ProtoGen.Protocol)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Section) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Service) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Transaction) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Message) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Structure) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Using) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Extern) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Enumeration) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Success) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Warning) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Error) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Inherits) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Section Service Transaction Message Structure Description Using Extern Enumeration Success Warning Error Inherits ]");
								}
							}
                        break;


                    case StateCode.Using_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Using Current_Cast = (Goedel.Tool.ProtoGen.Using)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Using__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Using__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Extern_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Extern Current_Cast = (Goedel.Tool.ProtoGen.Extern)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Extern__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Extern__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Extern__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Extern__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Extern Current_Cast = (Goedel.Tool.ProtoGen.Extern)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Section_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.Section Current_Cast = (Goedel.Tool.ProtoGen.Section)Current;
                            Current_Cast.Level = Convert.ToInt32(Text);
                            State = StateCode.Section__Level;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Section__Level:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Section Current_Cast = (Goedel.Tool.ProtoGen.Section)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Section__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Section__Title:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Section__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Section__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Section Current_Cast = (Goedel.Tool.ProtoGen.Section)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Service_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Service Current_Cast = (Goedel.Tool.ProtoGen.Service)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ClassT, Current_Cast);
                            State = StateCode.Service__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Service__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Service Current_Cast = (Goedel.Tool.ProtoGen.Service)Current;
                            Current_Cast.Discovery = Text;
                            State = StateCode.Service__Discovery;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Service__Discovery:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Service Current_Cast = (Goedel.Tool.ProtoGen.Service)Current;
                            Current_Cast.WellKnown = Text;
                            State = StateCode.Service__WellKnown;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Service__WellKnown:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Service Current_Cast = (Goedel.Tool.ProtoGen.Service)Current;
                            Current_Cast.Request = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Service__Request;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Service__Request:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Service Current_Cast = (Goedel.Tool.ProtoGen.Service)Current;
                            Current_Cast.Response = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Service__Response;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Service__Response:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Service__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Service__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Service Current_Cast = (Goedel.Tool.ProtoGen.Service)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Status) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description Status ]");
								}
							}
                        break;


                    case StateCode.Transaction_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Transaction Current_Cast = (Goedel.Tool.ProtoGen.Transaction)Current;
                            Current_Cast.Class = Registry.REF(Position, Text, TYPE__ClassT, Current_Cast);
                            State = StateCode.Transaction__Class;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Class:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Transaction Current_Cast = (Goedel.Tool.ProtoGen.Transaction)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Transaction__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Transaction Current_Cast = (Goedel.Tool.ProtoGen.Transaction)Current;
                            Current_Cast.Request = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Transaction__Request;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Request:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Transaction Current_Cast = (Goedel.Tool.ProtoGen.Transaction)Current;
                            Current_Cast.Response = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Transaction__Response;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Transaction__Response:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Transaction__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Transaction__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Transaction Current_Cast = (Goedel.Tool.ProtoGen.Transaction)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Status) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description Status ]");
								}
							}
                        break;


                    case StateCode.Message_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Message Current_Cast = (Goedel.Tool.ProtoGen.Message)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Message__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Message__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Message__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Message__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Message Current_Cast = (Goedel.Tool.ProtoGen.Message)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Abstract) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Inherits) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.External) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Boolean) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Integer) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Binary) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Float) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Label) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Name) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.String) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.URI) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.DateTime) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Struct) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.TStruct) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Enum) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Status) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Authentication) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Format) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Decimal) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Funct) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Param) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description Abstract Inherits External Boolean Integer Binary Float Label Name String URI DateTime Struct TStruct Enum Status Authentication Format Decimal Funct Param ]");
								}
							}
                        break;


                    case StateCode.Authentication_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Authentication Current_Cast = (Goedel.Tool.ProtoGen.Authentication)Current;
                            Current_Cast.Mechanism = Registry.TOKEN(Position, Text, TYPE__AuthenticationT, Current_Cast);
                            State = StateCode.Authentication__Mechanism;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Authentication__Mechanism:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Structure_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Structure Current_Cast = (Goedel.Tool.ProtoGen.Structure)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.Structure__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Structure__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Structure__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Structure__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Structure Current_Cast = (Goedel.Tool.ProtoGen.Structure)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Abstract) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Inherits) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.External) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Boolean) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Integer) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Binary) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Float) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Label) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Name) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.String) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.URI) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.DateTime) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Struct) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.TStruct) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Enum) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Format) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Decimal) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Select) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Funct) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Param) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description Abstract Inherits External Boolean Integer Binary Float Label Name String URI DateTime Struct TStruct Enum Format Decimal Select Funct Param ]");
								}
							}
                        break;


                    case StateCode.Description_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Description__Text1;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Description__Text1:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.ProtoGen.Description Current_Cast = (Goedel.Tool.ProtoGen.Description)Current;
                            Current_Cast.Text1.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.ABNF_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.ABNF__Text1;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.ABNF__Text1:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.ProtoGen.ABNF Current_Cast = (Goedel.Tool.ProtoGen.ABNF)Current;
                            Current_Cast.Text1.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Abstract_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Inherits_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Inherits Current_Cast = (Goedel.Tool.ProtoGen.Inherits)Current;
                            Current_Cast.Ref = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Inherits__Ref;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Inherits__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Request_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Request Current_Cast = (Goedel.Tool.ProtoGen.Request)Current;
                            Current_Cast.Ref = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Request__Ref;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Request__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Response_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Response Current_Cast = (Goedel.Tool.ProtoGen.Response)Current;
                            Current_Cast.Ref = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Response__Ref;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Response__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.External_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.External Current_Cast = (Goedel.Tool.ProtoGen.External)Current;
                            Current_Cast.Ref = Registry.TOKEN(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.External__Ref;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.External__Ref:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Tag_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Tag Current_Cast = (Goedel.Tool.ProtoGen.Tag)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Tag__Text;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Tag__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Boolean_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Boolean Current_Cast = (Goedel.Tool.ProtoGen.Boolean)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Boolean__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Boolean__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Boolean__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Boolean__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Boolean Current_Cast = (Goedel.Tool.ProtoGen.Boolean)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default ]");
								}
							}
                        break;


                    case StateCode.Integer_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Integer Current_Cast = (Goedel.Tool.ProtoGen.Integer)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Integer__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Integer__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Integer__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Integer__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Integer Current_Cast = (Goedel.Tool.ProtoGen.Integer)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default LengthBits Tag ]");
								}
							}
                        break;


                    case StateCode.Decimal_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Decimal Current_Cast = (Goedel.Tool.ProtoGen.Decimal)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Decimal__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Decimal__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Decimal__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Decimal__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Decimal Current_Cast = (Goedel.Tool.ProtoGen.Decimal)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.Float_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Float Current_Cast = (Goedel.Tool.ProtoGen.Float)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Float__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Float__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Float__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Float__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Float Current_Cast = (Goedel.Tool.ProtoGen.Float)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.Binary_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Binary Current_Cast = (Goedel.Tool.ProtoGen.Binary)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Binary__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Binary__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Binary__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Binary__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Binary Current_Cast = (Goedel.Tool.ProtoGen.Binary)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.LengthFixed) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default LengthBits LengthFixed Tag ]");
								}
							}
                        break;


                    case StateCode.Label_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Label Current_Cast = (Goedel.Tool.ProtoGen.Label)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Label__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Label__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Label__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Label__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Label Current_Cast = (Goedel.Tool.ProtoGen.Label)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.Name_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Name Current_Cast = (Goedel.Tool.ProtoGen.Name)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Name__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Name__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Name__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Name__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Name Current_Cast = (Goedel.Tool.ProtoGen.Name)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.String_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.String Current_Cast = (Goedel.Tool.ProtoGen.String)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.String__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.String__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.String__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.String__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.String Current_Cast = (Goedel.Tool.ProtoGen.String)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Quoted) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Constraint) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default Quoted Constraint Tag ]");
								}
							}
                        break;


                    case StateCode.Constraint_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Constraint Current_Cast = (Goedel.Tool.ProtoGen.Constraint)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ConstraintType, Current_Cast);
                            State = StateCode.Constraint__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Constraint__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.URI_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.URI Current_Cast = (Goedel.Tool.ProtoGen.URI)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.URI__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.URI__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.URI__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.URI__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.URI Current_Cast = (Goedel.Tool.ProtoGen.URI)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.DateTime_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.DateTime Current_Cast = (Goedel.Tool.ProtoGen.DateTime)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.DateTime__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.DateTime__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.DateTime__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.DateTime__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.DateTime Current_Cast = (Goedel.Tool.ProtoGen.DateTime)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Default Tag ]");
								}
							}
                        break;


                    case StateCode.Param_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Param Current_Cast = (Goedel.Tool.ProtoGen.Param)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Param__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Param__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Funct_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Funct Current_Cast = (Goedel.Tool.ProtoGen.Funct)Current;
                            Current_Cast.Outer = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.Funct__Outer;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Funct__Outer:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Funct Current_Cast = (Goedel.Tool.ProtoGen.Funct)Current;
                            Current_Cast.Inner = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.Funct__Inner;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Funct__Inner:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.TStruct_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.TStruct Current_Cast = (Goedel.Tool.ProtoGen.TStruct)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.TStruct__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.TStruct__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.TStruct Current_Cast = (Goedel.Tool.ProtoGen.TStruct)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.TStruct__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.TStruct__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.TStruct__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.TStruct__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.TStruct Current_Cast = (Goedel.Tool.ProtoGen.TStruct)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description LengthBits Tag ]");
								}
							}
                        break;


                    case StateCode.Struct_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Struct Current_Cast = (Goedel.Tool.ProtoGen.Struct)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.Struct__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Struct__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Struct Current_Cast = (Goedel.Tool.ProtoGen.Struct)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Struct__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Struct__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Struct__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Struct__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Struct Current_Cast = (Goedel.Tool.ProtoGen.Struct)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.LengthBits) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description LengthBits Tag ]");
								}
							}
                        break;


                    case StateCode.Enum_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Enum Current_Cast = (Goedel.Tool.ProtoGen.Enum)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__EnumerationType, Current_Cast);
                            State = StateCode.Enum__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Enum__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Enum Current_Cast = (Goedel.Tool.ProtoGen.Enum)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Enum__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Enum__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enum__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enum__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Enum Current_Cast = (Goedel.Tool.ProtoGen.Enum)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Tag) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description Tag ]");
								}
							}
                        break;


                    case StateCode.Select_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Select Current_Cast = (Goedel.Tool.ProtoGen.Select)Current;
                            Current_Cast.Tag = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Select__Tag;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Select__Tag:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Select Current_Cast = (Goedel.Tool.ProtoGen.Select)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Select__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Select__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Select__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Select__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.ProtoGen.Select Current_Cast = (Goedel.Tool.ProtoGen.Select)Current;
                            Current_Cast.Entries.Add (NewTaggedType ());
                            Represent = true;
                            }

                        break;


                    case StateCode.TaggedType_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.TaggedType Current_Cast = (Goedel.Tool.ProtoGen.TaggedType)Current;
                            Current_Cast.Tag = Registry.REF(Position, Text, TYPE__EnumerationLabel, Current_Cast);
                            State = StateCode.TaggedType__Tag;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.TaggedType__Tag:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.TaggedType Current_Cast = (Goedel.Tool.ProtoGen.TaggedType)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__StructureT, Current_Cast);
                            State = StateCode.TaggedType__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.TaggedType__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Format_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Format Current_Cast = (Goedel.Tool.ProtoGen.Format)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FormatT, Current_Cast);
                            State = StateCode.Format__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Format__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Format__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Format__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Format Current_Cast = (Goedel.Tool.ProtoGen.Format)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.ABNF) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ABNF ]");
								}
							}
                        break;


                    case StateCode.Tagged_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Tagged Current_Cast = (Goedel.Tool.ProtoGen.Tagged)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Tagged__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Tagged__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Tagged Current_Cast = (Goedel.Tool.ProtoGen.Tagged)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Tagged__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Tagged__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Tagged__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Tagged__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Tagged Current_Cast = (Goedel.Tool.ProtoGen.Tagged)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Required) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Multiple) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Required Multiple Description ]");
								}
							}
                        break;


                    case StateCode.Required_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Multiple_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Quoted_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Require_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Require Current_Cast = (Goedel.Tool.ProtoGen.Require)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__Variable, Current_Cast);
                            State = StateCode.Require__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Require__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Class_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Class Current_Cast = (Goedel.Tool.ProtoGen.Class)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Class__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Class__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Class__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Class Current_Cast = (Goedel.Tool.ProtoGen.Class)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Brief) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Command) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.OptionSet) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Enumerate) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Type) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Brief Command OptionSet Enumerate Type ]");
								}
							}
                        break;


                    case StateCode.Command_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Command Current_Cast = (Goedel.Tool.ProtoGen.Command)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__CommandType, Current_Cast);
                            State = StateCode.Command__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Command__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Command Current_Cast = (Goedel.Tool.ProtoGen.Command)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Command__Tag;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Command__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Command__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Command__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Command Current_Cast = (Goedel.Tool.ProtoGen.Command)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Brief) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Parameter) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Option) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Include) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Default) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Brief Parameter Option Include Default ]");
								}
							}
                        break;


                    case StateCode.Brief_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Brief Current_Cast = (Goedel.Tool.ProtoGen.Brief)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Brief__Text;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Brief__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Parameter_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Parameter Current_Cast = (Goedel.Tool.ProtoGen.Parameter)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__PType, Current_Cast);
                            State = StateCode.Parameter__Name;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Name:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Parameter Current_Cast = (Goedel.Tool.ProtoGen.Parameter)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Parameter__Text;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Parameter__Text:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Parameter Current_Cast = (Goedel.Tool.ProtoGen.Parameter)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Parameter__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Status_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Status Current_Cast = (Goedel.Tool.ProtoGen.Status)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Status__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Status__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Status__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Status__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Status Current_Cast = (Goedel.Tool.ProtoGen.Status)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Success_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Success Current_Cast = (Goedel.Tool.ProtoGen.Success)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Success__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Success__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.Success Current_Cast = (Goedel.Tool.ProtoGen.Success)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.Success__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Success__Code:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Success__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Success__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Success Current_Cast = (Goedel.Tool.ProtoGen.Success)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Error_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Error Current_Cast = (Goedel.Tool.ProtoGen.Error)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Error__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Error__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.Error Current_Cast = (Goedel.Tool.ProtoGen.Error)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.Error__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Error__Code:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Error__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Error__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Error Current_Cast = (Goedel.Tool.ProtoGen.Error)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Warning_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Warning Current_Cast = (Goedel.Tool.ProtoGen.Warning)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__StatusT, Current_Cast);
                            State = StateCode.Warning__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Warning__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.Warning Current_Cast = (Goedel.Tool.ProtoGen.Warning)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.Warning__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Warning__Code:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Warning__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Warning__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Warning Current_Cast = (Goedel.Tool.ProtoGen.Warning)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Option_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Option Current_Cast = (Goedel.Tool.ProtoGen.Option)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__PType, Current_Cast);
                            State = StateCode.Option__Name;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Option__Name:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Option Current_Cast = (Goedel.Tool.ProtoGen.Option)Current;
                            Current_Cast.Command = Text;
                            State = StateCode.Option__Command;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Option__Command:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Option Current_Cast = (Goedel.Tool.ProtoGen.Option)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Option__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Option__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Include_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Include Current_Cast = (Goedel.Tool.ProtoGen.Include)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__OptionSetType, Current_Cast);
                            State = StateCode.Include__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Include__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OptionSet_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.OptionSet Current_Cast = (Goedel.Tool.ProtoGen.OptionSet)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__OptionSetType, Current_Cast);
                            State = StateCode.OptionSet__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.OptionSet__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.OptionSet__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.OptionSet__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.OptionSet Current_Cast = (Goedel.Tool.ProtoGen.OptionSet)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Option) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Option ]");
								}
							}
                        break;


                    case StateCode.Enumerate_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Enumerate Current_Cast = (Goedel.Tool.ProtoGen.Enumerate)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Enumerate__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Enumerate__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enumerate__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enumerate__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.ProtoGen.Enumerate Current_Cast = (Goedel.Tool.ProtoGen.Enumerate)Current;
                            Current_Cast.Entries.Add (NewCase ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Case_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Case Current_Cast = (Goedel.Tool.ProtoGen.Case)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__CaseType, Current_Cast);
                            State = StateCode.Case__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Case__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Case Current_Cast = (Goedel.Tool.ProtoGen.Case)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Case__Tag;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Case__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Type_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Type Current_Cast = (Goedel.Tool.ProtoGen.Type)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__TypeType, Current_Cast);
                            State = StateCode.Type__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Type__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Type Current_Cast = (Goedel.Tool.ProtoGen.Type)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Type__Text;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Type__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Default_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Default Current_Cast = (Goedel.Tool.ProtoGen.Default)Current;
                            Current_Cast.Value = Text;
                            State = StateCode.Default__Value;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Default__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Maximum_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.Maximum Current_Cast = (Goedel.Tool.ProtoGen.Maximum)Current;
                            Current_Cast.Value = Convert.ToInt32(Text);
                            State = StateCode.Maximum__Value;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Maximum__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Minimum_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.Minimum Current_Cast = (Goedel.Tool.ProtoGen.Minimum)Current;
                            Current_Cast.Value = Convert.ToInt32(Text);
                            State = StateCode.Minimum__Value;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Minimum__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.LengthBits_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.LengthBits Current_Cast = (Goedel.Tool.ProtoGen.LengthBits)Current;
                            Current_Cast.Bits = Convert.ToInt32(Text);
                            State = StateCode.LengthBits__Bits;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.LengthBits__Bits:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.LengthFixed_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.LengthFixed Current_Cast = (Goedel.Tool.ProtoGen.LengthFixed)Current;
                            Current_Cast.Bytes = Convert.ToInt32(Text);
                            State = StateCode.LengthFixed__Bytes;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.LengthFixed__Bytes:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Enumeration_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Enumeration Current_Cast = (Goedel.Tool.ProtoGen.Enumeration)Current;
                            Current_Cast.Name = Registry.ID(Position, Text, TYPE__EnumerationType, Current_Cast);
                            State = StateCode.Enumeration__Name;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Enumeration__Name:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.Enumeration Current_Cast = (Goedel.Tool.ProtoGen.Enumeration)Current;
                            Current_Cast.Maximum = Convert.ToInt32(Text);
                            State = StateCode.Enumeration__Maximum;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Enumeration__Maximum:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enumeration__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enumeration__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.ProtoGen.Enumeration Current_Cast = (Goedel.Tool.ProtoGen.Enumeration)Current;
                            Current_Cast.Entries.Add (NewEnumerationEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.EnumerationEntry_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.EnumerationEntry Current_Cast = (Goedel.Tool.ProtoGen.EnumerationEntry)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__EnumerationLabel, Current_Cast);
                            State = StateCode.EnumerationEntry__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.EnumerationEntry__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.ProtoGen.EnumerationEntry Current_Cast = (Goedel.Tool.ProtoGen.EnumerationEntry)Current;
                            Current_Cast.Code = Convert.ToInt32(Text);
                            State = StateCode.EnumerationEntry__Code;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.EnumerationEntry__Code:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Mapping_Start:
						// Parser transition for _Label $$$$$

                    case StateCode.Mapping__Id:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Mapping Current_Cast = (Goedel.Tool.ProtoGen.Mapping)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Root) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Language) ) {
                                State = StateCode.Mapping__MappingType;
                                Current_Cast.MappingType = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [Root Language ]");
                                }
                            break;
                            }
                        else throw new Expected("Parser Error Expected [Root Language ]");

                    case StateCode.Mapping__MappingType:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Root_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Root Current_Cast = (Goedel.Tool.ProtoGen.Root)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Root__Namespace;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Root__Namespace:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Language_Start:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Language Current_Cast = (Goedel.Tool.ProtoGen.Language)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.C) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.CS) ) {
                                State = StateCode.Language__For;
                                Current_Cast.For = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [C CS ]");
                                }
                            break;
                            }
                        else throw new Expected("Parser Error Expected [C CS ]");

                    case StateCode.Language__For:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.C_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.C__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.C__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.C Current_Cast = (Goedel.Tool.ProtoGen.C)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Prefix) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Binding) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Stubs) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Prefix Binding Stubs ]");
								}
							}
                        break;


                    case StateCode.CS_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.CS__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.CS__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.CS Current_Cast = (Goedel.Tool.ProtoGen.CS)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Binding) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Stubs) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Binding Stubs ]");
								}
							}
                        break;


                    case StateCode.Stubs_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Prefix_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.ProtoGen.Prefix Current_Cast = (Goedel.Tool.ProtoGen.Prefix)Current;
                            Current_Cast.Tag = Registry.TOKEN(Position, Text, TYPE__NamespaceType, Current_Cast);
                            State = StateCode.Prefix__Tag;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Prefix__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Binding_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.ProtoGen.Binding Current_Cast = (Goedel.Tool.ProtoGen.Binding)Current;
                            Current_Cast.Mapping = Text;
                            State = StateCode.Binding__Mapping;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Binding__Mapping:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.ProtoGen.Binding Current_Cast = (Goedel.Tool.ProtoGen.Binding)Current;
                            Goedel.Tool.ProtoGen.ProtoStructType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Boolean) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Integer) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Binary) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Float) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Label) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.Name) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.String) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.URI) |
									(LabelType == Goedel.Tool.ProtoGen.ProtoStructType.DateTime) ) {
                                State = StateCode.Binding__Type;
                                Current_Cast.Type = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [Boolean Integer Binary Float Label Name String URI DateTime ]");
                                }
                            break;
                            }
                        else throw new Expected("Parser Error Expected [Boolean Integer Binary Float Label Name String URI DateTime ]");

                    case StateCode.Binding__Type:
                        Pop ();
                        Represent = true; 
                        break;

                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}
#pragma warning restore IDE0022	

