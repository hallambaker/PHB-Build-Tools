#script 1.0
#license MITLicense
#xclass Goedel.Tool.ProtoGen Generate
#% bool OldConstructors = false;
#% Separator Separator = new Separator (",");
#!
#!   Code Generator (C#)
#!
#!  

#method GenerateCS ProtoStruct ProtoStruct
#% ProtoStruct.Complete ();
#% var GenerateTime =System.DateTime.UtcNow;
#!% Boilerplate.Header (_Output, "//  ", GenerateTime);
#% Boilerplate.MITLicense (_Output, "//  ", "Copyright (c) " + "2016", ".");
#% var InheritsOverride = "override"; // "virtual"
#% string Namespace;

using System;
using System.IO;
using System.Collections;
using System.Collections.Generic;
using System.Text;
using Goedel.Protocol;



#foreach (var Item in ProtoStruct.Top)
#switchcast ProtoStructType Item
#casecast Protocol Protocol
#foreach (var Entry in Protocol.Entries)
#switchcast ProtoStructType Entry
#casecast Using Using
using #{Using.Id};
#end switchcast
#end foreach


#% Namespace = Protocol.Namespace.ToString ();
namespace #{Namespace} {


#% DescriptionListC (Protocol.Entries, 1);
	public abstract partial class #{Protocol.Prefix} #{Protocol.ThisInherits} {
#% CurrentPrefix = Protocol.Prefix.ToString ();

        /// <summary>
        /// Schema tag.
        /// </summary>
        /// <returns>The tag value</returns>
		public #{InheritsOverride} string Tag () {
			return _Tag;
			}

		/// <summary>
        /// Tag identifying this class
        /// </summary>
		public override string _Tag { get; } = "#{Protocol.Prefix}";

		/// <summary>
        /// Dictionary mapping tags to factory methods
        /// </summary>
		public static Dictionary<string, JSONFactoryDelegate> _TagDictionary = 
				new Dictionary<string, JSONFactoryDelegate> () {
#% Separator.IsFirst = true;
#foreach (_Choice Entry in Protocol.Structures)
#{Separator}
			{"#{Entry.ID}", #{Entry.ID}._Factory}#!
#end foreach
			};

		/// <summary>
        /// Construct an instance from the specified tagged JSONReader stream.
        /// </summary>
        /// <param name="JSONReader">Input stream</param>
        /// <param name="Out">The created object</param>
        public static void Deserialize(JSONReader JSONReader, out JSONObject Out) {
			Out = JSONReader.ReadTaggedObject (_TagDictionary);
            }
		}



		// Service Dispatch Classes
#foreach (_Choice Entry in Protocol.Entries)
#switchcast ProtoStructType Entry
#casecast Service Service


    /// <summary>
	/// The new base class for the client and service side APIs.
    /// </summary>		
    public abstract partial class #{Service.Id} : Goedel.Protocol.JPCInterface {
		
        /// <summary>
        /// Well Known service identifier.
        /// </summary>
		public const string WellKnown = "#{Service.WellKnown}";

        /// <summary>
        /// Well Known service identifier.
        /// </summary>
		public override string GetWellKnown {
			get => WellKnown;
			}

        /// <summary>
        /// Well Known service identifier.
        /// </summary>
		public const string Discovery = "#{Service.Discovery}";

        /// <summary>
        /// Well Known service identifier.
        /// </summary>
		public override string GetDiscovery {
			get => Discovery;
			}

        /// <summary>
        /// The active JPCSession.
        /// </summary>		
		public virtual JPCSession JPCSession {get; set;}

#foreach (_Choice Entry2 in Protocol.Entries)
#switchcast ProtoStructType Entry2
#casecast Transaction Transaction

        /// <summary>
		/// Base method for implementing the transaction  #{Transaction.Id}.
        /// </summary>
        /// <param name="Request">The request object to send to the host.</param>
		/// <returns>The response object from the service</returns>
        public virtual #{Transaction.Response} #{Transaction.Id} (
                #{Transaction.Request} Request) {
            return null;
            }
#end switchcast
#end foreach

        }

    /// <summary>
	/// Client class for #{Service.Id}.
    /// </summary>		
    public partial class #{Service.Id}Client : #{Service.Id} {
 		
		JPCRemoteSession JPCRemoteSession;
        /// <summary>
        /// The active JPCSession.
        /// </summary>		
		public override JPCSession JPCSession {
			get {return JPCRemoteSession;}
			set {JPCRemoteSession = value as JPCRemoteSession; }
			}


        /// <summary>
		/// Create a client connection to the specified service.
        /// </summary>	
        /// <param name="JPCRemoteSession">The remote session to connect to</param>
		public #{Service.Id}Client (JPCRemoteSession JPCRemoteSession) {
			this.JPCRemoteSession = JPCRemoteSession;
			}

#foreach (_Choice Entry2 in Protocol.Entries)
#switchcast ProtoStructType Entry2
#casecast Transaction Transaction

        /// <summary>
		/// Implement the transaction
        /// </summary>		
        /// <param name="Request">The request object</param>
		/// <returns>The response object</returns>
        public override #{Transaction.Response} #{Transaction.Id} (
                #{Transaction.Request} Request) {

            var ResponseData = JPCRemoteSession.Post("#{Transaction.Id}", Request);
            var Response = #{Transaction.Response}.FromJSON(ResponseData.JSONReader(), true);

            return Response;
            }
#end switchcast
#end foreach

		}


    /// <summary>
	/// Client class for #{Service.Id}.
    /// </summary>		
    public partial class #{Service.Id}Provider : Goedel.Protocol.JPCProvider {

		/// <summary>
		/// Interface object to dispatch requests to.
		/// </summary>	
		public #{Service.Id} Service;


		/// <summary>
		/// Dispatch object request in specified authentication context.
		/// </summary>			
        /// <param name="Session">The client context.</param>
        /// <param name="JSONReader">Reader for data object.</param>
        /// <returns>The response object returned by the corresponding dispatch.</returns>
		public override Goedel.Protocol.JSONObject Dispatch(JPCSession  Session,  
								Goedel.Protocol.JSONReader JSONReader) {

			JSONReader.StartObject ();
			string token = JSONReader.ReadToken ();
			JSONObject Response = null;

			switch (token) {
#foreach (_Choice Entry2 in Protocol.Entries)
#switchcast ProtoStructType Entry2
#casecast Transaction Transaction
				case "#{Transaction.Id}" : {
					var Request = new #{Transaction.Request}();
					Request.Deserialize (JSONReader);
					Response = Service.#{Transaction.Id} (Request);
					break;
					}
#end switchcast
#end foreach
				default : {
					throw new Goedel.Protocol.UnknownOperation ();
					}
				}
			JSONReader.EndObject ();
			return Response;
			}

		}


#end switchcast
#end foreach



		// Transaction Classes
#foreach (_Choice Entry in Protocol.Entries)
#switchcast ProtoStructType Entry
#casecast Message Message
#% MakeClass (Message.Id, Message.Entries, Message.Parameterized);
#% var Inherits = HasInherits  (Message.Entries);
#% MakeSerializers (Message.Id, Message.ID, Message.Entries, Inherits);
		}

#casecast Structure Structure
#% MakeClass (Structure.Id, Structure.Entries, Structure.Parameterized);
#% var Inherits = HasInherits  (Structure.Entries);
#% MakeSerializers (Structure.Id, Structure.ID, Structure.Entries, Inherits);
		}

#end switchcast
#end foreach
	}

#end switchcast
#end foreach
#end method

#block 
#% public bool IsAbstract  (List<_Choice> Entries) {
#% bool result = false;
#foreach (_Choice Entry in Entries)
#switchcast ProtoStructType Entry
#casecast Abstract null
#% result = true;
#end switchcast
#end foreach
#% return result;
#% }
#end block 

#block 
#% public bool IsMultiple  (List<_Choice> Entries) {
#% bool result = false;
#foreach (_Choice Entry in Entries)
#switchcast ProtoStructType Entry
#casecast Multiple null
#% result = true;
#end switchcast
#end foreach
#% return result;
#% }
#end block 

#block 
#% public bool IsRequired  (List<_Choice> Entries) {
#% bool result = false;
#foreach (_Choice Entry in Entries)
#switchcast ProtoStructType Entry
#casecast Required null
#% result = true;
#end switchcast
#end foreach
#% return result;
#% }
#end block 

#block 
#% public string HasInherits  (List<_Choice> Entries) {
#% string result = null;
#foreach (_Choice Entry in Entries)
#switchcast ProtoStructType Entry
#casecast Inherits Inherits
#% result = Inherits.Ref.ToString();
#casecast External External
#% result = External.Ref.ToString();
#end switchcast
#end foreach
#% return result;
#% }
#end block 

#block 
#% public void MakeClass  (ID<_Choice> Id, List<_Choice> Entries) {
#% var Inherits = HasInherits (Entries);
#!#% string Override;
#% DescriptionListC (Entries, 1);
	#!
#if (IsAbstract (Entries))
abstract #!
#end if
#if (Inherits == null) 
public partial class #{Id} : #{CurrentPrefix} {
#else 
public partial class #{Id} : #{Inherits} {
#end if
#call DeclareMembers (Entries)

        /// <summary>
        /// Tag identifying this class.
        /// </summary>
        /// <returns>The tag</returns>
		public override string Tag () {
			return "#{Id}";
			}

#% }
#end block 


#block 
#% public void MakeClass  (ID<_Choice> Id, List<_Choice> Entries, bool Param) {
#% var Inherits = HasInherits (Entries);
#!#% string Override;
#% DescriptionListC (Entries, 1);
	#!
#if (IsAbstract (Entries))
abstract #!
#end if
#% var TTT = Param ? "<T>" : "";
#if (Inherits == null) 
public partial class #{Id}#{TTT} : #{CurrentPrefix} {
#else 
public partial class #{Id}#{TTT} : #{Inherits} {
#end if
#call DeclareMembers (Entries)
		
		/// <summary>
        /// Tag identifying this class
        /// </summary>
		public override string _Tag { get; } = "#{Id}";

		/// <summary>
#if (IsAbstract (Entries))
        /// Factory method. Throws exception as this is an abstract class.
#else
        /// Factory method
#end if
        /// </summary>
        /// <returns>Object of this type</returns>
		public static new JSONObject _Factory () {
#if (IsAbstract (Entries))
			throw new CannotCreateAbstract();
#else
			return new #{Id}();
#end if
			}

#% }
#end block 


#block ParameterList
#% public void DeclareMembers  (List<_Choice> Entries) {
#foreach (_Choice Entry in Entries)
#% TOKEN<_Choice> Token = null;
#% string Type = null; string TType = null;
#% List<_Choice> Options = null;
#% bool Nullable;
#% string Tag;
#% GetType (Entry, out Token, out Type, out TType, out Options, out Nullable, out Tag);
#if (Token != null)
#% bool Multiple = IsMultiple (Options);
#if Multiple
#{CommentSummary(8,Entry.Description)}
		public virtual List<#{Type}>				#{Token}  {get; set;}
#else
#if !Nullable
		bool								__#{Token} = false;
		private #{Type}						_#{Token};
#{CommentSummary(8,Entry.Description)}
		public virtual #{Type}						#{Token} {
			get {return _#{Token};}
			set {_#{Token} = value; __#{Token} = true; }
			}
#else 
#{CommentSummary(8,Entry.Description)}
		public virtual #{Type}						#{Token}  {get; set;}
#end if
#end if
#end if
#end foreach
#% }
#end block

#block MakeSerializers
#% public void MakeSerializers  (ID<_Choice> Id, string STag, List<_Choice> Entries, string Inherits) {
#!% string IsOverride = (Id.Object.Superclass == null) ? "virtual " : "virtual ";

        /// <summary>
        /// Serialize this object to the specified output stream.
        /// </summary>
        /// <param name="Writer">Output stream</param>
        /// <param name="wrap">If true, output is wrapped with object
        /// start and end sequences '{ ... }'.</param>
        /// <param name="first">If true, item is the first entry in a list.</param>
		public override void Serialize (Writer Writer, bool wrap, ref bool first) {
			SerializeX (Writer, wrap, ref first);
			}

        /// <summary>
        /// Serialize this object to the specified output stream.
        /// Unlike the Serlialize() method, this method is not inherited from the
        /// parent class allowing a specific version of the method to be called.
        /// </summary>
        /// <param name="_Writer">Output stream</param>
        /// <param name="_wrap">If true, output is wrapped with object
        /// start and end sequences '{ ... }'.</param>
        /// <param name="_first">If true, item is the first entry in a list.</param>
		public new void SerializeX (Writer _Writer, bool _wrap, ref bool _first) {
			if (_wrap) {
				_Writer.WriteObjectStart ();
				}
#if (Inherits != null)
			((#{Inherits})this).SerializeX(_Writer, false, ref _first);
#end if
#foreach (_Choice Entry in Entries)
#% TOKEN<_Choice> Token = null;
#% string Type = null; string TType = null;
#% List<_Choice> Options = null; bool Nullable;
#% string Tag;
#% GetType (Entry, out Token, out Type, out TType, out Options, out Nullable, out Tag);
#if (Token != null)
#% bool Multiple = IsMultiple (Options);
#if Multiple
			if (#{Token} != null) {
				_Writer.WriteObjectSeparator (ref _first);
				_Writer.WriteToken ("#{Tag}", 1);
				_Writer.WriteArrayStart ();
				bool _firstarray = true;
				foreach (var _index in #{Token}) {
					_Writer.WriteArraySeparator (ref _firstarray);
#% MakeSerializeArrayEntry (Entry, "_index");
					}
				_Writer.WriteArrayEnd ();
				}
#else
#if Nullable
			if (#{Token} != null) {
#else
			if (__#{Token}){
#end if
				_Writer.WriteObjectSeparator (ref _first);
				_Writer.WriteToken ("#{Tag}", 1);
#% MakeSerializeEntry (Entry, Token.ToString());
				}
#end if
#if Multiple

#end if
#end if
#end foreach
			if (_wrap) {
				_Writer.WriteObjectEnd ();
				}
			}

        /// <summary>
        /// Deserialize a tagged stream
        /// </summary>
        /// <param name="JSONReader">The input stream</param>
		/// <param name="Tagged">If true, the input is wrapped in a tag specifying the type</param>
        /// <returns>The created object.</returns>		
        public static new #{Id} FromJSON (JSONReader JSONReader, bool Tagged=true) {
			if (JSONReader == null) {
				return null;
				}
			if (Tagged) {
				var Out = JSONReader.ReadTaggedObject (_TagDictionary);
				return Out as #{Id};
				}
#if (!IsAbstract (Entries))
		    var Result = new #{Id} ();
			Result.Deserialize (JSONReader);
			return Result;
#else
			throw new CannotCreateAbstract();
#end if
			}

        /// <summary>
        /// Having read a tag, process the corresponding value data.
        /// </summary>
        /// <param name="JSONReader">The input stream</param>
        /// <param name="Tag">The tag</param>
		public override void DeserializeToken (JSONReader JSONReader, string Tag) {
			
			switch (Tag) {
#foreach (_Choice Entry in Entries)
#% TOKEN<_Choice> Token = null;
#% string Type = null; string TType = null;
#% List<_Choice> Options = null;
#% bool Nullable;
#% string Tag;
#% GetType(Entry, out Token, out Type, out TType, out Options, out Nullable, out Tag);
#if (Token != null)
#% bool Multiple = IsMultiple (Options);
				case "#{Tag}" : {
#if Multiple
					// Have a sequence of values
					bool _Going = JSONReader.StartArray ();
					#{Token} = new List <#{Type}> ();
					while (_Going) {
#if Entry._Tag () == ProtoStructType.Struct
						// an untagged structure.
						var _Item = new  #{Type} ();
						_Item.Deserialize (JSONReader);
						// var _Item = new #{Type} (JSONReader);
#elseif Entry._Tag () == ProtoStructType.TStruct
						var _Item = #{Type}.FromJSON (JSONReader, true); // a tagged structure
#else
						#{Type} _Item = JSONReader.Read#{TType} ();
#end if
						#{Token}.Add (_Item);
						_Going = JSONReader.NextArray ();
						}
#else
#if Entry._Tag () == ProtoStructType.Struct
					// An untagged structure
					#{Token} = new #{Type} ();
					#{Token}.Deserialize (JSONReader);
 
#elseif Entry._Tag () == ProtoStructType.TStruct
					#{Token} = #{Type}.FromJSON (JSONReader, true) ;  // A tagged structure
#else
					#{Token} = JSONReader.Read#{TType} ();
#end if
#end if
					break;
					}
#end if
#end foreach
				default : {
#if (Inherits != null)
					base.DeserializeToken(JSONReader, Tag);
#end if
					break;
					}
				}
			// check up that all the required elements are present
			}


#% }
#end block

#method2 MakeSerializeEntry _Choice Entry string Tag
#switchcast ProtoStructType Entry
#casecast Boolean null
					_Writer.WriteBoolean (#{Tag});
#casecast Integer null
					_Writer.WriteInteger32 (#{Tag});
#casecast Binary null
					_Writer.WriteBinary (#{Tag});
#casecast Struct null
					#{Tag}.Serialize (_Writer, false);
#casecast TStruct null
					// expand this to a tagged structure
					//#{Tag}.Serialize (_Writer, false);
					{
						_Writer.WriteObjectStart();
						_Writer.WriteToken(#{Tag}.Tag(), 1);
						bool firstinner = true;
						#{Tag}.Serialize (_Writer, true, ref firstinner);
						_Writer.WriteObjectEnd();
						}
#casecast Label null
					_Writer.WriteString (#{Tag});
#casecast Name null
					_Writer.WriteString (#{Tag});
#casecast String null
					_Writer.WriteString (#{Tag});
#casecast URI null
					_Writer.WriteString (#{Tag});
#casecast DateTime null
					_Writer.WriteDateTime (#{Tag});
#%							break; }
#% default : {

#end switchcast
#end method2

#method2 MakeSerializeArrayEntry _Choice Entry string Tag
#switchcast ProtoStructType Entry
#casecast Boolean null
					_Writer.WriteBoolean (#{Tag});
#casecast Integer null
					_Writer.WriteInteger32 (#{Tag});
#casecast Binary null
					_Writer.WriteBinary (#{Tag});
#casecast Struct null
					// This is an untagged structure. Cannot inherit.
                    //_Writer.WriteObjectStart();
                    //_Writer.WriteToken(#{Tag}.Tag(), 1);
					bool firstinner = true;
					#{Tag}.Serialize (_Writer, true, ref firstinner);
                    //_Writer.WriteObjectEnd();
#casecast TStruct null
                    _Writer.WriteObjectStart();
                    _Writer.WriteToken(#{Tag}.Tag(), 1);
					bool firstinner = true;
					#{Tag}.Serialize (_Writer, true, ref firstinner);
                    _Writer.WriteObjectEnd();
#casecast Label null
					_Writer.WriteString (#{Tag});
#casecast Name null
					_Writer.WriteString (#{Tag});
#casecast String null
					_Writer.WriteString (#{Tag});
#casecast URI null
					_Writer.WriteString (#{Tag});
#casecast DateTime null
					_Writer.WriteDateTime (#{Tag});
#%							break; }
#% default : {

#end switchcast
#end method2


#block
#% void GetType (_Choice Entry, out TOKEN<_Choice> Token, out string Type, out string TType, 
#%				out List<_Choice> Options, out bool Nullable, out string Tag) {
#% Nullable = true;
#switchcast ProtoStructType Entry
#casecast Boolean Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "bool";  Nullable = false;TType = "Boolean";
#casecast Integer Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "int"; Nullable = false;TType = "Integer32";
#casecast Binary Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "byte[]";TType = "Binary";
#casecast Label Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "string";TType = "String";
#casecast Name Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "string";TType = "String";
#casecast String Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "string";TType = "String";
#casecast URI Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "string";TType = "String";
#casecast DateTime Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = "DateTime?"; Nullable = true; TType = "DateTime";
#casecast Struct Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = Param.Type.ToString(); TType = Type;
#casecast TStruct Param
#% Tag = Param.ID ; Token = Param.Id; Options = Param.Options; Type = Param.Type.ToString(); TType = Type;
#% break; } default : {
#% Tag = null ; Token = null; Options = null; Type = null; TType = null;
#end switchcast
#% }
#end block

#block
#% void GetSerializerz (_Choice Entry, out TOKEN<_Choice> Token, out string Type,
#%				out List<_Choice> Options) {
#switchcast ProtoStructType Entry
#casecast Boolean Param
#% Token = Param.Id; Options = Param.Options; Type = "Boolean";
#casecast Integer Param
#% Token = Param.Id; Options = Param.Options; Type = "Integer32";
#casecast Binary Param
#% Token = Param.Id; Options = Param.Options; Type = "Binary";
#casecast Label Param
#% Token = Param.Id; Options = Param.Options; Type = "String";
#casecast Name Param
#% Token = Param.Id; Options = Param.Options; Type = "String";
#casecast String Param
#% Token = Param.Id; Options = Param.Options; Type = "String";
#casecast URI Param
#% Token = Param.Id; Options = Param.Options; Type = "String";
#casecast DateTime Param
#% Token = Param.Id; Options = Param.Options; Type = "DateTime";
#casecast Struct Param
#% Token = Param.Id; Options = Param.Options; Type = Param.Type.ToString();
#casecast TStruct Param
#% Token = Param.Id; Options = Param.Options; Type = Param.Type.ToString();
#% break; } default : {
#% Token = null; Options = null; Type = null;
#end switchcast
#% }
#end block

#block DeserializeCase
#% void DeserializeCase (ID<_Choice> Id, string Tag) {

				case "#{Id}" : {
#if Id.Object.IsAbstract
					Out = null;
					throw new Exception ("Can't create abstract type");
#else
					// Out = #{Id}.Factory ();
					Out = new #{Id} ();
					Out.Deserialize (JSONReader);
					break;
#end if
					}

#%	}
#end block

#block MapInheritors
#% void MapInheritors (ID<_Choice> Id, string Tag) {
				case "#{Id}" : {
#if Id.Object.IsAbstract
					Out = null;
					throw new Exception ("Can't create abstract type");
#else
					Out = new #{Id} (); 
					// Out = #{Id}.Factory ();
					Out.Deserialize (JSONReader);
					break;
#end if
					}

#foreach (REF<_Choice> Ref in Id.REFs)
#switchcast ProtoStructType Ref.Object
#casecast Message Message
#% MapInheritors (Message.Id, Message.ID);
#casecast Structure Structure
#% MapInheritors (Structure.Id, Structure.ID);
#end switchcast
#end foreach
#%	}
#end block


#block DescriptionListC
#% public void DescriptionListC  (List<_Choice> Entries, int indent) {
#% Indentify (indent);
#if (indent > 0) 
/// <summary>
#end if
#% bool first = true;
#foreach (_Choice Entry in Entries)
#switchcast ProtoStructType Entry
#casecast Description Description
#if first
#% first = false;
#elseFstart
#% Indentify (indent);
///
#end if
#foreach (string s in Description.Text1)
#for (int i=0; i<indent; i++)
	#!
#end for
/// #{s}
#end foreach
#end switchcast
#end foreach
#% Indentify (indent);
#if (indent > 0) 
/// </summary>
#end if
#% }
#end block
#end xclass
