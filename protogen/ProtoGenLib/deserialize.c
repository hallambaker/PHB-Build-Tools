
#include <protogenlib\json_types.h>

END_PUBLIC_HEADERS
#include <protogenlib\common.h>

JSON_Object *Dump_Object;


static int match_tag_registry (JSON_Registry *Registry, int count, JSON_Minibuffer *buffer) {
	int i;
	for (i=JSON_TYPE_Intrinsics; i<count; i++) {
		if (buffer->index == Registry[i].Tag_Length) {
			//printf ("%s = %s\n", buffer->buffer, Registry[i].Tag);

			if (strcmp (buffer->buffer, Registry[i].Tag) == 0) {
				return i;
				}
			}
		}
	return -1;
	}


static int match_tag (JSON_Registry *Registry, JSON_Minibuffer *buffer) {
	int i;
	for (i=0; i<Registry->Count; i++) {
		if (buffer->index == Registry->Table[i].Tag_Length) {
			if (strcmp (buffer->buffer, Registry->Table[i].Tag) == 0) {
				return i;
				}
			}
		}
	return -1;
	}


static void minibuffer_add (JSON_Minibuffer *minibuffer, char c) {
	if (minibuffer->index < (JSON_SIZE_MINIBUFFER-1)) {
		minibuffer->buffer [minibuffer->index] = c;
		minibuffer->buffer [minibuffer->index+1] = 0;
		}
	else {
		minibuffer->overflow = true;
		}
	minibuffer->index++;

	if (IS_BASE64(c)) {
		minibuffer->count_b64 ++;
		}
	if (MASK_CHECK (c, 0x80, 0x00) | MASK_CHECK (c, 0xc0, 0xc0)) {
		minibuffer->count_utf8 ++;
		}

	}

static boolean minibuffer_compare (JSON_Minibuffer *minibuffer, char *test) {
	int i;
	for (i = 0; i<minibuffer->index; i++) {
		if (minibuffer->buffer[i] != test [i]) {
			return FALSE;
			}
		}
	return (test[i] == 0);	// match is true iff we are at the end of test
	}




//
//PUBLIC_ENTRY 	JSON_Deserialize (JSON_Context *Context, JSON_Parse *Parse, int count, void *Data) {
//	//JSON_Minibuffer *minibuffer;
//	int status;
//
//	//minibuffer = ALLOCATE (Context, JSON_Minibuffer);
//	//minibuffer->buffer[0] = 0;
//	//minibuffer->index = 0;
//
//	status = JSON_Deserialize_Parser ( Context, Parse, count, Data);
//
//	//FREE(minibuffer);
//
//	return status;
//	}

// I really should build a tool to generate this stuff from the FSR

// It would be much better to dispense with the character sets altogether 
// and either make the state transition an [X][256] array or work out how
// to do the transition collapsing algorithmically

#define CharType_Quote			0
#define CharType_LeftBrace		1 
#define CharType_RightBrace		2
#define CharType_LeftSquare		3 
#define CharType_RightSquare	4
#define CharType_Solidus		5
#define CharType_Zero			6
#define CharType_Digit			7
#define CharType_Period			8
#define CharType_Colon			9
#define CharType_Comma			10
#define CharType_Minus			11 
#define CharType_Plus			12
#define CharType_Ee				13
#define CharType_u				14
#define CharType_Escaped		15
#define CharType_Hex			16
#define CharType_Lower			17
#define CharType_WS				18
#define CharType_Other			19
#define CharType_COUNT			20

static int GetCharType(char c) {
    if (c == '\"') return CharType_Quote;
    if (c == '{') return CharType_LeftBrace;
    if (c == '}') return CharType_RightBrace;
    if (c == '[') return CharType_LeftSquare;
    if (c == ']') return CharType_RightSquare;
    if (c == '0') return CharType_Zero;
    if ((c >= '0') & (c <= '9')) return CharType_Digit;
    if (c == '.') return CharType_Period;
    if (c == ':') return CharType_Colon;
    if (c == ',') return CharType_Comma;
    if (c == '-') return CharType_Minus;
    if (c == '\\') return CharType_Solidus;
    if (c == '+') return CharType_Plus;            
    if ((c == 'e') | (c == 'E')) return CharType_Ee;
    if (c == 'u') return CharType_u;
    if  ((c == '/') | (c == 't') | (c == 'r') | (c == 'n') | (c == 'f') | (c == 'b'))  return CharType_Escaped;
    if ((c >= 'a') & (c <= 'f')) return CharType_Hex;
    if ((c >= 'A') & (c <= 'F')) return CharType_Hex;
    if ((c >= 'a') & (c <= 'z')) return CharType_Lower;  
    if ((c == ' ') | (c == '\t') | (c == '\r') | (c == '\n') | (c == '\f') | (c == '\b')) return CharType_WS;        
    return CharType_Other;
    }


//
// Again, this really, really should be generated by a tool. 
//

 static int States [][CharType_COUNT]   =      
    {
        // ",  {,  },  [,  ],  \,  0, 19,  .,  :,  ,,  -,  +, Ee,  u,esc,hex, az, WS, *   
        { 15,  1,  2,  3,  4, -1,  7,  9, -1, 25,  6,  8, -1,  5,  5,  5,  5,  5,  0, -1}, //  0 Start - eat WS
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 1 StartObject
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  2 EndObject
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  3 StartArray
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  4 EndArray

        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,  5,  5,  5,  5,  5, -1, -1}, //  5 Litteral
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  6 Comma
             
        // Number
        { -1, -1, -1, -1, -1, -1, 26, 26, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  7  "0"
        { -1, -1, -1, -1, -1, -1,  7,  9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, //  8  "-"           
        { -1, -1, -1, -1, -1, -1,  9,  9, 10, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1}, //  9  "[-]999"           
        { -1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 10  "[-]999."         
        { -1, -1, -1, -1, -1, -1, 11, 11, -1, -1, -1, -1, -1, 12, -1, -1, -1, -1, -1, -1}, // 11  "[-]999.99"         
        { -1, -1, -1, -1, -1, -1, 14, 14, -1, -1, -1, 13, 13, -1, -1, -1, -1, -1, -1, -1}, // 12  "[-]999[.99]E"           
        { -1, -1, -1, -1, -1, -1, 14, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 13  "[-]999[.99]E+"
        { -1, -1, -1, -1, -1, -1, 14, 14, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 14  "[-]999[.99]E[+]99"
            
        // String
        { 24, 16, 16, 16, 16, 17, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16}, // 15   "         
        { 24, 16, 16, 16, 16, 17, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16}, // 16   "a[aaaa]
        { 23, -1, -1, -1, -1, 23, -1, -1, -1, -1, -1, -1, -1, -1, 18, 23, -1, -1, -1, -1}, // 17   "a[aaaa]\ 
        { -1, -1, -1, -1, -1, -1, 19, 19, -1, -1, -1, -1, -1, 19, -1, 19, 19, -1, -1, -1}, // 18   "a[aaaa]\u
        { -1, -1, -1, -1, -1, -1, 19, 20, -1, -1, -1, -1, -1, 20, -1, 20, 20, -1, -1, -1}, // 19   "a[aaaa]\u0
        { -1, -1, -1, -1, -1, -1, 21, 21, -1, -1, -1, -1, -1, 21, -1, 21, 21, -1, -1, -1}, // 20   "a[aaaa]\u01
        { -1, -1, -1, -1, -1, -1, 22, 22, -1, -1, -1, -1, -1, 22, -1, 22, 22, -1, -1, -1}, // 21   "a[aaaa]\u0123
        { 24, 16, 16, 16, 16, 17, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16}, // 22   "a[aaa]\\ 
        { 24, 16, 16, 16, 16, 17, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16}, // 23   "a[aaa]\\ 
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1}, // 24   "[aaaa][\\][aaaa]
        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1},  // 25  Colon
        { -1, -1, -1, -1, -1, -1, -1, 26, 26, -1, -1, 26, 26, 26, -1, -1, -1, -1, -1, -1}  // 26    Invalid number
    };


#define Action_Ignore			0
#define Action_Add				1
#define Action_AddHex			2
#define Action_Escape			3
#define Action_LastHex			4
#define Action_Complete			5
#define Action_AddComplete		6


static int Actions []  = {
    Action_Ignore,          //  0
    Action_AddComplete,     //  1
    Action_AddComplete,     //  2
    Action_AddComplete,     //  3
    Action_AddComplete,     //  4
    Action_AddComplete,     //  5
    Action_AddComplete,     //  6
    Action_AddComplete,     //  7
    Action_Add,             //  8
    Action_AddComplete,     //  9
    Action_Add,             // 10 
    Action_AddComplete,     // 11
    Action_Add,             // 12
    Action_Add,             // 13
    Action_AddComplete,     // 14
    Action_Ignore,          // 15
    Action_Add,             // 16
    Action_Ignore,          // 17
    Action_Ignore,          // 18
    Action_AddHex,          // 19
    Action_AddHex,          // 20
    Action_AddHex,          // 21
    Action_LastHex,         // 22
    Action_Escape,          // 23
    Action_Complete,        // 24
    Action_AddComplete,     // 25
    Action_Ignore           // 26

    };


#define Token_Invalid			0
#define Token_StartObject		1
#define Token_EndObject			2
#define Token_StartArray		3
#define Token_EndArray			4
#define Token_Colon				5
#define Token_Comma				6
#define Token_String			7
#define Token_Number			8
#define Token_Litteral			9
#define Token_True				10
#define Token_False				11
#define Token_Null				12
#define Token_Empty				13




static int Tokens [] = {
    Token_Empty,                //  0
    Token_StartObject,          //  1
    Token_EndObject,            //  2
    Token_StartArray,           //  3
    Token_EndArray,             //  4                               
    Token_Litteral,             //  5
    Token_Comma,                //  6
    Token_Number,               //  7         
    Token_Number,               //  8
    Token_Number,               //  9
    Token_Invalid,              // 10                                 
    Token_Number,               // 11
    Token_Number,               // 12
    Token_Number,               // 13          
    Token_Number,               // 14             
    Token_String,               // 15 
    Token_String,               // 16 
    Token_String,               // 17 
    Token_String,               // 18 
    Token_String,               // 19 
    Token_String,               // 20
    Token_String,               // 21
    Token_String,               // 22
    Token_String,               // 23
    Token_String,               // 24
    Token_Colon,                // 25
    Token_Invalid               // 26
                            };

static int HexCharToInt(char c) {
    if ((c>='0') & (c<='9')) return ((int)c - (int)'0');
    if ((c>='a') & (c<='f')) return (10 + (int)c - (int)'a');
    if ((c>='A') & (c<='F')) return (10 + (int)c - (int)'A');   
    return -1;
    }

static int is_value (int x) {
	return ((x == Token_String) | (x == Token_Number) | (x == Token_True) |
			(x == Token_False) | (x == Token_Null));

	}

#define PState_Start		0
#define PState_LBrace		1
#define PState_String		2
#define PState_Colon		3
#define PState_Value		4
#define PState_Array		6
#define PState_ArrayValue	7
#define PState_ArrayComma	8
#define PState_RBrace		1024 // is always the highest state

//typedef struct _Stack {
//	int				State;
//	JSON_Parse		*Parse;
//	void			*Data;
//	} Stack;


static void Push (JSON_Parse_Stack *stack, int State, JSON_Registry *Registry, void *Data, 
		int *pointer, int slot) {
	stack[*pointer].Registry = Registry;
	stack[*pointer].State = State;
	stack[*pointer].Data = Data;
	stack[*pointer].Slot = slot;
	(*pointer) ++;
	}

static void Pop (JSON_Parse_Stack *stack, int *State, JSON_Registry **Registry, void **Data, 
		int *pointer, int *slot) {
	(*pointer) --;
	if (pointer <0) return;

	*Registry = stack[*pointer].Registry;
	*State = stack[*pointer].State;
	*Data = stack[*pointer].Data;
	*slot = stack[*pointer].Slot;

	}

PUBLIC_ENTRY JSON_Deserialize (JSON_Context *Context, JSON_Registry *Registry, 
				void *Data) {
	BEGIN;

	JSON_Deserialize_Parse(Context, Registry, Data);

	END;
	}


//typedef union _KeystoreAll = {
//	KeyStore_KeyEntry		KeyEntry;
//	KeyStore_FileEntry		FileEntry;
//	KeyStore_Phinger		Phinger;
//	KeyStore_PublicKey		PublicKey;
//	KeyStore_Keydata		KeyData;
//	KeyStore_PGP			PGP;
//	KeyStore_Key			Key;
//	KeyStore_Certificate	Certificate;
//	KeyStore_Purpose		Purpose;
//	KeyStore_Policy			Policy;
//	} ;

PUBLIC_ENTRY JSON_Deserialize_Object (JSON_Context *Context, void **Data_out, Boolean Multiple) {
	JSON_Stream *Stream = Context->Stream;
	JSON_Minibuffer *minibuffer = Context->Minibuffer;
	JSON_Registry *Registry = NULL;
	JSON_Object *Data, *Last = NULL;
	JSON_Parse_Stack *stack = Context->Stack;
	int stack_pointer = 0;

	int got_token = 0;
	int token;

	int Pstate = PState_Start;
	int Parse;

	BEGIN;

	while ((got_token >= 0) & (Multiple | (Pstate < PState_RBrace ))){

		got_token = JSON_Deserialize_Lexer (Stream, minibuffer);
		token = minibuffer->Token;
		Context->Last_Token = token;
		//printf ("%d / %s  : %d\n", token, minibuffer->buffer, Pstate);
		//PHB_Dump_Phinger ();

		switch (Pstate) {
			case PState_Start: {
				if (token == Token_StartObject) {
					Pstate = PState_LBrace;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_LBrace: { 
				if (token == Token_EndObject) {

					Pstate = PState_RBrace; 

					}
				else if (token == Token_String) {
					Pstate = PState_String;
					
					Parse = match_tag_registry (Context->Registry, Context->Count, minibuffer);
					if (Parse <0) return -1;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_String: { 
				if (token == Token_Colon) {

					JSON_Registry *Registry = Context->Registry + Parse;
					Pstate = PState_Value;

					Registry->Create (Context, (void**) &Data);
					JSON_Deserialize_Parse (Context, Registry, Data);
					
					if (Last == NULL) {
						*Data_out = Data;
						}
					else {
						Last->_Next = Data;
						}
					Last = Data;

					}
				else {
					return -1;
					}
				break;
				}

			case PState_Value: { 
				if (token == Token_EndObject) {
					Pstate = PState_RBrace; 
					}

				// Should make use of this to return a list of objects
				//else if (token == Token_Comma) {
				//	Pstate = PState_LBrace;
				//	}
				else {
					return -1;
					}
				break;
				}
			case PState_RBrace: { 
				if (token == Token_Comma)  {
					Pstate = PState_Start;
					}
				else if (token == Token_StartObject)  {
					Pstate = PState_LBrace;
					}
				else {
					return -1;
					}
				break;
				}

			}

		}
	

	END;
	}


//
// This parser is so simple that it does not require a tool
//
// The same parser can be used for JSON-B
// Support for JSON-C and JSON-D requires one extra transition to permit 
// dictionary entries to be declared.
//
//PUBLIC_ENTRY JSON_Deserialize_Parse (JSON_Context *Context, JSON_Parse *Parse, int count, 
//				void *Data) {
					
					
PUBLIC_ENTRY JSON_Deserialize_Parse (JSON_Context *Context, JSON_Registry *Registry, 
				void *Data) {

	JSON_Stream *Stream = Context->Stream;
	JSON_Minibuffer *minibuffer = Context->Minibuffer;
	JSON_Parse_Stack *stack = Context->Stack;

	int stack_pointer = 0;

	int got_token = 0;
	int token;

	int Pstate = PState_Start;
	int slot = -1;


	//Stack *stack;
	BEGIN;
	
	//JSON_Allocate (Context, sizeof (Stack) * Context->MaxNested, (void**) &stack);

	//if (Data_Ptr != NULL) {
	//	Data = *Data_Ptr
	//	}

	while ((got_token >= 0) & (Pstate < PState_RBrace )){
		if ((stack_pointer >= Context->MaxNested) | (stack_pointer < 0)) {
			return -1;
			}

		got_token = JSON_Deserialize_Lexer (Stream, minibuffer);
		token = minibuffer->Token;
		Context->Last_Token = token;
		//printf ("%d / %s  : %d\n", token, minibuffer->buffer, Pstate);
		//PHB_Dump_Phinger ();

		switch (Pstate) {
			case PState_Start: {
				if (token == Token_StartObject) {
					Pstate = PState_LBrace;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_LBrace: { 
				if (token == Token_EndObject) {
					if (stack_pointer > 0) {
						Pop (stack, &Pstate, &Registry, &Data, &stack_pointer, &slot);
						}
					else {
						Pstate = PState_RBrace; 
						}
					}
				else if (token == Token_String) {
					Pstate = PState_String;
					slot = match_tag (Registry, minibuffer);
					}
				else {
					return -1;
					}
				break;
				}
			case PState_String: { 
				if (token == Token_Colon) {
					Pstate = PState_Colon;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_Colon: { 
				if (is_value(token)) { 
					Pstate = PState_Value;
					if (slot >= 0) {
						JSON_Deserialize_Fill (Context, Registry->Table+slot, Data);
						}
					}
				else if (token == Token_StartObject) {
					JSON_Parse *Parse = Registry->Table + slot;

					Push (stack, PState_Value, Registry, Data, &stack_pointer, slot);

					Registry = Context->Registry + Parse->Type;
					JSON_Deserialize_Create (Parse, Registry, Context, Data, &Data);

					Pstate = PState_LBrace;
					}
				else if (token == Token_StartArray) {
					Pstate = PState_Array;
					}
				else {
					return -1;
					}
				break;
				}

			case PState_Array : { 
				if (is_value(token)) { 
					Pstate = PState_ArrayValue;
					JSON_Deserialize_Add (Context, Registry->Table+slot, Data);
					}
				else if (token == Token_EndArray) {
					Pstate = PState_Value;
					}
				else if (token == Token_StartObject) {
					void *NewData;
					JSON_Parse *Parse = Registry->Table + slot;

					Push (stack, PState_ArrayValue, Registry, Data, &stack_pointer, slot);
							
					JSON_Deserialize_Create_Add (Context, Parse, Data, &NewData);
					Registry = Context->Registry + Parse->Type;	

					Pstate = PState_LBrace;
					Data = NewData;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_ArrayValue : { 
				if (token == Token_Comma) { 
					Pstate = PState_ArrayComma;
					}
				else if (token == Token_EndArray) {
					Pstate = PState_Value;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_ArrayComma : { 
				if (is_value(token)) { 
					Pstate = PState_ArrayValue;
					JSON_Deserialize_Add (Context, Registry->Table+slot, Data);
					}
				else if (token == Token_StartObject) {
					void *NewData;
					JSON_Parse *Parse = Registry->Table + slot;

					Push (stack, PState_ArrayValue, Registry, Data, &stack_pointer, slot);
					
					JSON_Deserialize_Create_Add (Context, Parse, Data, &NewData);
					Registry = Context->Registry + Parse->Type;

					Pstate = PState_LBrace;
					Data = NewData;
					}
				else if (token == Token_EndArray) {
					Pstate = PState_Value;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_Value: { 
				if (token == Token_EndObject) {
					if (stack_pointer > 0) {
						Pop (stack, &Pstate, &Registry, &Data, &stack_pointer, &slot);
						}
					else {
						Pstate = PState_RBrace; 
						}
					}
				else if (token == Token_Comma) {
					Pstate = PState_LBrace;
					}
				else {
					return -1;
					}
				break;
				}
			case PState_RBrace: { 

				break;
				}
			}

		}

	END;
	}



PUBLIC_ENTRY JSON_Deserialize_Add (JSON_Context *Context, JSON_Parse *Parse, void *Data) {
	
	JSON_Group *Slot ;
	JSON_Object *Object;
	JSON_Minibuffer *minibuffer = Context->Minibuffer;
	//JSON_Registry *Registry = Context->Registry;
	BEGIN;

	Slot = (JSON_Group*) OFFSET_CAST(Data, Parse->Offset);
	
	if (Parse->Type == JSON_TYPE_Boolean) {
		JSON_Object_Create_Boolean (Context, TRUE, &Object);
		JSON_Context_Read_Boolean (Context, &Object->As.Boolean);
		JSON_Object_Add (Slot, Object);
		}
	else if (Parse->Type == JSON_TYPE_Int64) {
		JSON_Object_Create_Int64 (Context, 1, &Object);
		JSON_Context_Read_Int64 (Context, &Object->As.Integer);
		JSON_Object_Add (Slot, Object);
		}
	else if (Parse->Type == JSON_TYPE_Real64) {
		JSON_Object_Create_Real64 (Context, 1.1, &Object);
		JSON_Context_Read_Real64 (Context, &Object->As.Float);
		JSON_Object_Add (Slot, Object);
		}
	else if (Parse->Type == JSON_TYPE_String) {
		JSON_Object_Create_String (Context, &Object);
		JSON_Context_Read_String (Context, &Object->As.String);
		JSON_Object_Add (Slot, Object);
		}
	else if (Parse->Type == JSON_TYPE_Binary) {
		JSON_Object_Create_Binary (Context, &Object);
		JSON_Context_Read_Binary (Context, &Object->As.Binary);
		JSON_Object_Add (Slot, Object);
		}
	else if (Parse->Type == JSON_TYPE_DateTime) {
		JSON_Object_Create_String (Context, &Object);
		JSON_Context_Read_DateTime (Context, &Object->As.DateTime);
		JSON_Object_Add (Slot, Object);
		}
	



	END;
	}


PUBLIC_ENTRY JSON_Deserialize_Create_Add (JSON_Context *Context, JSON_Parse *Parse,  
			void *Data, void ** NewData) {
	

	JSON_Object *Object = NULL; // This is actually the superclass				
	JSON_Group *Slot; // = (JSON_Group*) OFFSET_CAST(Data, Parse->Offset);
	JSON_Registry *Registry; // = Context->Registry;


	BEGIN;

	Slot = (JSON_Group*) OFFSET_CAST(Data, Parse->Offset);
	Registry = Context->Registry + Parse->Type;

	ASSERT (Parse->Type >0, -1, "Registry error");

	Registry->Create (Context, (void**) &Object);
	JSON_Object_Add (Slot, Object);
	*NewData = Object;

	END;
	}


PUBLIC_ENTRY JSON_Deserialize_Create (JSON_Parse *Parse, JSON_Registry *Registry, 
			JSON_Context *Context, void *Data, void ** NewData) {
	void **Slot ;

	void *Obj;
	BEGIN;

	Slot = (void**) OFFSET_CAST(Data, Parse->Offset);

	ASSERT (Parse->Type >0, -1, "Registry error");


	Registry->Create (Context, &Obj);
	*Slot = Obj;
	*NewData = Obj;

	END;
	}

PUBLIC_ENTRY JSON_Deserialize_Fill (JSON_Context *Context, JSON_Parse *Parse, void *Data) {
			
	BEGIN;

	if (Parse->Type == JSON_TYPE_Boolean) {
		boolean *Slot = (boolean*) OFFSET_CAST(Data, Parse->Offset);
		JSON_Context_Read_Boolean (Context, Slot);
		}
	else if (Parse->Type == JSON_TYPE_Int64) {
		Int64 *Slot = (Int64*) OFFSET_CAST(Data, Parse->Offset);
		JSON_Context_Read_Int64 (Context, Slot);
		}
	else if (Parse->Type == JSON_TYPE_Real64) {
		Real64 *Slot = (double*) OFFSET_CAST(Data, Parse->Offset);
		JSON_Context_Read_Real64 (Context, Slot);
		}
	else if (Parse->Type == JSON_TYPE_String) {
		JSON_String *Slot = (JSON_String*) OFFSET_CAST(Data, Parse->Offset);
		JSON_Context_Read_String (Context, Slot);
		}
	else if (Parse->Type == JSON_TYPE_Binary) {
		JSON_Binary *Slot = (JSON_Binary *) OFFSET_CAST(Data, Parse->Offset);
		JSON_Context_Read_Binary (Context, Slot);
		}
	else if (Parse->Type == JSON_TYPE_DateTime) {
		JSON_DateTime *Slot = (JSON_DateTime*) OFFSET_CAST(Data, Parse->Offset);
		JSON_Context_Read_DateTime (Context, Slot);
		}

	

	END;
	}

PUBLIC_ENTRY JSON_Deserialize_Lexer (JSON_Stream *Stream, JSON_Minibuffer *minibuffer) {
    //string result = "";
    int			GotToken = 0;
    boolean		Complete = false;
    int			Hex = 0;
    int			State = 0;

    char c;
	int Type;

    minibuffer->index = 0;
	minibuffer->count_b64 = 0;
	minibuffer->count_utf8 = 0;
	minibuffer->overflow = false;
	minibuffer->Token = Token_Invalid;
	JSON_Stream_Mark (Stream);

	while ( GotToken >= 0 ) {
		GotToken = JSON_Stream_Peek_Char (Stream, &c);

		if (GotToken < 0) {		// End of stream
            if (State == 0) {
                minibuffer->Token = Token_Empty;
                return -1;
                }
			else { 
				Type = CharType_WS;
				}
            }
		else {
			Type = (int) GetCharType (c);
			}

        State = States [State][Type];

        if (State < 0) {
            if (!Complete) {
                minibuffer->Token = Token_Empty;
                return -1;
                }
            else if (minibuffer->Token == Token_Litteral) {
                if (minibuffer_compare (minibuffer, "true")) {
                    minibuffer->Token = Token_True;
                    }
                else if (minibuffer_compare (minibuffer, "false")) {
                    minibuffer->Token = Token_False;
                    }
                else if (minibuffer_compare (minibuffer, "null")) {
                    minibuffer->Token = Token_Null;
                    }
                else {
                    minibuffer->Token = Token_Invalid;
                    }
                }
            return 0;
            }
        minibuffer->Token = Tokens [State];

        GotToken = JSON_Stream_Get_Char (Stream, &c);
		DEBUG_PRINT (("%c", c));

        switch (Actions[State]) {
            case Action_Ignore: {
                break;
                }
            case Action_Add: {
				minibuffer_add (minibuffer, c);
                break;
                }
            case Action_AddHex: {
                Hex = 16*Hex + HexCharToInt (c);
                break;
                }
            case Action_LastHex: {
                Hex = 16*Hex + HexCharToInt (c);
				minibuffer_add (minibuffer, (char) Hex);
                break;
                }
            case Action_Escape: {
                char ec;
                switch (c) {
                    case '\"' : { ec = '\"'; break ; }
                    case '\\' : { ec = '\\'; break ; }
                    case '/' : { ec = '/'; break ; }
                    case 'f' : { ec = '\f'; break ; }
                    case 'b' : { ec = '\b'; break ; }
                    case 'n' : { ec = '\n'; break ; }
                    case 'r' : { ec = '\r'; break ; }
                    case 't' : { ec = '\t'; break ; }
                    default : {ec = (char) 0; break ; }
                    }
                minibuffer_add (minibuffer,  ec);
                break;
                }
            case Action_Complete: {
                Complete = true;
                break;
                }
            case Action_AddComplete: {
                Complete = true;
                minibuffer_add (minibuffer,  c);
                break;
                }
            }
        }

    return 0;
    }




	
PUBLIC_ENTRY JSON_Context_Read_Boolean (JSON_Context *Context, Boolean *Data) {
	BEGIN;

	switch (Context->Last_Token) {
		case Token_True : 
			*Data = TRUE;
			break;
		case Token_False : 
			*Data = FALSE;
			break;
		default :
			*Data = Boolean_NaN;
			break;
		}

	END;
	}


PUBLIC_ENTRY JSON_Context_Read_Int64 (JSON_Context *Context, Int64 *Data) {
	BEGIN;

	if (Context->Last_Token == Token_Null) {
		*Data = Int64_NaN;
		return 0;
		}

	if (Context->Last_Token != Token_Number) {
		*Data = Int64_NaN;
		return 0;
		}

	*Data = atol (Context->Minibuffer->buffer);

	END;
	}

PUBLIC_ENTRY JSON_Context_Read_Real64 (JSON_Context *Context, Real64 *Data) {
	BEGIN;

	if (Context->Last_Token == Token_Null) {
		*Data = Real64_NaN;
		return 0;
		}

	if (Context->Last_Token != Token_Number) {
		*Data = Int64_NaN;
		return 0;
		}

	*Data = atof (Context->Minibuffer->buffer);

	END;
	}

PUBLIC_ENTRY JSON_Context_Read_String (JSON_Context *Context, JSON_String *Data) {
	BEGIN;

	if (Context->Last_Token != Token_String) {
		Data->Data = NULL;
		Data->Length = -1;
		Data->Allocated = -1;
		return 0;
		}

	if (Context->Minibuffer->overflow) {
		char c = 0;
		JSON_Stream_Rewind (Context->Stream);

		Data->Allocated = Context->Minibuffer->index;
		Data->Length = 0;
		JSON_Allocate (Context, Data->Allocated+1, (void**) &Data->Data);

		while ((c != '"') & (Data->Length < Data->Allocated)){
			JSON_Stream_Get_Char (Context->Stream, &c);
			//printf ("%c", c);
			Data->Data[Data->Length++] = c;
			}

		if (c != '"') {
			JSON_Stream_Get_Char (Context->Stream, &c);
			}

		Data->Data[Data->Length] = 0;
		DEBUG_PRINT (("\n"));
		}
	else {
		JSON_String_By_Zstring (Context, Context->Minibuffer->buffer, Data);
		}


	END;
	}

PUBLIC_ENTRY JSON_Context_Read_Binary (JSON_Context *Context, JSON_Binary *Data) {
	char c;
	BEGIN;

	if (Context->Last_Token != Token_String) {
		Data->Data = NULL;
		Data->Length = -1;
		return 0;
		}

	Data->Length = 0;
	Data->Allocated = 3 * (Context->Minibuffer->count_b64 / 4) + 8;
	JSON_Allocate (Context, Data->Allocated+1, (void**) &Data->Data);

	JSON_Stream_Rewind (Context->Stream);
	JSON_Stream_Get_Char (Context->Stream, &c);
	JSON_Stream_Read_Binary (Context->Stream, Data);

	END;
	}


PUBLIC_ENTRY JSON_Context_Read_DateTime (JSON_Context *Context, JSON_DateTime *Data) {
	BEGIN;

	if (Context->Last_Token != Token_String) {
		Data->Data = NULL;
		Data->Length = -1;
		return 0;
		}

	if (Context->Minibuffer->overflow) {
		char c = 0;
		JSON_Stream_Rewind (Context->Stream);


		Data->Allocated = Context->Minibuffer->index;
		Data->Length = 0;
		JSON_Allocate (Context, Data->Allocated+1, (void**) &Data->Data);

		while ((c != '"') & (Data->Length < Data->Allocated)){
			JSON_Stream_Get_Char (Context->Stream, &c);
			//printf ("%c", c);
			Data->Data[Data->Length++] = c;
			}

		if (c != '"') {
			JSON_Stream_Get_Char (Context->Stream, &c);
			}

		Data->Data[Data->Length] = 0;
		DEBUG_PRINT (("\n"));
		}
	else {
		JSON_DateTime_Decode (Context, Context->Minibuffer->buffer, Data);
		}


	END;
	}