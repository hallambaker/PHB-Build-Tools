
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;




//
// Namespace Goedel.Tool.RegistryConfig
// Class ConfigItems
//


// Types
//   TopTypeType
//       Class
//   TypeType
//       Field
//       String
//       Int
//       Binary
//       AltID
//   IdType
//       FieldType
//   NamespaceType
//       Goedel.Tool.RegistryConfig
//   ClassType
//       ConfigItems
//   NameType
//       Namespace
//       Id
//       Fields
//       Type
//       Options
//       Name
//   TokenType
//       ClassType

#pragma warning disable IDE0022
namespace Goedel.Tool.RegistryConfig {


    public enum ConfigItemsType {
        _Top,

        Class,
        Field,
        AltID,
        String,
        Int,
        Binary,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public ConfigItemsType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);

		public virtual void Init (_Choice Parent) {
			}

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice Parent) {
			Init (Parent);
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Class : _Choice {
        public TOKEN<_Choice>			Namespace;
        public ID<_Choice>				Id; 
        public List <Field>           Fields = new List<Field> ();

        public override ConfigItemsType _Tag () =>ConfigItemsType.Class;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Fields) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Class");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (Field _e in Fields) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Class");
				}			
			}
		}

    public partial class Field : _Choice {
        public ID<_Choice>				Id; 
        public _Choice					Type;
        public List <_Choice>           Options = new List<_Choice> ();

        public override ConfigItemsType _Tag () =>ConfigItemsType.Field;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			Type._InitChildren (this);
			foreach (var Sub in Options) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Field");
				}

	        Output.WriteId ("Id", Id.ToString()); 
	        Type.Serialize (Output, true);
			Output.StartList ("");
			foreach (_Choice _e in Options) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Field");
				}			
			}
		}

    public partial class AltID : _Choice {
		public string					Name;

        public override ConfigItemsType _Tag () =>ConfigItemsType.AltID;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("AltID");
				}

			Output.WriteAttribute ("Name", Name);
			if (tag) {
				Output.EndElement ("AltID");
				}			
			}
		}

    public partial class String : _Choice {

        public override ConfigItemsType _Tag () =>ConfigItemsType.String;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class Int : _Choice {

        public override ConfigItemsType _Tag () =>ConfigItemsType.Int;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Int");
				}

			if (tag) {
				Output.EndElement ("Int");
				}			
			}
		}

    public partial class Binary : _Choice {

        public override ConfigItemsType _Tag () =>ConfigItemsType.Binary;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Binary");
				}

			if (tag) {
				Output.EndElement ("Binary");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() =>  Label = null;

        public override ConfigItemsType _Tag () => ConfigItemsType._Label;

		public override void Serialize (StructureWriter Output, bool tag) =>Output.WriteId ("ID", Label.ToString());
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Class_Start,
		Class__Namespace,				
		Class__Id,				
		Class__Fields,				
		Field_Start,
		Field__Id,				
		Field__Type,				
		Field__Options,				
		AltID_Start,
		AltID__Name,				
		String_Start,
		Int_Start,
		Binary_Start,
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Tool.RegistryConfig._Choice     Token;
        }

    public partial class ConfigItems : Goedel.Registry.Parser{
        public List <Goedel.Tool.RegistryConfig._Choice>        Top;
        public Registry	<Goedel.Tool.RegistryConfig._Choice>	Registry;

        public bool StartOfEntry {get;  private set;}

        StateCode								State;
        Goedel.Tool.RegistryConfig._Choice				Current;
        List <_StackItem>						Stack;


        public static ConfigItems Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new ConfigItems() {
				Options = Options
				};

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
				Entry._InitChildren (null);
				}
			}

        public ConfigItems() {
            Top = new List<Goedel.Tool.RegistryConfig._Choice> () ;
            Registry = new Registry <Goedel.Tool.RegistryConfig._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            StartOfEntry = true;

			TYPE__FieldType = Registry.TYPE ("FieldType"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 



            }



        public TYPE<Goedel.Tool.RegistryConfig._Choice> TYPE__FieldType ;
        public TYPE<Goedel.Tool.RegistryConfig._Choice> TYPE__ClassType ;

        private Goedel.Tool.RegistryConfig._Choice New_Choice(string Label) {
            switch (Label) {

                case "Class": return NewClass();
                case "Field": return NewField();
                case "AltID": return NewAltID();
                case "String": return NewString();
                case "Int": return NewInt();
                case "Binary": return NewBinary();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Tool.RegistryConfig.Class NewClass() {
            Goedel.Tool.RegistryConfig.Class result = new Goedel.Tool.RegistryConfig.Class();
            Push (result);
            State = StateCode.Class_Start;
            return result;
            }


        private Goedel.Tool.RegistryConfig.Field NewField() {
            Goedel.Tool.RegistryConfig.Field result = new Goedel.Tool.RegistryConfig.Field();
            Push (result);
            State = StateCode.Field_Start;
            return result;
            }


        private Goedel.Tool.RegistryConfig.AltID NewAltID() {
            Goedel.Tool.RegistryConfig.AltID result = new Goedel.Tool.RegistryConfig.AltID();
            Push (result);
            State = StateCode.AltID_Start;
            return result;
            }


        private Goedel.Tool.RegistryConfig.String NewString() {
            Goedel.Tool.RegistryConfig.String result = new Goedel.Tool.RegistryConfig.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private Goedel.Tool.RegistryConfig.Int NewInt() {
            Goedel.Tool.RegistryConfig.Int result = new Goedel.Tool.RegistryConfig.Int();
            Push (result);
            State = StateCode.Int_Start;
            return result;
            }


        private Goedel.Tool.RegistryConfig.Binary NewBinary() {
            Goedel.Tool.RegistryConfig.Binary result = new Goedel.Tool.RegistryConfig.Binary();
            Push (result);
            State = StateCode.Binary_Start;
            return result;
            }


        static Goedel.Tool.RegistryConfig.ConfigItemsType _Reserved(string Label) {
            switch (Label) {

                case "Class": return Goedel.Tool.RegistryConfig.ConfigItemsType.Class;
                case "Field": return Goedel.Tool.RegistryConfig.ConfigItemsType.Field;
                case "AltID": return Goedel.Tool.RegistryConfig.ConfigItemsType.AltID;
                case "String": return Goedel.Tool.RegistryConfig.ConfigItemsType.String;
                case "Int": return Goedel.Tool.RegistryConfig.ConfigItemsType.Int;
                case "Binary": return Goedel.Tool.RegistryConfig.ConfigItemsType.Binary;

                }
            return Goedel.Tool.RegistryConfig.ConfigItemsType._Bottom;
            }


		public void Serialize (TextWriter Output)=> Serialize (Output, OutputFormat.Goedel);

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Tool.RegistryConfig._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Tool.RegistryConfig._Choice Token) {
            _StackItem Item = new _StackItem () {
					State = State,
					Token = Current
					};

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.False (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.False (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Tool.RegistryConfig.ConfigItemsType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Tool.RegistryConfig.ConfigItemsType.Class)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Class_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.RegistryConfig.Class Current_Cast = (Goedel.Tool.RegistryConfig.Class)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Namespace;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Class__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.RegistryConfig.Class Current_Cast = (Goedel.Tool.RegistryConfig.Class)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.Class__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Class__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Class__Fields;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Class__Fields: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.RegistryConfig.Class Current_Cast = (Goedel.Tool.RegistryConfig.Class)Current;
                            Current_Cast.Fields.Add (NewField ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Field_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.RegistryConfig.Field Current_Cast = (Goedel.Tool.RegistryConfig.Field)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Field__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Field__Id:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.RegistryConfig.Field Current_Cast = (Goedel.Tool.RegistryConfig.Field)Current;
                            Goedel.Tool.RegistryConfig.ConfigItemsType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.RegistryConfig.ConfigItemsType.String) |
									(LabelType == Goedel.Tool.RegistryConfig.ConfigItemsType.Int) |
									(LabelType == Goedel.Tool.RegistryConfig.ConfigItemsType.Binary) ) {
                                State = StateCode.Field__Type;
                                Current_Cast.Type = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [String Int Binary ]");
                                }
                            break;
                            }
                        else {
                            throw new Expected("Parser Error Expected [String Int Binary ]");
                            }

                    case StateCode.Field__Type:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Field__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Field__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.RegistryConfig.Field Current_Cast = (Goedel.Tool.RegistryConfig.Field)Current;
                            Goedel.Tool.RegistryConfig.ConfigItemsType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.RegistryConfig.ConfigItemsType.AltID) |
									(LabelType == Goedel.Tool.RegistryConfig.ConfigItemsType.AltID) ) {
                                Current_Cast.Options.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [AltID AltID ]");
								}
							}
                        break;


                    case StateCode.AltID_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.RegistryConfig.AltID Current_Cast = (Goedel.Tool.RegistryConfig.AltID)Current;
                            Current_Cast.Name = Text;
                            State = StateCode.AltID__Name;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.AltID__Name:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.String_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Int_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Binary_Start:
                        Pop ();
                        Represent = true; 
                        break;

                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}
#pragma warning restore IDE0022	

