
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;


//
// Namespace Goedel.Trojan
// Class GUISchema
//


// Types
//   TopTypeType
//       GUI
//   TypeType
//       Window
//       Wizard
//       Dialog
//       Operations
//       Heading
//       Text
//       Horizontal
//       Vertical
//       Action
//       Task
//       Next
//       Input
//       Output
//       Close
//       Validate
//       File
//       String
//   IdType
//       WidgetType
//       EntryType
//   NamespaceType
//       Goedel.Trojan
//   ClassType
//       GUISchema
//   NameType
//       Namespace
//       Entries
//       Id
//       Tag
//       Steps
//       Data
//       Label
//       Target
//   TokenType
//       ClassType

namespace Goedel.Trojan {


    public enum GUISchemaType {
        _Top,

        GUI,
        Window,
        Wizard,
        Dialog,
        Operations,
        Heading,
        Text,
        Horizontal,
        Vertical,
        Action,
        Task,
        Next,
        Input,
        Output,
        File,
        String,
        Validate,
        Close,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public GUISchemaType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);
        }



    public partial class GUI : _Choice {
        public TOKEN<_Choice>			Namespace;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.GUI;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("GUI");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("GUI");
				}			
			}
		}

    public partial class Window : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Window;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Window");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Window");
				}			
			}
		}

    public partial class Wizard : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Wizard;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Wizard");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Wizard");
				}			
			}
		}

    public partial class Dialog : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Dialog;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Dialog");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Dialog");
				}			
			}
		}

    public partial class Operations : _Choice {
        public List <REF<_Choice>>           Steps = new List<REF<_Choice>> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Operations;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Operations");
				}

			Output.StartList ("");
			foreach (REF<_Choice> _e in Steps) {
				Output.WriteId ("Steps", _e.ToString());
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Operations");
				}			
			}
		}

    public partial class Heading : _Choice {
		public List <System.String>			Data = new List <System.String> (); 

        public override GUISchemaType _Tag () {
            return GUISchemaType.Heading;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Heading");
				}

			foreach (string _s in Data) {
				Output.WriteAttribute ("Data",_s);
				}
			if (tag) {
				Output.EndElement ("Heading");
				}			
			}
		}

    public partial class Text : _Choice {
		public List <System.String>			Data = new List <System.String> (); 

        public override GUISchemaType _Tag () {
            return GUISchemaType.Text;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Text");
				}

			foreach (string _s in Data) {
				Output.WriteAttribute ("Data",_s);
				}
			if (tag) {
				Output.EndElement ("Text");
				}			
			}
		}

    public partial class Horizontal : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Horizontal;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Horizontal");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Horizontal");
				}			
			}
		}

    public partial class Vertical : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Vertical;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Vertical");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Vertical");
				}			
			}
		}

    public partial class Action : _Choice {
        public ID<_Choice>				Id; 
		public string					Label;
        public REF<_Choice>				Target;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Action;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Action");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Label", Label);
	        Output.WriteId ("Target", Target.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Action");
				}			
			}
		}

    public partial class Task : _Choice {
        public ID<_Choice>				Target; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Task;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Task");
				}

	        Output.WriteId ("Target", Target.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Task");
				}			
			}
		}

    public partial class Next : _Choice {
        public REF<_Choice>				Target;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Next;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Next");
				}

	        Output.WriteId ("Target", Target.ToString());
			if (tag) {
				Output.EndElement ("Next");
				}			
			}
		}

    public partial class Input : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Label;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Input;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Input");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Label", Label);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Input");
				}			
			}
		}

    public partial class Output : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Label;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Output;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Output");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Label", Label);
			if (tag) {
				Output.EndElement ("Output");
				}			
			}
		}

    public partial class File : _Choice {

        public override GUISchemaType _Tag () {
            return GUISchemaType.File;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("File");
				}

			if (tag) {
				Output.EndElement ("File");
				}			
			}
		}

    public partial class String : _Choice {

        public override GUISchemaType _Tag () {
            return GUISchemaType.String;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class Validate : _Choice {
        public TOKEN<_Choice>			Id;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Validate;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Validate");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Validate");
				}			
			}
		}

    public partial class Close : _Choice {

        public override GUISchemaType _Tag () {
            return GUISchemaType.Close;
            }

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Close");
				}

			if (tag) {
				Output.EndElement ("Close");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override GUISchemaType _Tag () {
            return GUISchemaType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }
//	}

//namespace Goedel.Registry {

    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		GUI_Start,
		GUI__Namespace,				
		GUI__Entries,				
		Window_Start,
		Window__Id,				
		Window__Tag,				
		Window__Entries,				
		Wizard_Start,
		Wizard__Id,				
		Wizard__Tag,				
		Wizard__Entries,				
		Dialog_Start,
		Dialog__Id,				
		Dialog__Entries,				
		Operations_Start,
		Operations__Steps,				
		Heading_Start,
		Heading__Data,				
		Text_Start,
		Text__Data,				
		Horizontal_Start,
		Horizontal__Entries,				
		Vertical_Start,
		Vertical__Entries,				
		Action_Start,
		Action__Id,				
		Action__Label,				
		Action__Target,				
		Action__Entries,				
		Task_Start,
		Task__Target,				
		Task__Entries,				
		Next_Start,
		Next__Target,				
		Input_Start,
		Input__Id,				
		Input__Label,				
		Input__Entries,				
		Output_Start,
		Output__Id,				
		Output__Label,				
		File_Start,
		String_Start,
		Validate_Start,
		Validate__Id,				
		Close_Start,
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Trojan._Choice     Token;
        }

    public partial class GUISchema : Goedel.Registry.Parser{
        public List <Goedel.Trojan._Choice>        Top;
        public Registry	<Goedel.Trojan._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        Goedel.Trojan._Choice				Current;
        List <_StackItem>						Stack;
        TokenType								CurrentToken;
        Position								CurrentPosition;
        string									CurrentText;


        public static GUISchema Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new GUISchema();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }

            return Result;
            }


        public GUISchema() {
            Top = new List<Goedel.Trojan._Choice> () ;
            Registry = new Registry <Goedel.Trojan._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__WidgetType = Registry.TYPE ("WidgetType"); 
			TYPE__EntryType = Registry.TYPE ("EntryType"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 



            }



        public TYPE<Goedel.Trojan._Choice> TYPE__WidgetType ;
        public TYPE<Goedel.Trojan._Choice> TYPE__EntryType ;
        public TYPE<Goedel.Trojan._Choice> TYPE__ClassType ;

        private Goedel.Trojan._Choice New_Choice(string Label) {
            switch (Label) {

                case "GUI": return NewGUI();
                case "Window": return NewWindow();
                case "Wizard": return NewWizard();
                case "Dialog": return NewDialog();
                case "Operations": return NewOperations();
                case "Heading": return NewHeading();
                case "Text": return NewText();
                case "Horizontal": return NewHorizontal();
                case "Vertical": return NewVertical();
                case "Action": return NewAction();
                case "Task": return NewTask();
                case "Next": return NewNext();
                case "Input": return NewInput();
                case "Output": return NewOutput();
                case "File": return NewFile();
                case "String": return NewString();
                case "Validate": return NewValidate();
                case "Close": return NewClose();

				}
            throw new System.Exception ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Trojan.GUI NewGUI() {
            Goedel.Trojan.GUI result = new Goedel.Trojan.GUI();
            Push (result);
            State = StateCode.GUI_Start;
            return result;
            }


        private Goedel.Trojan.Window NewWindow() {
            Goedel.Trojan.Window result = new Goedel.Trojan.Window();
            Push (result);
            State = StateCode.Window_Start;
            return result;
            }


        private Goedel.Trojan.Wizard NewWizard() {
            Goedel.Trojan.Wizard result = new Goedel.Trojan.Wizard();
            Push (result);
            State = StateCode.Wizard_Start;
            return result;
            }


        private Goedel.Trojan.Dialog NewDialog() {
            Goedel.Trojan.Dialog result = new Goedel.Trojan.Dialog();
            Push (result);
            State = StateCode.Dialog_Start;
            return result;
            }


        private Goedel.Trojan.Operations NewOperations() {
            Goedel.Trojan.Operations result = new Goedel.Trojan.Operations();
            Push (result);
            State = StateCode.Operations_Start;
            return result;
            }


        private Goedel.Trojan.Heading NewHeading() {
            Goedel.Trojan.Heading result = new Goedel.Trojan.Heading();
            Push (result);
            State = StateCode.Heading_Start;
            return result;
            }


        private Goedel.Trojan.Text NewText() {
            Goedel.Trojan.Text result = new Goedel.Trojan.Text();
            Push (result);
            State = StateCode.Text_Start;
            return result;
            }


        private Goedel.Trojan.Horizontal NewHorizontal() {
            Goedel.Trojan.Horizontal result = new Goedel.Trojan.Horizontal();
            Push (result);
            State = StateCode.Horizontal_Start;
            return result;
            }


        private Goedel.Trojan.Vertical NewVertical() {
            Goedel.Trojan.Vertical result = new Goedel.Trojan.Vertical();
            Push (result);
            State = StateCode.Vertical_Start;
            return result;
            }


        private Goedel.Trojan.Action NewAction() {
            Goedel.Trojan.Action result = new Goedel.Trojan.Action();
            Push (result);
            State = StateCode.Action_Start;
            return result;
            }


        private Goedel.Trojan.Task NewTask() {
            Goedel.Trojan.Task result = new Goedel.Trojan.Task();
            Push (result);
            State = StateCode.Task_Start;
            return result;
            }


        private Goedel.Trojan.Next NewNext() {
            Goedel.Trojan.Next result = new Goedel.Trojan.Next();
            Push (result);
            State = StateCode.Next_Start;
            return result;
            }


        private Goedel.Trojan.Input NewInput() {
            Goedel.Trojan.Input result = new Goedel.Trojan.Input();
            Push (result);
            State = StateCode.Input_Start;
            return result;
            }


        private Goedel.Trojan.Output NewOutput() {
            Goedel.Trojan.Output result = new Goedel.Trojan.Output();
            Push (result);
            State = StateCode.Output_Start;
            return result;
            }


        private Goedel.Trojan.File NewFile() {
            Goedel.Trojan.File result = new Goedel.Trojan.File();
            Push (result);
            State = StateCode.File_Start;
            return result;
            }


        private Goedel.Trojan.String NewString() {
            Goedel.Trojan.String result = new Goedel.Trojan.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private Goedel.Trojan.Validate NewValidate() {
            Goedel.Trojan.Validate result = new Goedel.Trojan.Validate();
            Push (result);
            State = StateCode.Validate_Start;
            return result;
            }


        private Goedel.Trojan.Close NewClose() {
            Goedel.Trojan.Close result = new Goedel.Trojan.Close();
            Push (result);
            State = StateCode.Close_Start;
            return result;
            }


        static Goedel.Trojan.GUISchemaType _Reserved(string Label) {
            switch (Label) {

                case "GUI": return Goedel.Trojan.GUISchemaType.GUI;
                case "Window": return Goedel.Trojan.GUISchemaType.Window;
                case "Wizard": return Goedel.Trojan.GUISchemaType.Wizard;
                case "Dialog": return Goedel.Trojan.GUISchemaType.Dialog;
                case "Operations": return Goedel.Trojan.GUISchemaType.Operations;
                case "Heading": return Goedel.Trojan.GUISchemaType.Heading;
                case "Text": return Goedel.Trojan.GUISchemaType.Text;
                case "Horizontal": return Goedel.Trojan.GUISchemaType.Horizontal;
                case "Vertical": return Goedel.Trojan.GUISchemaType.Vertical;
                case "Action": return Goedel.Trojan.GUISchemaType.Action;
                case "Task": return Goedel.Trojan.GUISchemaType.Task;
                case "Next": return Goedel.Trojan.GUISchemaType.Next;
                case "Input": return Goedel.Trojan.GUISchemaType.Input;
                case "Output": return Goedel.Trojan.GUISchemaType.Output;
                case "File": return Goedel.Trojan.GUISchemaType.File;
                case "String": return Goedel.Trojan.GUISchemaType.String;
                case "Validate": return Goedel.Trojan.GUISchemaType.Validate;
                case "Close": return Goedel.Trojan.GUISchemaType.Close;

                }
            return Goedel.Trojan.GUISchemaType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Trojan._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Trojan._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new System.Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {
            CurrentToken = Token;
            CurrentPosition = Position;
            CurrentText = Text;

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new System.Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Trojan.GUISchemaType.GUI)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new System.Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new System.Exception("Too Many Closing Braces");

                    case StateCode.GUI_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.GUI Current_Cast = (Goedel.Trojan.GUI)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.GUI__Namespace;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.GUI__Namespace:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.GUI__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.GUI__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.GUI Current_Cast = (Goedel.Trojan.GUI)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Window) |
									(LabelType == Goedel.Trojan.GUISchemaType.Wizard) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Window Wizard ]");
								}
							}
                        break;


                    case StateCode.Window_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Window Current_Cast = (Goedel.Trojan.Window)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Window__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Window__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Window Current_Cast = (Goedel.Trojan.Window)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Window__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Window__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Window__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Window__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Window Current_Cast = (Goedel.Trojan.Window)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Dialog) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Dialog ]");
								}
							}
                        break;


                    case StateCode.Wizard_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Wizard Current_Cast = (Goedel.Trojan.Wizard)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Wizard__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Wizard__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Wizard Current_Cast = (Goedel.Trojan.Wizard)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Wizard__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Wizard__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Wizard__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Wizard__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Wizard Current_Cast = (Goedel.Trojan.Wizard)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Dialog) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Dialog ]");
								}
							}
                        break;


                    case StateCode.Dialog_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Dialog Current_Cast = (Goedel.Trojan.Dialog)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Dialog__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Dialog__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Dialog__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Dialog__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Dialog Current_Cast = (Goedel.Trojan.Dialog)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Operations) |
									(LabelType == Goedel.Trojan.GUISchemaType.Heading) |
									(LabelType == Goedel.Trojan.GUISchemaType.Text) |
									(LabelType == Goedel.Trojan.GUISchemaType.Horizontal) |
									(LabelType == Goedel.Trojan.GUISchemaType.Vertical) |
									(LabelType == Goedel.Trojan.GUISchemaType.Action) |
									(LabelType == Goedel.Trojan.GUISchemaType.Task) |
									(LabelType == Goedel.Trojan.GUISchemaType.Next) |
									(LabelType == Goedel.Trojan.GUISchemaType.Input) |
									(LabelType == Goedel.Trojan.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Operations Heading Text Horizontal Vertical Action Task Next Input Output ]");
								}
							}
                        break;


                    case StateCode.Operations_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Operations__Steps;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Operations__Steps: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Operations Current_Cast = (Goedel.Trojan.Operations)Current;
                            Current_Cast.Steps.Add ( Registry.REF(Position, Text, TYPE__WidgetType, Current_Cast ) );
                            break;
                            }

                        break;


                    case StateCode.Heading_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Heading__Data;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Heading__Data:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Trojan.Heading Current_Cast = (Goedel.Trojan.Heading)Current;
                            Current_Cast.Data.Add (Text);
                            break;							
                            }
                       throw new System.Exception("Expected Text");


                    case StateCode.Text_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Text__Data;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Text__Data:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Trojan.Text Current_Cast = (Goedel.Trojan.Text)Current;
                            Current_Cast.Data.Add (Text);
                            break;							
                            }
                       throw new System.Exception("Expected Text");


                    case StateCode.Horizontal_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Horizontal__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Horizontal__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Horizontal Current_Cast = (Goedel.Trojan.Horizontal)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Text) |
									(LabelType == Goedel.Trojan.GUISchemaType.Action) |
									(LabelType == Goedel.Trojan.GUISchemaType.Task) |
									(LabelType == Goedel.Trojan.GUISchemaType.Next) |
									(LabelType == Goedel.Trojan.GUISchemaType.Input) |
									(LabelType == Goedel.Trojan.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Text Action Task Next Input Output ]");
								}
							}
                        break;


                    case StateCode.Vertical_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Vertical__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Vertical__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Vertical Current_Cast = (Goedel.Trojan.Vertical)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Text) |
									(LabelType == Goedel.Trojan.GUISchemaType.Action) |
									(LabelType == Goedel.Trojan.GUISchemaType.Task) |
									(LabelType == Goedel.Trojan.GUISchemaType.Next) |
									(LabelType == Goedel.Trojan.GUISchemaType.Input) |
									(LabelType == Goedel.Trojan.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Text Action Task Next Input Output ]");
								}
							}
                        break;


                    case StateCode.Action_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Action Current_Cast = (Goedel.Trojan.Action)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__EntryType, Current_Cast);
                            State = StateCode.Action__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Action__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Action Current_Cast = (Goedel.Trojan.Action)Current;
                            Current_Cast.Label = Text;
                            State = StateCode.Action__Label;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Action__Label:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Action Current_Cast = (Goedel.Trojan.Action)Current;
                            Current_Cast.Target = Registry.REF(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Action__Target;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Action__Target:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Action__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Action__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Action Current_Cast = (Goedel.Trojan.Action)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Text) |
									(LabelType == Goedel.Trojan.GUISchemaType.Input) |
									(LabelType == Goedel.Trojan.GUISchemaType.Output) |
									(LabelType == Goedel.Trojan.GUISchemaType.Close) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Text Input Output Close ]");
								}
							}
                        break;


                    case StateCode.Task_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Task Current_Cast = (Goedel.Trojan.Task)Current;
                            Current_Cast.Target = Registry.ID(Position, Text, TYPE__EntryType, Current_Cast);
                            State = StateCode.Task__Target;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Task__Target:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Task__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Task__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Task Current_Cast = (Goedel.Trojan.Task)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Text) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Text ]");
								}
							}
                        break;


                    case StateCode.Next_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Next Current_Cast = (Goedel.Trojan.Next)Current;
                            Current_Cast.Target = Registry.REF(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Next__Target;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Next__Target:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Input_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Input Current_Cast = (Goedel.Trojan.Input)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__EntryType, Current_Cast);
                            State = StateCode.Input__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Input__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Input Current_Cast = (Goedel.Trojan.Input)Current;
                            Current_Cast.Label = Text;
                            State = StateCode.Input__Label;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Input__Label:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Input__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Input__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Input Current_Cast = (Goedel.Trojan.Input)Current;
                            Goedel.Trojan.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.GUISchemaType.Validate) |
									(LabelType == Goedel.Trojan.GUISchemaType.File) |
									(LabelType == Goedel.Trojan.GUISchemaType.String) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Validate File String ]");
								}
							}
                        break;


                    case StateCode.Output_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Output Current_Cast = (Goedel.Trojan.Output)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__EntryType, Current_Cast);
                            State = StateCode.Output__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Output__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Output Current_Cast = (Goedel.Trojan.Output)Current;
                            Current_Cast.Label = Text;
                            State = StateCode.Output__Label;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Output__Label:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.File_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.String_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Validate_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Validate Current_Cast = (Goedel.Trojan.Validate)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__EntryType, Current_Cast);
                            State = StateCode.Validate__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Validate__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Close_Start:
                        Pop ();
                        Represent = true; 
                        break;

                    default:
                        throw new System.Exception("Unreachable code reached");
                    }
                }
            }
        }
	}


