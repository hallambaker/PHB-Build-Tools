
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;


//
// Namespace Goedel.Trojan.Script
// Class GUISchema
//


// Types
//   TopTypeType
//       GUI
//   TypeType
//       About
//       Window
//       Menu
//       Object
//       Wizard
//       Text
//       Copyright
//       Tip
//       ThreePane
//       Command
//       Select
//       Inherit
//       DateTime
//       String
//       Secret
//       Integer
//       Boolean
//       Option
//       Set
//       List
//       Chooser
//       Enumerate
//       Item
//       Output
//       Radio
//       Step
//   IdType
//       GuiType
//       WidgetType
//       ItemType
//       WizardType
//   NamespaceType
//       Goedel.Trojan.Script
//   ClassType
//       GUISchema
//   NameType
//       Namespace
//       Id
//       Entries
//       Title
//       Data
//       Tag
//       Of
//   TokenType
//       ClassType
//       FieldType

namespace Goedel.Trojan.Script {


    public enum GUISchemaType {
        _Top,

        GUI,
        About,
        Text,
        Copyright,
        Tip,
        Window,
        ThreePane,
        Menu,
        Command,
        Select,
        Object,
        Inherit,
        Item,
        List,
        Set,
        Option,
        DateTime,
        Chooser,
        String,
        Secret,
        Integer,
        Boolean,
        Output,
        Enumerate,
        Radio,
        Wizard,
        Step,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public GUISchemaType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);

		public virtual void Init (_Choice Parent) {
			}

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice Parent) {
			Init (Parent);
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class GUI : _Choice {
        public TOKEN<_Choice>			Namespace;
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.GUI;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("GUI");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("GUI");
				}			
			}
		}

    public partial class About : _Choice {
		public string					Title;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.About;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("About");
				}

			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("About");
				}			
			}
		}

    public partial class Text : _Choice {
		public List <System.String>			Data = new List <System.String> (); 

        public override GUISchemaType _Tag () {
            return GUISchemaType.Text;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Text");
				}

			foreach (string _s in Data) {
				Output.WriteAttribute ("Data",_s);
				}
			if (tag) {
				Output.EndElement ("Text");
				}			
			}
		}

    public partial class Copyright : _Choice {
		public string					Data;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Copyright;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Copyright");
				}

			Output.WriteAttribute ("Data", Data);
			if (tag) {
				Output.EndElement ("Copyright");
				}			
			}
		}

    public partial class Tip : _Choice {
		public List <System.String>			Data = new List <System.String> (); 

        public override GUISchemaType _Tag () {
            return GUISchemaType.Tip;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Tip");
				}

			foreach (string _s in Data) {
				Output.WriteAttribute ("Data",_s);
				}
			if (tag) {
				Output.EndElement ("Tip");
				}			
			}
		}

    public partial class Window : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Window;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Window");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Window");
				}			
			}
		}

    public partial class ThreePane : _Choice {
        public REF<_Choice>				Menu;

        public override GUISchemaType _Tag () {
            return GUISchemaType.ThreePane;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("ThreePane");
				}

	        Output.WriteId ("Menu", Menu.ToString());
			if (tag) {
				Output.EndElement ("ThreePane");
				}			
			}
		}

    public partial class Menu : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Menu;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Menu");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Menu");
				}			
			}
		}

    public partial class Command : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Command;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Command");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Command");
				}			
			}
		}

    public partial class Select : _Choice {
        public REF<_Choice>				Id;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Select;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Select");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Select");
				}			
			}
		}

    public partial class Object : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Object;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Object");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Object");
				}			
			}
		}

    public partial class Inherit : _Choice {
        public REF<_Choice>				Id;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Inherit;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Inherit");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Inherit");
				}			
			}
		}

    public partial class Item : _Choice {
        public REF<_Choice>				Of;
        public TOKEN<_Choice>			Id;
		public string					Tag;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Item;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Item");
				}

	        Output.WriteId ("Of", Of.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			if (tag) {
				Output.EndElement ("Item");
				}			
			}
		}

    public partial class List : _Choice {
        public REF<_Choice>				Of;
        public TOKEN<_Choice>			Id;
		public string					Tag;

        public override GUISchemaType _Tag () {
            return GUISchemaType.List;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("List");
				}

	        Output.WriteId ("Of", Of.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			if (tag) {
				Output.EndElement ("List");
				}			
			}
		}

    public partial class Set : _Choice {
        public REF<_Choice>				Of;
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Set;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Set");
				}

	        Output.WriteId ("Of", Of.ToString());
	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Set");
				}			
			}
		}

    public partial class Option : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Option;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Option");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Option");
				}			
			}
		}

    public partial class DateTime : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.DateTime;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("DateTime");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("DateTime");
				}			
			}
		}

    public partial class Chooser : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Chooser;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Chooser");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Chooser");
				}			
			}
		}

    public partial class String : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.String;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class Secret : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Secret;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Secret");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Secret");
				}			
			}
		}

    public partial class Integer : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Integer;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Integer");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Integer");
				}			
			}
		}

    public partial class Boolean : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Boolean;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Boolean");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Boolean");
				}			
			}
		}

    public partial class Output : _Choice {

        public override GUISchemaType _Tag () {
            return GUISchemaType.Output;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Output");
				}

			if (tag) {
				Output.EndElement ("Output");
				}			
			}
		}

    public partial class Enumerate : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Enumerate;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enumerate");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enumerate");
				}			
			}
		}

    public partial class Radio : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Tag;

        public override GUISchemaType _Tag () {
            return GUISchemaType.Radio;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Radio");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			if (tag) {
				Output.EndElement ("Radio");
				}			
			}
		}

    public partial class Wizard : _Choice {
        public ID<_Choice>				Id; 
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Wizard;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Wizard");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Wizard");
				}			
			}
		}

    public partial class Step : _Choice {
        public REF<_Choice>				Id;
		public string					Tag;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GUISchemaType _Tag () {
            return GUISchemaType.Step;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Step");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Tag", Tag);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Step");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override GUISchemaType _Tag () {
            return GUISchemaType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		GUI_Start,
		GUI__Namespace,				
		GUI__Id,				
		GUI__Entries,				
		About_Start,
		About__Title,				
		About__Entries,				
		Text_Start,
		Text__Data,				
		Copyright_Start,
		Copyright__Data,				
		Tip_Start,
		Tip__Data,				
		Window_Start,
		Window__Id,				
		Window__Tag,				
		Window__Entries,				
		ThreePane_Start,
		ThreePane__Menu,				
		Menu_Start,
		Menu__Id,				
		Menu__Tag,				
		Menu__Entries,				
		Command_Start,
		Command__Id,				
		Command__Tag,				
		Command__Entries,				
		Select_Start,
		Select__Id,				
		Object_Start,
		Object__Id,				
		Object__Tag,				
		Object__Entries,				
		Inherit_Start,
		Inherit__Id,				
		Item_Start,
		Item__Of,				
		Item__Id,				
		Item__Tag,				
		List_Start,
		List__Of,				
		List__Id,				
		List__Tag,				
		Set_Start,
		Set__Of,				
		Set__Id,				
		Set__Tag,				
		Set__Entries,				
		Option_Start,
		Option__Id,				
		Option__Tag,				
		Option__Entries,				
		DateTime_Start,
		DateTime__Id,				
		DateTime__Tag,				
		DateTime__Entries,				
		Chooser_Start,
		Chooser__Id,				
		Chooser__Tag,				
		Chooser__Entries,				
		String_Start,
		String__Id,				
		String__Tag,				
		String__Entries,				
		Secret_Start,
		Secret__Id,				
		Secret__Tag,				
		Secret__Entries,				
		Integer_Start,
		Integer__Id,				
		Integer__Tag,				
		Integer__Entries,				
		Boolean_Start,
		Boolean__Id,				
		Boolean__Tag,				
		Boolean__Entries,				
		Output_Start,
		Enumerate_Start,
		Enumerate__Id,				
		Enumerate__Tag,				
		Enumerate__Entries,				
		Radio_Start,
		Radio__Id,				
		Radio__Tag,				
		Wizard_Start,
		Wizard__Id,				
		Wizard__Tag,				
		Wizard__Entries,				
		Step_Start,
		Step__Id,				
		Step__Tag,				
		Step__Entries,				
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Trojan.Script._Choice     Token;
        }

    public partial class GUISchema : Goedel.Registry.Parser{
        public List <Goedel.Trojan.Script._Choice>        Top;
        public Registry	<Goedel.Trojan.Script._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        Goedel.Trojan.Script._Choice				Current;
        List <_StackItem>						Stack;
        TokenType								CurrentToken;
        Position								CurrentPosition;
        string									CurrentText;


        public static GUISchema Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new GUISchema();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
				Entry._InitChildren (null);
				}
			}

        public GUISchema() {
            Top = new List<Goedel.Trojan.Script._Choice> () ;
            Registry = new Registry <Goedel.Trojan.Script._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__GuiType = Registry.TYPE ("GuiType"); 
			TYPE__WidgetType = Registry.TYPE ("WidgetType"); 
			TYPE__ItemType = Registry.TYPE ("ItemType"); 
			TYPE__WizardType = Registry.TYPE ("WizardType"); 
			TYPE__ClassType = Registry.TYPE ("ClassType"); 
			TYPE__FieldType = Registry.TYPE ("FieldType"); 



            }



        public TYPE<Goedel.Trojan.Script._Choice> TYPE__GuiType ;
        public TYPE<Goedel.Trojan.Script._Choice> TYPE__WidgetType ;
        public TYPE<Goedel.Trojan.Script._Choice> TYPE__ItemType ;
        public TYPE<Goedel.Trojan.Script._Choice> TYPE__WizardType ;
        public TYPE<Goedel.Trojan.Script._Choice> TYPE__ClassType ;
        public TYPE<Goedel.Trojan.Script._Choice> TYPE__FieldType ;

        private Goedel.Trojan.Script._Choice New_Choice(string Label) {
            switch (Label) {

                case "GUI": return NewGUI();
                case "About": return NewAbout();
                case "Text": return NewText();
                case "Copyright": return NewCopyright();
                case "Tip": return NewTip();
                case "Window": return NewWindow();
                case "ThreePane": return NewThreePane();
                case "Menu": return NewMenu();
                case "Command": return NewCommand();
                case "Select": return NewSelect();
                case "Object": return NewObject();
                case "Inherit": return NewInherit();
                case "Item": return NewItem();
                case "List": return NewList();
                case "Set": return NewSet();
                case "Option": return NewOption();
                case "DateTime": return NewDateTime();
                case "Chooser": return NewChooser();
                case "String": return NewString();
                case "Secret": return NewSecret();
                case "Integer": return NewInteger();
                case "Boolean": return NewBoolean();
                case "Output": return NewOutput();
                case "Enumerate": return NewEnumerate();
                case "Radio": return NewRadio();
                case "Wizard": return NewWizard();
                case "Step": return NewStep();

				}
            throw new System.Exception ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Trojan.Script.GUI NewGUI() {
            Goedel.Trojan.Script.GUI result = new Goedel.Trojan.Script.GUI();
            Push (result);
            State = StateCode.GUI_Start;
            return result;
            }


        private Goedel.Trojan.Script.About NewAbout() {
            Goedel.Trojan.Script.About result = new Goedel.Trojan.Script.About();
            Push (result);
            State = StateCode.About_Start;
            return result;
            }


        private Goedel.Trojan.Script.Text NewText() {
            Goedel.Trojan.Script.Text result = new Goedel.Trojan.Script.Text();
            Push (result);
            State = StateCode.Text_Start;
            return result;
            }


        private Goedel.Trojan.Script.Copyright NewCopyright() {
            Goedel.Trojan.Script.Copyright result = new Goedel.Trojan.Script.Copyright();
            Push (result);
            State = StateCode.Copyright_Start;
            return result;
            }


        private Goedel.Trojan.Script.Tip NewTip() {
            Goedel.Trojan.Script.Tip result = new Goedel.Trojan.Script.Tip();
            Push (result);
            State = StateCode.Tip_Start;
            return result;
            }


        private Goedel.Trojan.Script.Window NewWindow() {
            Goedel.Trojan.Script.Window result = new Goedel.Trojan.Script.Window();
            Push (result);
            State = StateCode.Window_Start;
            return result;
            }


        private Goedel.Trojan.Script.ThreePane NewThreePane() {
            Goedel.Trojan.Script.ThreePane result = new Goedel.Trojan.Script.ThreePane();
            Push (result);
            State = StateCode.ThreePane_Start;
            return result;
            }


        private Goedel.Trojan.Script.Menu NewMenu() {
            Goedel.Trojan.Script.Menu result = new Goedel.Trojan.Script.Menu();
            Push (result);
            State = StateCode.Menu_Start;
            return result;
            }


        private Goedel.Trojan.Script.Command NewCommand() {
            Goedel.Trojan.Script.Command result = new Goedel.Trojan.Script.Command();
            Push (result);
            State = StateCode.Command_Start;
            return result;
            }


        private Goedel.Trojan.Script.Select NewSelect() {
            Goedel.Trojan.Script.Select result = new Goedel.Trojan.Script.Select();
            Push (result);
            State = StateCode.Select_Start;
            return result;
            }


        private Goedel.Trojan.Script.Object NewObject() {
            Goedel.Trojan.Script.Object result = new Goedel.Trojan.Script.Object();
            Push (result);
            State = StateCode.Object_Start;
            return result;
            }


        private Goedel.Trojan.Script.Inherit NewInherit() {
            Goedel.Trojan.Script.Inherit result = new Goedel.Trojan.Script.Inherit();
            Push (result);
            State = StateCode.Inherit_Start;
            return result;
            }


        private Goedel.Trojan.Script.Item NewItem() {
            Goedel.Trojan.Script.Item result = new Goedel.Trojan.Script.Item();
            Push (result);
            State = StateCode.Item_Start;
            return result;
            }


        private Goedel.Trojan.Script.List NewList() {
            Goedel.Trojan.Script.List result = new Goedel.Trojan.Script.List();
            Push (result);
            State = StateCode.List_Start;
            return result;
            }


        private Goedel.Trojan.Script.Set NewSet() {
            Goedel.Trojan.Script.Set result = new Goedel.Trojan.Script.Set();
            Push (result);
            State = StateCode.Set_Start;
            return result;
            }


        private Goedel.Trojan.Script.Option NewOption() {
            Goedel.Trojan.Script.Option result = new Goedel.Trojan.Script.Option();
            Push (result);
            State = StateCode.Option_Start;
            return result;
            }


        private Goedel.Trojan.Script.DateTime NewDateTime() {
            Goedel.Trojan.Script.DateTime result = new Goedel.Trojan.Script.DateTime();
            Push (result);
            State = StateCode.DateTime_Start;
            return result;
            }


        private Goedel.Trojan.Script.Chooser NewChooser() {
            Goedel.Trojan.Script.Chooser result = new Goedel.Trojan.Script.Chooser();
            Push (result);
            State = StateCode.Chooser_Start;
            return result;
            }


        private Goedel.Trojan.Script.String NewString() {
            Goedel.Trojan.Script.String result = new Goedel.Trojan.Script.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private Goedel.Trojan.Script.Secret NewSecret() {
            Goedel.Trojan.Script.Secret result = new Goedel.Trojan.Script.Secret();
            Push (result);
            State = StateCode.Secret_Start;
            return result;
            }


        private Goedel.Trojan.Script.Integer NewInteger() {
            Goedel.Trojan.Script.Integer result = new Goedel.Trojan.Script.Integer();
            Push (result);
            State = StateCode.Integer_Start;
            return result;
            }


        private Goedel.Trojan.Script.Boolean NewBoolean() {
            Goedel.Trojan.Script.Boolean result = new Goedel.Trojan.Script.Boolean();
            Push (result);
            State = StateCode.Boolean_Start;
            return result;
            }


        private Goedel.Trojan.Script.Output NewOutput() {
            Goedel.Trojan.Script.Output result = new Goedel.Trojan.Script.Output();
            Push (result);
            State = StateCode.Output_Start;
            return result;
            }


        private Goedel.Trojan.Script.Enumerate NewEnumerate() {
            Goedel.Trojan.Script.Enumerate result = new Goedel.Trojan.Script.Enumerate();
            Push (result);
            State = StateCode.Enumerate_Start;
            return result;
            }


        private Goedel.Trojan.Script.Radio NewRadio() {
            Goedel.Trojan.Script.Radio result = new Goedel.Trojan.Script.Radio();
            Push (result);
            State = StateCode.Radio_Start;
            return result;
            }


        private Goedel.Trojan.Script.Wizard NewWizard() {
            Goedel.Trojan.Script.Wizard result = new Goedel.Trojan.Script.Wizard();
            Push (result);
            State = StateCode.Wizard_Start;
            return result;
            }


        private Goedel.Trojan.Script.Step NewStep() {
            Goedel.Trojan.Script.Step result = new Goedel.Trojan.Script.Step();
            Push (result);
            State = StateCode.Step_Start;
            return result;
            }


        static Goedel.Trojan.Script.GUISchemaType _Reserved(string Label) {
            switch (Label) {

                case "GUI": return Goedel.Trojan.Script.GUISchemaType.GUI;
                case "About": return Goedel.Trojan.Script.GUISchemaType.About;
                case "Text": return Goedel.Trojan.Script.GUISchemaType.Text;
                case "Copyright": return Goedel.Trojan.Script.GUISchemaType.Copyright;
                case "Tip": return Goedel.Trojan.Script.GUISchemaType.Tip;
                case "Window": return Goedel.Trojan.Script.GUISchemaType.Window;
                case "ThreePane": return Goedel.Trojan.Script.GUISchemaType.ThreePane;
                case "Menu": return Goedel.Trojan.Script.GUISchemaType.Menu;
                case "Command": return Goedel.Trojan.Script.GUISchemaType.Command;
                case "Select": return Goedel.Trojan.Script.GUISchemaType.Select;
                case "Object": return Goedel.Trojan.Script.GUISchemaType.Object;
                case "Inherit": return Goedel.Trojan.Script.GUISchemaType.Inherit;
                case "Item": return Goedel.Trojan.Script.GUISchemaType.Item;
                case "List": return Goedel.Trojan.Script.GUISchemaType.List;
                case "Set": return Goedel.Trojan.Script.GUISchemaType.Set;
                case "Option": return Goedel.Trojan.Script.GUISchemaType.Option;
                case "DateTime": return Goedel.Trojan.Script.GUISchemaType.DateTime;
                case "Chooser": return Goedel.Trojan.Script.GUISchemaType.Chooser;
                case "String": return Goedel.Trojan.Script.GUISchemaType.String;
                case "Secret": return Goedel.Trojan.Script.GUISchemaType.Secret;
                case "Integer": return Goedel.Trojan.Script.GUISchemaType.Integer;
                case "Boolean": return Goedel.Trojan.Script.GUISchemaType.Boolean;
                case "Output": return Goedel.Trojan.Script.GUISchemaType.Output;
                case "Enumerate": return Goedel.Trojan.Script.GUISchemaType.Enumerate;
                case "Radio": return Goedel.Trojan.Script.GUISchemaType.Radio;
                case "Wizard": return Goedel.Trojan.Script.GUISchemaType.Wizard;
                case "Step": return Goedel.Trojan.Script.GUISchemaType.Step;

                }
            return Goedel.Trojan.Script.GUISchemaType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Trojan.Script._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Trojan.Script._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
            if (Stack.Count == 0) throw new System.Exception ("Internal Parser Error");

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {
            CurrentToken = Token;
            CurrentPosition = Position;
            CurrentText = Text;

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) return;
            if (Token == TokenType.INVALID)
                throw new System.Exception("Invalid Token");

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected START");

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.GUI)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new System.Exception("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else throw new System.Exception("Parser Error Expected [Class]");

                    case StateCode._End:                   //      -
                        throw new System.Exception("Too Many Closing Braces");

                    case StateCode.GUI_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.GUI Current_Cast = (Goedel.Trojan.Script.GUI)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__ClassType, Current_Cast);
                            State = StateCode.GUI__Namespace;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.GUI__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.GUI Current_Cast = (Goedel.Trojan.Script.GUI)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__GuiType, Current_Cast);
                            State = StateCode.GUI__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.GUI__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.GUI__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.GUI__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.GUI Current_Cast = (Goedel.Trojan.Script.GUI)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.About) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Window) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Menu) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Object) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Wizard) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [About Window Menu Object Wizard ]");
								}
							}
                        break;


                    case StateCode.About_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.About Current_Cast = (Goedel.Trojan.Script.About)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.About__Title;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.About__Title:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.About__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.About__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.About Current_Cast = (Goedel.Trojan.Script.About)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Text) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Copyright) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Text Copyright ]");
								}
							}
                        break;


                    case StateCode.Text_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Text__Data;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Text__Data:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Trojan.Script.Text Current_Cast = (Goedel.Trojan.Script.Text)Current;
                            Current_Cast.Data.Add (Text);
                            break;							
                            }
                       throw new System.Exception("Expected Text");


                    case StateCode.Copyright_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Copyright Current_Cast = (Goedel.Trojan.Script.Copyright)Current;
                            Current_Cast.Data = Text;
                            State = StateCode.Copyright__Data;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Copyright__Data:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Tip_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Tip__Data;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Tip__Data:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Trojan.Script.Tip Current_Cast = (Goedel.Trojan.Script.Tip)Current;
                            Current_Cast.Data.Add (Text);
                            break;							
                            }
                       throw new System.Exception("Expected Text");


                    case StateCode.Window_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Window Current_Cast = (Goedel.Trojan.Script.Window)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Window__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Window__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Window Current_Cast = (Goedel.Trojan.Script.Window)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Window__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Window__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Window__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Window__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Window Current_Cast = (Goedel.Trojan.Script.Window)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.ThreePane) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [ThreePane ]");
								}
							}
                        break;


                    case StateCode.ThreePane_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.ThreePane Current_Cast = (Goedel.Trojan.Script.ThreePane)Current;
                            Current_Cast.Menu = Registry.REF(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.ThreePane__Menu;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.ThreePane__Menu:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Menu_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Menu Current_Cast = (Goedel.Trojan.Script.Menu)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Menu__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Menu__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Menu Current_Cast = (Goedel.Trojan.Script.Menu)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Menu__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Menu__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Menu__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Menu__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Menu Current_Cast = (Goedel.Trojan.Script.Menu)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Command) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Menu) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Command Menu ]");
								}
							}
                        break;


                    case StateCode.Command_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Command Current_Cast = (Goedel.Trojan.Script.Command)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__WidgetType, Current_Cast);
                            State = StateCode.Command__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Command__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Command Current_Cast = (Goedel.Trojan.Script.Command)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Command__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Command__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Command__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Command__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Command Current_Cast = (Goedel.Trojan.Script.Command)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Select) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Tip) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Text) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Select Tip Text ]");
								}
							}
                        break;


                    case StateCode.Select_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Select Current_Cast = (Goedel.Trojan.Script.Select)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ItemType, Current_Cast);
                            State = StateCode.Select__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Select__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Object_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Object Current_Cast = (Goedel.Trojan.Script.Object)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__ItemType, Current_Cast);
                            State = StateCode.Object__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Object__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Object Current_Cast = (Goedel.Trojan.Script.Object)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Object__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Object__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Object__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Object__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Object Current_Cast = (Goedel.Trojan.Script.Object)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Inherit) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.DateTime) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.String) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Secret) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Integer) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Boolean) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Option) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Set) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Command) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.List) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Chooser) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Enumerate) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Text) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Tip) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Item) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Inherit DateTime String Secret Integer Boolean Option Set Command List Chooser Enumerate Text Tip Item ]");
								}
							}
                        break;


                    case StateCode.Inherit_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Inherit Current_Cast = (Goedel.Trojan.Script.Inherit)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ItemType, Current_Cast);
                            State = StateCode.Inherit__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Inherit__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Item_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Item Current_Cast = (Goedel.Trojan.Script.Item)Current;
                            Current_Cast.Of = Registry.REF(Position, Text, TYPE__ItemType, Current_Cast);
                            State = StateCode.Item__Of;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Item__Of:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Item Current_Cast = (Goedel.Trojan.Script.Item)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Item__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Item__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Item Current_Cast = (Goedel.Trojan.Script.Item)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Item__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Item__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.List_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.List Current_Cast = (Goedel.Trojan.Script.List)Current;
                            Current_Cast.Of = Registry.REF(Position, Text, TYPE__ItemType, Current_Cast);
                            State = StateCode.List__Of;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.List__Of:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.List Current_Cast = (Goedel.Trojan.Script.List)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.List__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.List__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.List Current_Cast = (Goedel.Trojan.Script.List)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.List__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.List__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Set_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Set Current_Cast = (Goedel.Trojan.Script.Set)Current;
                            Current_Cast.Of = Registry.REF(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Set__Of;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Set__Of:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Set Current_Cast = (Goedel.Trojan.Script.Set)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Set__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Set__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Set Current_Cast = (Goedel.Trojan.Script.Set)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Set__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Set__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Set__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Set__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Set Current_Cast = (Goedel.Trojan.Script.Set)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Output ]");
								}
							}
                        break;


                    case StateCode.Option_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Option Current_Cast = (Goedel.Trojan.Script.Option)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Option__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Option__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Option Current_Cast = (Goedel.Trojan.Script.Option)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Option__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Option__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Option__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Option__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Option Current_Cast = (Goedel.Trojan.Script.Option)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.DateTime) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.String) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Secret) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Integer) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Boolean) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Option) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Set) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Command) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Item) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.List) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Chooser) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Text) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Tip) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [DateTime String Secret Integer Boolean Option Set Command Item List Chooser Text Tip ]");
								}
							}
                        break;


                    case StateCode.DateTime_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.DateTime Current_Cast = (Goedel.Trojan.Script.DateTime)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.DateTime__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.DateTime__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.DateTime Current_Cast = (Goedel.Trojan.Script.DateTime)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.DateTime__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.DateTime__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.DateTime__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.DateTime__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.DateTime Current_Cast = (Goedel.Trojan.Script.DateTime)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Output ]");
								}
							}
                        break;


                    case StateCode.Chooser_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Chooser Current_Cast = (Goedel.Trojan.Script.Chooser)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Chooser__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Chooser__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Chooser Current_Cast = (Goedel.Trojan.Script.Chooser)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Chooser__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Chooser__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Chooser__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Chooser__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Chooser Current_Cast = (Goedel.Trojan.Script.Chooser)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Output ]");
								}
							}
                        break;


                    case StateCode.String_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.String Current_Cast = (Goedel.Trojan.Script.String)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.String__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.String__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.String Current_Cast = (Goedel.Trojan.Script.String)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.String__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.String__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.String__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.String__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.String Current_Cast = (Goedel.Trojan.Script.String)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Output ]");
								}
							}
                        break;


                    case StateCode.Secret_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Secret Current_Cast = (Goedel.Trojan.Script.Secret)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Secret__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Secret__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Secret Current_Cast = (Goedel.Trojan.Script.Secret)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Secret__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Secret__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Secret__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Secret__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Secret Current_Cast = (Goedel.Trojan.Script.Secret)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Output ]");
								}
							}
                        break;


                    case StateCode.Integer_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Integer Current_Cast = (Goedel.Trojan.Script.Integer)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Integer__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Integer__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Integer Current_Cast = (Goedel.Trojan.Script.Integer)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Integer__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Integer__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Integer__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Integer__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Integer Current_Cast = (Goedel.Trojan.Script.Integer)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Output ]");
								}
							}
                        break;


                    case StateCode.Boolean_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Boolean Current_Cast = (Goedel.Trojan.Script.Boolean)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Boolean__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Boolean__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Boolean Current_Cast = (Goedel.Trojan.Script.Boolean)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Boolean__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Boolean__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Boolean__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Boolean__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Boolean Current_Cast = (Goedel.Trojan.Script.Boolean)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Output) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Output ]");
								}
							}
                        break;


                    case StateCode.Output_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Enumerate_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Enumerate Current_Cast = (Goedel.Trojan.Script.Enumerate)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Enumerate__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Enumerate__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Enumerate Current_Cast = (Goedel.Trojan.Script.Enumerate)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Enumerate__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Enumerate__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enumerate__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enumerate__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Enumerate Current_Cast = (Goedel.Trojan.Script.Enumerate)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Radio) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Text) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Radio Text ]");
								}
							}
                        break;


                    case StateCode.Radio_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Radio Current_Cast = (Goedel.Trojan.Script.Radio)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__FieldType, Current_Cast);
                            State = StateCode.Radio__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Radio__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Radio Current_Cast = (Goedel.Trojan.Script.Radio)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Radio__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Radio__Tag:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Wizard_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Wizard Current_Cast = (Goedel.Trojan.Script.Wizard)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__WizardType, Current_Cast);
                            State = StateCode.Wizard__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Wizard__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Wizard Current_Cast = (Goedel.Trojan.Script.Wizard)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Wizard__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Wizard__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Wizard__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Wizard__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Wizard Current_Cast = (Goedel.Trojan.Script.Wizard)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Step) |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Text) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Step Text ]");
								}
							}
                        break;


                    case StateCode.Step_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Trojan.Script.Step Current_Cast = (Goedel.Trojan.Script.Step)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ItemType, Current_Cast);
                            State = StateCode.Step__Id;
                            break;
                            }
                        throw new System.Exception("Expected LABEL or LITERAL");

                    case StateCode.Step__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Trojan.Script.Step Current_Cast = (Goedel.Trojan.Script.Step)Current;
                            Current_Cast.Tag = Text;
                            State = StateCode.Step__Tag;
                            break;
                            }
                        throw new System.Exception("Expected String");

                    case StateCode.Step__Tag:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Step__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Step__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Trojan.Script.Step Current_Cast = (Goedel.Trojan.Script.Step)Current;
                            Goedel.Trojan.Script.GUISchemaType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Trojan.Script.GUISchemaType.Text) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new System.Exception("Parser Error Expected [Text ]");
								}
							}
                        break;



                    default:
                        throw new System.Exception("Unreachable code reached");
                    }
                }
            }
        }
	}


