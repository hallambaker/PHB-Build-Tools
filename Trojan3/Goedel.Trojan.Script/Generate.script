#script 1.0
#license MITLicense
#using System.Linq
#pclass Goedel.Trojan.Script GenerateGTK
#!

#% string GoedelNamespace = "Goedel.Trojan";
#% Separator Separator;
#% public bool FALSE = false;
#method GenerateCS GUISchema GUISchema
#% GUISchema._InitChildren ();

//This file was generated automatically.

using System;
using System.Collections.Generic;
using Goedel.Registry;
using Goedel.Trojan;

#foreach (var GUI in GUISchema.GUIs)

namespace #{GUI.Namespace} {

	// Make extensible partial classes for all the toplevel classes
	// This allows an implementation to decorate any class at will.
	public abstract partial class Object:  #{GoedelNamespace}.Object {
		}
	public abstract partial class Menu:  #{GoedelNamespace}.Menu {
		}
	public abstract partial class Window:  #{GoedelNamespace}.Window {
		}


	/// <summary>
    /// The application data model. This inherits the field declarations and
	/// stub callback methods from the template. The stub callbacks should be
	/// overwritten by the user's code. 
    /// </summary>
	public partial class #{GUI.Id} : _#{GUI.Id} {
		}

	/// <summary>
    /// The template data model  constructed from the specification.
	/// Contains stub methods for each callback.
    /// </summary>
	public abstract class _#{GUI.Id} : #{GoedelNamespace}.Model {

        /// <summary>
        /// Default constructor.
        /// </summary>
        public _#{GUI.Id}() {
            _About = new About(this) {
#if GUI.About != null
				Name = "#{GUI.About.Title}"
#end if
				};
            }




#foreach (var Command in GUI.Commands)
#{CommentSummary(8, Command.CommentSummary)} #!
		public virtual void #{Command.Id} (#!
#if (Command.Parameter != null) 
Object Object #!
#end if		
) {
			}

#end foreach

#!foreach (var Object in GUI.Objects) 
#!		protected #{Object.Id} Selected_#{Object.Id} = null ;
#!end foreach


#{CommentSummary(8, "Dispatch command callback with required parameters.")} #!
        public override void  Dispatch(string Command) {
            switch (Command) {
#foreach (var Command in GUI.Commands) 
#if (Command.Parameter != null) 
                case "#{Command.Id}": {
                        #{Command.Id}(Selected as Object);
#else	
                case "#{Command.Id}": {
                        #{Command.Id}();
#end if
                        return;
                        }
#end foreach
                }
            }

#if FALSE
#{CommentSummary(8, "Report if selection criteria for specified command are met.")} #!
        public bool Active(String Command) {
            switch (Command) {
#foreach (var Command in GUI.Commands) 
#if (Command.Parameter != null) 
                case "#{Command.Id}_#{Command.Parameter}": {
						// NYI here make a list of all the possibilities
                        //return Selected_#{Command.Parameter}# != null;
						return true;
                        }
#end if	
#end foreach
                }
            return true;
            }
#end if
		}


	// Windows

	/*
	* Window declarations
	*/
#foreach (var Window in GUI.Windows) 
#{CommentSummary(8, Window.CommentSummary)} #!
	public partial class #{Window.Id} : _#{Window.Id} {

		string _Title = "#{Window.Tag}";
		public override string Title {
			get {return _Title;}
			set {_Title = value;}
			}

		public #{Window.Id}  (#{GoedelNamespace}.Model Model, Binding Binding) {
			// Call backing code to populate the data model
			Populate ();

			// Initialize the view and controller
			Initialize (Model, Binding);
			}
		}

	public abstract class _#{Window.Id} : Window {

#if (Window.Menu != null)
		Menu _Menu = new #{Window.Menu.Id} ();
        public override #{GoedelNamespace}.Menu Menu { get { return _Menu; } }
#end if		
		}
#end foreach

	/*
	* Menu declarations
	*/
#foreach (var Menu in GUI.Menus) 

#{CommentSummary(8, Menu.CommentSummary)} #!
	public partial class #{Menu.Id} : Menu {
	
		public override List<MenuEntry> Entries {
            get { return _Entries; }
            set { _Entries = value; }
            }

#call MakeMenu Menu
		}


#end foreach

	/*
	* Wizard declarations
	*/

#foreach (var Wizard in GUI.Wizards) 

	/// <summary>
    /// Wizard callback class.
    /// </summary>

	public partial class #{Wizard.Id} : _#{Wizard.Id} {
		}


	/// <summary>
    /// Template class for wizard. The application programmer implements
	/// the wizard by overriding wizard methods. Note that since the user 
	/// may backtrack when implementing a method, callbacks MUST tolerate
	/// being called multiple times. It is also permitted for a user to 
	/// cancel a wizard before the final commit.
    /// </summary>
	public partial class _#{Wizard.Id} : Wizard {

        public override string Title => #{Wizard.Tag.Quoted()};
        public override List<string> Texts => _Texts;
        public override List<Step> Steps => _Steps;

        /// <summary>
        /// Default constructor
        /// </summary>
        /// <param name="Model">Model to bind to</param>
        public _#{Wizard.Id}(Model Model) : base(Model) {
            }


#call DeclareFields Wizard.Entries

		// #{Wizard.Id}
		List<string> _Texts = #!
#call MakeTextList Wizard.Entries
;
		List<Step> _Steps = new List<Step> {#!
#% Separator = new Separator (",");
#foreach (var Entry in Wizard.Entries)
#% var Step = Entry as Step;
#if Step != null
#{Separator}
			new Step () {Value = new #{Step.Id} (), 
				Title = #{Step.Tag.Quoted()}, Description =
		#!
#indent
#indent
#call MakeTextList Step.Entries
#outdent
#outdent
}#!
#end if
#end foreach
};


		public override bool Dispatch (int Step) {

			switch (Step) {
#% int StepNumber = 0;
#foreach (var Entry in Wizard.Entries)
#% var Step = Entry as Step;
#if Step != null
				case #{StepNumber++} : return #{Step.Id.Label()}.Dispatch(this);
#end if
#end foreach
				}
			return false;
			}

		}


#end foreach

	/*
	* Backing object class declarations
	*/
#foreach (var Object in GUI.Objects) 
	public partial class #{Object.Id} #!
#if (Object.ParentObject == null)
: Object #!
#else
: #{Object.ParentObject.Id} #!
#end if	
{

#call DeclareFields Object.Entries

		public override List<ObjectEntry> Entries {
            get { return _Entries; }
            set { _Entries = value; }
            }

		List<ObjectEntry> _Entries = new List<ObjectEntry> {
#% Separator =new Separator (",");
#% MakeWidgets (Object, Separator);
			} ;


        /// <summary>
        /// Create a list containing all the current children.
        /// </summary>
        /// <returns></returns>
        public override List<Goedel.Trojan.Object> GetChildren() {
#if (Object.ParentObject == null)
			var Result = base.GetChildren();
#else 
            var Result = new List<Goedel.Trojan.Object>();
#end if
#foreach (var Entry in Object.Entries)
#switchcast GUISchemaType Entry
#casecast List List
			if (#{List.FieldName}.Value != null) {
				foreach (var Entry in #{List.FieldName}.Value) {
					Result.Add (Entry);
					}
				}
#casecast Set Set
			if (#{Set.FieldName}.Value != null) {
				foreach (var Entry in #{Set.FieldName}.Value) {
					Result.Add (Entry);
					}
				}
#end switchcast				
#end foreach

			return Result;
            }


		}


#end foreach


#end foreach

	}

#end method

#block MakeTextList
#% public void MakeTextList (List<_Choice> Entries) {
#% var Separator = new Separator (",");
		new List<string> {#!
#foreach (var Entry in Entries)
#% var Text = Entry as Text;
#if Text != null
#{Separator}
			#{Text.Data.Quoted()} #!
#end if
#end foreach

			}#!
#% }
#end block 



#method MakeMenu Menu Menu
		List<MenuEntry> _Entries = new List<MenuEntry> {#!
#% var Separator = new Separator (",");
#foreach (var Entry in Menu.Entries)
#switchcast GUISchemaType Entry
#casecast Menu SubMenu
#{Separator}
			new SubMenu () {
				Id ="#{SubMenu.Id}",  
				Label = "#{SubMenu.Tag}", 
				Sub = new #{SubMenu.Id}() }#!
#casecast Action Action
#{Separator}
			new MenuEntry () { 
				Id ="#{Action.Id}",  
				Label = "#{Action.Tag}" }#!
#casecast Divider null
#{Separator}
			new MenuDivider () #!
#end switchcast
#end foreach
};
#end method


#block MakeWidgets
#% public void MakeWidgets (_Choice Choice, Separator Separator) {
#% List<_Choice> Entries = null;
#% var Object = Choice as Object;
#if (Object != null)
#% Entries = Object.Entries;
#if (Object.ParentObject != null)
#% MakeWidgets (Object.ParentObject, Separator);
#end if
#elseif (Choice as Enumerate != null)
#% var Enumerate = Choice as Enumerate;
#% Entries = Enumerate.Entries;
#else
#% var Option = Choice as Option;
#% Entries = Option.Entries;
#end if
#foreach (var Entry in Entries)
#if (Entry as Command != null) 
#{Separator}
			new ObjectCommand {
						Id = "#{Entry.FieldName}",  
						Label = #{Entry.FieldTag.Quoted()}}#!
#elseif (Entry as Inherit != null) 
#elseif (Entry as Action != null) 
#% var Action = Entry as Action;
#{Separator}
			new ObjectAction {
						Id = "#{Entry.FieldName}",  
#if (Entry.Text != null)
						Text = #{Entry.Text.Quoted()},
#end if
						Label = #{Action.Tag.Quoted()}}#!
#elseif (Entry as Text != null) 
#% var Text = Entry as Text;
#{Separator}
			new ObjectText {
						Text = "#{Text}"
						}#!
#elseif (Entry as Enumerate != null) 
#% var Enumerate = Entry as Enumerate;
#{Separator}
			new ObjectFieldEnumerate {
						Id = "#{Entry.FieldName}",  
						Label = "#{Entry.FieldTag}",
						Entries = new List<ObjectEntry> {#!
#% var SubSeparator = new Separator (",");
#foreach (var RadioEntry in Enumerate.Entries)
#{SubSeparator}
				new ObjectFieldRadio {
						Id = "#{RadioEntry.FieldName}",  
						Label = "#{RadioEntry.FieldTag}",
						SelectionValue = (int) Enum#{Entry.FieldName}.#{RadioEntry.FieldName}  } #!
#end foreach
							}
						}#!
#elseif (Entry as Item != null) 
#{Separator}
			new ObjectFieldItem {
						Id = "#{Entry.FieldName}",  
						Label = "#{Entry.FieldTag}",
						Value = new #{Entry.FieldType} () 
						}#!
#elseif (Entry as Option != null) 
#% var Option = Entry as Option;
#{Separator}	
			new ObjectFieldOption {
						Id = "#{Entry.FieldName}",  
						Label = "#{Entry.FieldTag}",
#if (Entry.Output)
						ReadOnly = true,
#end if
						Entries = new List<ObjectEntry> {#!
#indent
#% var SubSeparator = new Separator (",");
#%  MakeWidgets (Option, SubSeparator);
#outdent

							}
						}#!
#elseif (Entry as Output != null) 
#else 
#{Separator}
			new ObjectField#{Entry.WidgetType} {Id = "#{Entry.FieldName}", 
#! Do not need to check if these are permitted here as Goedel syntax check does that.
#if (Entry as List != null)
						Prototype = new #{(Entry as List).Of} (),
#end if
#if (Entry.Output)
						ReadOnly = true,
#end if
#if (Entry.Tip != null)
						Tip = #{Entry.Tip.Quoted()},
#end if
#if (Entry.IsSlider)
						Mode = FieldModeInteger.Slider,
#end if
#if (Entry.Range != null)
						Minimum = #{Entry.Range.Lower},
						Maximum = #{Entry.Range.Upper},
						Step = #{Entry.Range.Step},
#end if
#if (Entry.Length != null)
						Length = #{Entry.Length},
#end if
						Label = "#{Entry.FieldTag}" // #{Entry.FieldIndex}
					    }#!
#end if
#end foreach
#% }
#end block



#method MakeFieldArray Object Object
#if (Object.ParentObject != null)
#call MakeFieldArray Object.ParentObject
#end if
#foreach (var Entry in Object.Entries)
#if ((Entry.FieldNumber >= 0))
#{Separator}
			new FieldValue#{Entry.WidgetType} ()  /* #{Entry.FieldName} #{Entry.FieldNumber} */ #!
#end if	
#end foreach
#end method


#method DeclareFields List<_Choice> Entries
#foreach (var Entry in Entries)
#if (Entry.FieldType != null)
#if (Entry as Enumerate != null) 
		public enum #{Entry.FieldType} {#!
#% Separator = new Separator (",");
#foreach (var EnumEntry in (Entry as Enumerate).Entries)
#switchcast GUISchemaType EnumEntry
#casecast Radio Radio
#{Separator}
			#{Radio.Id}  /* #{Radio.Tag} */
#end switchcast
#end foreach
			};
		public ObjectFieldEnumerate #{Entry.FieldName}  {
			get {
				return #{Entry.FieldIndex};
				}
			}
#else
		/// <summary>
        /// #{Entry.FieldName}
        /// </summary>
#if (Entry as Item != null)
		public #{Entry.FieldType} #{Entry.FieldName} {
			get {
				return (#{Entry.FieldType}) (#{Entry.FieldIndex}).Value;
				}
#elseif (Entry as Step != null)
		public #{Entry.FieldType} #{Entry.FieldName} {
			get {
				return (#{Entry.FieldType}) #{Entry.FieldIndex};
				}
#else
		public ObjectField#{Entry.WidgetType} #{Entry.FieldName} {
			get {
				return #{Entry.FieldIndex};
				}
#end if

			}
			
#end if
#end if
#switchcast GUISchemaType Entry
#casecast Item null
#casecast List null
#casecast Set null
#casecast Option Option
#call DeclareFields Option.Entries
#end switchcast
#end foreach
#end method

#end pclass
