#script 1.0
#license MITLicense
#xclass Goedel.Tool.Makey Generate
#%  public Generate (TextWriter Output) : base (Output) {}
#% string Prefix = "! "; //"\t";


#method Preamble VSFile VSFile
##
## Makefile for Visual Studio Project ...
##
## This file is generated automatically from the Visual Studio Project
## File. If you make changes to this file and do not update the project
## file, changes will be lost when the file is regenerated.

## The following targets are defined (well planned)
##
## make 			Compile for the current platform
## make cross		Compile for all platforms
## make install		Compile and install
## make clean		Delete all target and intermediate files

## The following build flags are supported
##
## make mode= release | debug			Build release or debug version
## make arch= this | all | <x>			Bundle for the current platform, all platforms
##										or the specified platform

## Define the default target directories (referenced projects must all follow same scheme)
##
## By default, we arrange the mono targets as follows:
##
## <Source>					The source code directory
## <Source>/mono/			Equivalent to VS bin directory
## <Source>/mono/Debug		Equivalent to VS bin/Debug directory
## <Source>/mono/Release	Equivalent to VS bin/Debug directory
##
## If the target is an executable, the following directories are also created:
##
## <Source>/This			The bundled executable for the platform the code was compiled on
## <Source>/<Arch1>			The bundled executable for the platform <Arch1>	
##
## If the install target is selected, the bundles will be installed in
##
## ~/Tools/This				The bundled executable for platform the code is built on
## ~/Tools/<Arch1>			The bundled executable for this platform <Arch1>	

export TARGETROOT	?= mono
export MODE			?= Release
export ARCH			?= This
export Packages		?= ~/Packages
export PackagesPath ?= /lib/net40

export TARGETBIN	= $(TARGETROOT)/$(MODE)
export TARGETEXE	= $(TARGETROOT)/$(ARCH)

export DESTDIR		?= ~/.local
export bindir		?= /bin
export libdir		?= /lib
export INSTALL_PROGRAM	?= $(DESTDIR)$(bindir)
export INSTALL_DATA		?= $(DESTDIR)$(bindir)

## Define the default compilers, linkers, packagers, etc.
export CSHARPDLL	?=  mcs /target:library
export CSHARPEXE	?=  mcs /target:exe
export BUNDLE		?=  mkbundle --deps --static -o 



## The following tools are used in the goedel build system itself:
#% PHBTool ("RFC2TXT",		"rfctool /in", "/txt");
#% PHBTool ("RFC2XML",		"rfctool /in", "/xml");
#% PHBTool ("RFC2MD",		"rfctool /in", "/md");
#% PHBTool ("RFC2HTML",		"rfctool /in", "/html");
#% PHBTool ("CommandCS",	"commandparse /in", "/cs");
#% PHBTool ("FSRCS",		"fsrgen /in", "/cs");
#% PHBTool ("Exceptional",	"exceptional /in", "/cs");
#% PHBTool ("GScript",		"gscript /in", "/cs");
#% PHBTool ("Goedel3",		"goedel3 /in", "/cs");
#% PHBTool ("ASN2CS",		"asn2 /in", "/cs");
#% PHBTool ("DomainerCS",	"domainer /in", "/cs");
#% PHBTool ("RegistryCS",	"registryconfig /in", "/cs");
#% PHBTool ("VSIXBuild",	"vsixbuild /in", "/cs");
#% PHBTool ("ProtoGen",		"protogen /in", "/cs");
#% PHBTool ("TrojanGTK",	"trojan /gtk", "/cs");

#if (Prefix != "\t")
## Use the specified character as the prefix character. Note this may not 
## be supported on versions of make other than gmake.
.RECIPEPREFIX = #{Prefix}
#end if
#end method


#method GenerateMakefile VSSolution Solution
#call Preamble Solution

## The main target

.PHONY all

## Need to identify the target directory using UnixPath()
## This file in directory #{Solution.Directory}

#foreach (var Item in Solution.Projects)
#% var Project = Item.Project;
#% var TargetPath = Item.Directory.UnixPath (Project.Target);
#if (Project.Target != null)
all :  #{Project.Target}

#foreach (var Dep in Project.LinkDependency)
#% var DepPath = Item.Directory.UnixFile (Dep);
#{TargetPath} : #{DepPath}
#end foreach
#{TargetPath} :
#{Prefix}$(MAKE) -C #{Project.Directory}

#end if
#end foreach

#end method



#method GenerateMakefile VSProject Project
#call Preamble Project

## The main target

#if (Project.IsExe)
$(TARGETEXE)/#{Project.AssemblyName} :| $(TARGETEXE)
$(TARGETEXE)/#{Project.AssemblyName} : $(TARGETBIN)/#{Project.AssemblyName}.exe 
#{Prefix}$(BUNDLE) $@ $^


$(TARGETBIN)/#{Project.Target} :| $(TARGETBIN)
#foreach (var File in Project.SourceDependency)
$(TARGETBIN)/#{Project.Target} : #{File.UnixFile()} 
#end foreach
#foreach (var File in Project.LinkDependency)
$(TARGETBIN)/#{Project.Target} : $(TARGETBIN)/#{File}.dll
#end foreach

$(TARGETBIN/)#{Project.Target} :
#{Prefix}$(CSHARPEXE) /out:$@ $^


#elseif (Project.IsLibrary)
$(TARGETBIN)/#{Project.Target} :| $(TARGETBIN)
#foreach (var File in Project.SourceDependency)
$(TARGETBIN)/#{Project.Target} : #{File}
#end foreach
#foreach (var File in Project.LinkDependency)
$(TARGETBIN)/#{Project.Target} : $(TARGETBIN)/#{File}.dll
#end foreach
#foreach (var Item in Project.PrivateReference)
$(TARGETBIN)/#{Project.Target} : $(TARGETBIN)/#{Item.Name}.dll
#end foreach

$(TARGETBIN)#{Project.Target} : 
#{Prefix}$(CSHARPDLL) /out:$@ $^

#else
#end if

## Directories etc.

$(INSTALL_PROGRAM) :
#{Prefix}mkdir -p $(INSTALL_PROGRAM) 

$(INSTALL_DATA) :
#{Prefix}mkdir -p $(INSTALL_DATA) 

$(TARGETBIN) :
#{Prefix}mkdir -p $(TARGETBIN) 

$(TARGETEXE) :
#{Prefix}mkdir -p $(TARGETEXE) 


## Generated code

#foreach (var Item in Project.None)
#if (Item.Generator != null)
#{Item.LastGenOutput} : #{Item.Include}
#{Prefix} $(Custom_#{Item.Generator}) #{Item.Include} $(Custom_#{Item.Generator}_FLAG) #{Item.LastGenOutput} 
#end if
#end foreach

.PHONY : clean install cross recursive


## Referenced projects
##

## Recursive make targets, do not execute if the variable NORECURSE is defined
ifndef NORECURSE

#foreach (var Item in Project.ProjectReference)
#{Item.Include.UnixPath()}/$(TARGETBIN)/#{Item.SubProject.AssemblyName}.dll : recursive
#{Prefix}$(MAKE) -C #{Item.Include.UnixPath()}

#end foreach
endif

# copy libraries into the base library
#foreach (var Item in Project.ProjectReference)
$(TARGETBIN)/#{Item.SubProject.AssemblyName}.dll : #{Item.Include.UnixPath()}/$(TARGETBIN)/#{Item.SubProject.AssemblyName}.dll
#{Prefix} cp #{Item.Include.UnixPath()}/$(TARGETBIN)/#{Item.SubProject.AssemblyName}.dll $(TARGETBIN)/#{Item.SubProject.AssemblyName}.dll

#end foreach

## Referenced Libraries
##
#foreach (var Item in Project.PrivateReference)
$(TARGETBIN)/#{Item.Name} : #{Item.HintPath.UnixFile()}
#{Prefix} cp   #{Item.HintPath.UnixFile()} $(TARGETBIN)/#{Item.Name}
#end foreach


## Clean up
##
## At the moment we only delete the currently indicated target. This allows a 
## developer to do a make clean / make when a problem with a corrupted intermediate
## file is suspected.

clean : 
#{Prefix}rm -f $(TARGETBIN)/*
#{Prefix}rm -f $(TARGETEXE)/*

## Install
##
## Install files to a tools directory. Default is ~/.local/bin


#if (Project.IsExe)
install : $(INSTALL_PROGRAM)/#{Project.AssemblyName} 

$(INSTALL_PROGRAM)/#{Project.AssemblyName}  :| $(INSTALL_PROGRAM)
$(INSTALL_PROGRAM)/#{Project.AssemblyName}  : $(TARGETEXE)/#{Project.AssemblyName} 
#{Prefix}cp $^ $@ 

#elseif (Project.OutputType == "Library")
install : $(INSTALL_DATA)/#{Project.AssemblyName}.dll

$(INSTALL_DATA)/#{Project.AssemblyName}.dll :| $(INSTALL_DATA)
$(INSTALL_DATA)/#{Project.AssemblyName}.dll : $(TARGETBIN)/#{Project.AssemblyName}.dll
#{Prefix}cp $^ $@ 

#end if

## Cross
##
## Cross compilation targets. 


#if (Project.IsExe)
#foreach (var Arch in Project.CrossTargets)
cross : $(TARGETROOT)/#{Arch}/#{Project.AssemblyName} 
$(TARGETROOT)/#{Arch}/#{Project.AssemblyName} : $(TARGETBIN)/#{Project.AssemblyName}.exe
#{Prefix}mkdir -p $(TARGETROOT)/#{Arch}/#{Project.AssemblyName} 
#{Prefix}$(BUNDLE) $@ --cross ${Arch} $^

#end foreach
#end if

#end method

#method3 PHBTool string Tag string Tool string Flag
export Custom_#{Tag}		?= #{Tool}
export Custom_#{Tag}_FLAG	?= #{Flag}
#end method3


#end xclass