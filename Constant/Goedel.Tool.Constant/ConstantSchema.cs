
//  Copyright (c) ThresholdSecrets by 2020
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;


//
// Namespace Goedel.Tool.Constant
// Class Constant
//


// Types
//   TopTypeType
//       Namespace
//       File
//   TypeType
//       Code
//       String
//       Function
//       Enum
//       IANA
//       Parameters
//       Conv
//   IdType
//       Filename
//   NamespaceType
//       Goedel.Tool.Constant
//   ClassType
//       Constant
//   NameType
//       Id
//       Class
//       Text
//       Entries
//       Title
//       Options
//       Description
//       Value
//       Integer
//       Tag
//       UDF
//       Algorithm
//       Compress
//       Note
//       Bits
//       Reserve
//       End
//       Type
//       Return
//       Parameter
//       Formula
//       Convert
//   TokenType
//       Name
//       Label

namespace Goedel.Tool.Constant {


    public enum ConstantType {
        _Top,

        Namespace,
        File,
        IANA,
        Code,
        String,
        Parameters,
        Enum,
        Tag,
        UDF,
        Note,
        Algorithm,
        Compress,
        Integer,
        Reserve,
        Function,
        Description,
        Parameter,
        Conv,
        Formula,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public ConstantType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);

		public virtual void Init (_Choice Parent) {
			}

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice Parent) {
			Init (Parent);
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Namespace : _Choice {
        public TOKEN<_Choice>			Id;
        public TOKEN<_Choice>			Class;
		public List <System.String>			Text = new List <System.String> (); 

        public override ConstantType _Tag () {
            return ConstantType.Namespace;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Namespace");
				}

	        Output.WriteId ("Id", Id.ToString());
	        Output.WriteId ("Class", Class.ToString());
			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("Namespace");
				}			
			}
		}

    public partial class File : _Choice {
        public ID<_Choice>				Id; 
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ConstantType _Tag () {
            return ConstantType.File;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("File");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("File");
				}			
			}
		}

    public partial class IANA : _Choice {
        public REF<_Choice>				Id;
		public string					Title;
		public Description  Description = new  Description();

        public override ConstantType _Tag () {
            return ConstantType.IANA;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("IANA");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
		// public Description  Description = new  Description();
			Description.Serialize (Output, true);
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("IANA");
				}			
			}
		}

    public partial class Code : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Title;
		public Description  Description = new  Description();

        public override ConstantType _Tag () {
            return ConstantType.Code;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Code");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
		// public Description  Description = new  Description();
			Description.Serialize (Output, true);
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Code");
				}			
			}
		}

    public partial class String : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Value;
		public Description  Description = new  Description();

        public override ConstantType _Tag () {
            return ConstantType.String;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("String");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Value", Value);
			Output.StartList ("");
		// public Description  Description = new  Description();
			Description.Serialize (Output, true);
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("String");
				}			
			}
		}

    public partial class Parameters : _Choice {
        public ID<_Choice>				Id; 
		public string					Title;
		public List<Integer>  Integer = new  List <Integer> ();
		public List<Tag>  Tag = new  List <Tag> ();

        public override ConstantType _Tag () {
            return ConstantType.Parameters;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Parameters");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
			foreach (Integer _e in Integer) {
				_e.Serialize (Output, true);
				}
			foreach (Tag _e in Tag) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Parameters");
				}			
			}
		}

    public partial class Enum : _Choice {
        public ID<_Choice>				Id; 
		public string					Title;
		public List<Code>  Code = new  List <Code> ();
		public List<UDF>  UDF = new  List <UDF> ();
		public List<Integer>  Integer = new  List <Integer> ();
		public List<Tag>  Tag = new  List <Tag> ();

        public override ConstantType _Tag () {
            return ConstantType.Enum;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Enum");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
			foreach (Code _e in Code) {
				_e.Serialize (Output, true);
				}
			foreach (UDF _e in UDF) {
				_e.Serialize (Output, true);
				}
			foreach (Integer _e in Integer) {
				_e.Serialize (Output, true);
				}
			foreach (Tag _e in Tag) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Enum");
				}			
			}
		}

    public partial class Tag : _Choice {
        public ID<_Choice>				Id; 
		public string					Value;

        public override ConstantType _Tag () {
            return ConstantType.Tag;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Tag");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Value", Value);
			if (tag) {
				Output.EndElement ("Tag");
				}			
			}
		}

    public partial class UDF : _Choice {
		public int						Value;
        public TOKEN<_Choice>			Class;
		public Algorithm  Algorithm = new  Algorithm();
		public Compress  Compress = new  Compress();
		public Note  Note = new  Note();

        public override ConstantType _Tag () {
            return ConstantType.UDF;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("UDF");
				}

			Output.WriteAttribute ("Value", Value);
	        Output.WriteId ("Class", Class.ToString());
			Output.StartList ("");
		// public Algorithm  Algorithm = new  Algorithm();
			Algorithm.Serialize (Output, true);
		// public Compress  Compress = new  Compress();
			Compress.Serialize (Output, true);
		// public Note  Note = new  Note();
			Note.Serialize (Output, true);
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("UDF");
				}			
			}
		}

    public partial class Note : _Choice {
		public string					Text;

        public override ConstantType _Tag () {
            return ConstantType.Note;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Note");
				}

			Output.WriteAttribute ("Text", Text);
			if (tag) {
				Output.EndElement ("Note");
				}			
			}
		}

    public partial class Algorithm : _Choice {
        public TOKEN<_Choice>			Id;

        public override ConstantType _Tag () {
            return ConstantType.Algorithm;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Algorithm");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Algorithm");
				}			
			}
		}

    public partial class Compress : _Choice {
		public int						Bits;

        public override ConstantType _Tag () {
            return ConstantType.Compress;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Compress");
				}

			Output.WriteAttribute ("Bits", Bits);
			if (tag) {
				Output.EndElement ("Compress");
				}			
			}
		}

    public partial class Integer : _Choice {
        public TOKEN<_Choice>			Id;
		public int						Value;
		public string					Title;
		public Description  Description = new  Description();
		public Reserve  Reserve = new  Reserve();

        public override ConstantType _Tag () {
            return ConstantType.Integer;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Integer");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Value", Value);
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
		// public Description  Description = new  Description();
			Description.Serialize (Output, true);
		// public Reserve  Reserve = new  Reserve();
			Reserve.Serialize (Output, true);
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Integer");
				}			
			}
		}

    public partial class Reserve : _Choice {
		public int						End;

        public override ConstantType _Tag () {
            return ConstantType.Reserve;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Reserve");
				}

			Output.WriteAttribute ("End", End);
			if (tag) {
				Output.EndElement ("Reserve");
				}			
			}
		}

    public partial class Function : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Title;
		public string					Type;
        public TOKEN<_Choice>			Return;
		public List<Parameter>  Parameter = new  List <Parameter> ();
		public Description  Description = new  Description();
		public List<Formula>  Formula = new  List <Formula> ();

        public override ConstantType _Tag () {
            return ConstantType.Function;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Function");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Title", Title);
			Output.WriteAttribute ("Type", Type);
	        Output.WriteId ("Return", Return.ToString());
			Output.StartList ("");
			foreach (Parameter _e in Parameter) {
				_e.Serialize (Output, true);
				}
		// public Description  Description = new  Description();
			Description.Serialize (Output, true);
			foreach (Formula _e in Formula) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Function");
				}			
			}
		}

    public partial class Description : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override ConstantType _Tag () {
            return ConstantType.Description;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Description");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("Description");
				}			
			}
		}

    public partial class Parameter : _Choice {
        public TOKEN<_Choice>			Id;
        public TOKEN<_Choice>			Type;
		public string					Title;
		public Conv  Convert = new  Conv();

        public override ConstantType _Tag () {
            return ConstantType.Parameter;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Parameter");
				}

	        Output.WriteId ("Id", Id.ToString());
	        Output.WriteId ("Type", Type.ToString());
			Output.WriteAttribute ("Title", Title);
			Output.StartList ("");
		// public Conv  Convert = new  Conv();
			Convert.Serialize (Output, true);
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Parameter");
				}			
			}
		}

    public partial class Conv : _Choice {
		public string					Type;

        public override ConstantType _Tag () {
            return ConstantType.Conv;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Conv");
				}

			Output.WriteAttribute ("Type", Type);
			if (tag) {
				Output.EndElement ("Conv");
				}			
			}
		}

    public partial class Formula : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Type;
		public List <System.String>			Text = new List <System.String> (); 

        public override ConstantType _Tag () {
            return ConstantType.Formula;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Formula");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Type", Type);
			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("Formula");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override ConstantType _Tag () {
            return ConstantType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Namespace_Start,
		Namespace__Id,				
		Namespace__Class,				
		Namespace__Text,				
		File_Start,
		File__Id,				
		File__Entries,				
		IANA_Start,
		IANA__Id,				
		IANA__Title,				
		IANA__Options,				
		Code_Start,
		Code__Id,				
		Code__Title,				
		Code__Options,				
		String_Start,
		String__Id,				
		String__Value,				
		String__Options,				
		Parameters_Start,
		Parameters__Id,				
		Parameters__Title,				
		Parameters__Options,				
		Enum_Start,
		Enum__Id,				
		Enum__Title,				
		Enum__Options,				
		Tag_Start,
		Tag__Id,				
		Tag__Value,				
		UDF_Start,
		UDF__Value,				
		UDF__Class,				
		UDF__Options,				
		Note_Start,
		Note__Text,				
		Algorithm_Start,
		Algorithm__Id,				
		Compress_Start,
		Compress__Bits,				
		Integer_Start,
		Integer__Id,				
		Integer__Value,				
		Integer__Title,				
		Integer__Options,				
		Reserve_Start,
		Reserve__End,				
		Function_Start,
		Function__Id,				
		Function__Title,				
		Function__Type,				
		Function__Return,				
		Function__Options,				
		Description_Start,
		Description__Text,				
		Parameter_Start,
		Parameter__Id,				
		Parameter__Type,				
		Parameter__Title,				
		Parameter__Options,				
		Conv_Start,
		Conv__Type,				
		Formula_Start,
		Formula__Id,				
		Formula__Type,				
		Formula__Text,				
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Tool.Constant._Choice     Token;
        }

    public partial class Constant : Goedel.Registry.Parser{
        public List <Goedel.Tool.Constant._Choice>        Top;
        public Registry	<Goedel.Tool.Constant._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        Goedel.Tool.Constant._Choice				Current;
        List <_StackItem>						Stack;


        public static Constant Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new Constant();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
				Entry._InitChildren (null);
				}
			}

        public Constant() {
            Top = new List<Goedel.Tool.Constant._Choice> () ;
            Registry = new Registry <Goedel.Tool.Constant._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;

			TYPE__Filename = Registry.TYPE ("Filename"); 
			TYPE__Name = Registry.TYPE ("Name"); 
			TYPE__Label = Registry.TYPE ("Label"); 



            }



        public TYPE<Goedel.Tool.Constant._Choice> TYPE__Filename ;
        public TYPE<Goedel.Tool.Constant._Choice> TYPE__Name ;
        public TYPE<Goedel.Tool.Constant._Choice> TYPE__Label ;

        private Goedel.Tool.Constant._Choice New_Choice(string Label) {
            switch (Label) {

                case "Namespace": return NewNamespace();
                case "File": return NewFile();
                case "IANA": return NewIANA();
                case "Code": return NewCode();
                case "String": return NewString();
                case "Parameters": return NewParameters();
                case "Enum": return NewEnum();
                case "Tag": return NewTag();
                case "UDF": return NewUDF();
                case "Note": return NewNote();
                case "Algorithm": return NewAlgorithm();
                case "Compress": return NewCompress();
                case "Integer": return NewInteger();
                case "Reserve": return NewReserve();
                case "Function": return NewFunction();
                case "Description": return NewDescription();
                case "Parameter": return NewParameter();
                case "Conv": return NewConv();
                case "Formula": return NewFormula();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Tool.Constant.Namespace NewNamespace() {
            Goedel.Tool.Constant.Namespace result = new Goedel.Tool.Constant.Namespace();
            Push (result);
            State = StateCode.Namespace_Start;
            return result;
            }


        private Goedel.Tool.Constant.File NewFile() {
            Goedel.Tool.Constant.File result = new Goedel.Tool.Constant.File();
            Push (result);
            State = StateCode.File_Start;
            return result;
            }


        private Goedel.Tool.Constant.IANA NewIANA() {
            Goedel.Tool.Constant.IANA result = new Goedel.Tool.Constant.IANA();
            Push (result);
            State = StateCode.IANA_Start;
            return result;
            }


        private Goedel.Tool.Constant.Code NewCode() {
            Goedel.Tool.Constant.Code result = new Goedel.Tool.Constant.Code();
            Push (result);
            State = StateCode.Code_Start;
            return result;
            }


        private Goedel.Tool.Constant.String NewString() {
            Goedel.Tool.Constant.String result = new Goedel.Tool.Constant.String();
            Push (result);
            State = StateCode.String_Start;
            return result;
            }


        private Goedel.Tool.Constant.Parameters NewParameters() {
            Goedel.Tool.Constant.Parameters result = new Goedel.Tool.Constant.Parameters();
            Push (result);
            State = StateCode.Parameters_Start;
            return result;
            }


        private Goedel.Tool.Constant.Enum NewEnum() {
            Goedel.Tool.Constant.Enum result = new Goedel.Tool.Constant.Enum();
            Push (result);
            State = StateCode.Enum_Start;
            return result;
            }


        private Goedel.Tool.Constant.Tag NewTag() {
            Goedel.Tool.Constant.Tag result = new Goedel.Tool.Constant.Tag();
            Push (result);
            State = StateCode.Tag_Start;
            return result;
            }


        private Goedel.Tool.Constant.UDF NewUDF() {
            Goedel.Tool.Constant.UDF result = new Goedel.Tool.Constant.UDF();
            Push (result);
            State = StateCode.UDF_Start;
            return result;
            }


        private Goedel.Tool.Constant.Note NewNote() {
            Goedel.Tool.Constant.Note result = new Goedel.Tool.Constant.Note();
            Push (result);
            State = StateCode.Note_Start;
            return result;
            }


        private Goedel.Tool.Constant.Algorithm NewAlgorithm() {
            Goedel.Tool.Constant.Algorithm result = new Goedel.Tool.Constant.Algorithm();
            Push (result);
            State = StateCode.Algorithm_Start;
            return result;
            }


        private Goedel.Tool.Constant.Compress NewCompress() {
            Goedel.Tool.Constant.Compress result = new Goedel.Tool.Constant.Compress();
            Push (result);
            State = StateCode.Compress_Start;
            return result;
            }


        private Goedel.Tool.Constant.Integer NewInteger() {
            Goedel.Tool.Constant.Integer result = new Goedel.Tool.Constant.Integer();
            Push (result);
            State = StateCode.Integer_Start;
            return result;
            }


        private Goedel.Tool.Constant.Reserve NewReserve() {
            Goedel.Tool.Constant.Reserve result = new Goedel.Tool.Constant.Reserve();
            Push (result);
            State = StateCode.Reserve_Start;
            return result;
            }


        private Goedel.Tool.Constant.Function NewFunction() {
            Goedel.Tool.Constant.Function result = new Goedel.Tool.Constant.Function();
            Push (result);
            State = StateCode.Function_Start;
            return result;
            }


        private Goedel.Tool.Constant.Description NewDescription() {
            Goedel.Tool.Constant.Description result = new Goedel.Tool.Constant.Description();
            Push (result);
            State = StateCode.Description_Start;
            return result;
            }


        private Goedel.Tool.Constant.Parameter NewParameter() {
            Goedel.Tool.Constant.Parameter result = new Goedel.Tool.Constant.Parameter();
            Push (result);
            State = StateCode.Parameter_Start;
            return result;
            }


        private Goedel.Tool.Constant.Conv NewConv() {
            Goedel.Tool.Constant.Conv result = new Goedel.Tool.Constant.Conv();
            Push (result);
            State = StateCode.Conv_Start;
            return result;
            }


        private Goedel.Tool.Constant.Formula NewFormula() {
            Goedel.Tool.Constant.Formula result = new Goedel.Tool.Constant.Formula();
            Push (result);
            State = StateCode.Formula_Start;
            return result;
            }


        static Goedel.Tool.Constant.ConstantType _Reserved(string Label) {
            switch (Label) {

                case "Namespace": return Goedel.Tool.Constant.ConstantType.Namespace;
                case "File": return Goedel.Tool.Constant.ConstantType.File;
                case "IANA": return Goedel.Tool.Constant.ConstantType.IANA;
                case "Code": return Goedel.Tool.Constant.ConstantType.Code;
                case "String": return Goedel.Tool.Constant.ConstantType.String;
                case "Parameters": return Goedel.Tool.Constant.ConstantType.Parameters;
                case "Enum": return Goedel.Tool.Constant.ConstantType.Enum;
                case "Tag": return Goedel.Tool.Constant.ConstantType.Tag;
                case "UDF": return Goedel.Tool.Constant.ConstantType.UDF;
                case "Note": return Goedel.Tool.Constant.ConstantType.Note;
                case "Algorithm": return Goedel.Tool.Constant.ConstantType.Algorithm;
                case "Compress": return Goedel.Tool.Constant.ConstantType.Compress;
                case "Integer": return Goedel.Tool.Constant.ConstantType.Integer;
                case "Reserve": return Goedel.Tool.Constant.ConstantType.Reserve;
                case "Function": return Goedel.Tool.Constant.ConstantType.Function;
                case "Description": return Goedel.Tool.Constant.ConstantType.Description;
                case "Parameter": return Goedel.Tool.Constant.ConstantType.Parameter;
                case "Conv": return Goedel.Tool.Constant.ConstantType.Conv;
                case "Formula": return Goedel.Tool.Constant.ConstantType.Formula;

                }
            return Goedel.Tool.Constant.ConstantType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Tool.Constant._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Tool.Constant._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.False (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.False (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Tool.Constant.ConstantType.Namespace) |
									(LabelType == Goedel.Tool.Constant.ConstantType.File)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Namespace_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Namespace Current_Cast = (Goedel.Tool.Constant.Namespace)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Name, Current_Cast);
                            State = StateCode.Namespace__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Namespace__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Namespace Current_Cast = (Goedel.Tool.Constant.Namespace)Current;
                            Current_Cast.Class = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Namespace__Class;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Namespace__Class:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Namespace__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Namespace__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Constant.Namespace Current_Cast = (Goedel.Tool.Constant.Namespace)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.File_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.File Current_Cast = (Goedel.Tool.Constant.File)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__Filename, Current_Cast);
                            State = StateCode.File__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.File__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.File__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.File__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.File Current_Cast = (Goedel.Tool.Constant.File)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Constant.ConstantType.Code) |
									(LabelType == Goedel.Tool.Constant.ConstantType.String) |
									(LabelType == Goedel.Tool.Constant.ConstantType.Function) |
									(LabelType == Goedel.Tool.Constant.ConstantType.Enum) |
									(LabelType == Goedel.Tool.Constant.ConstantType.IANA) |
									(LabelType == Goedel.Tool.Constant.ConstantType.Parameters) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Code String Function Enum IANA Parameters ]");
								}
							}
                        break;


                    case StateCode.IANA_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.IANA Current_Cast = (Goedel.Tool.Constant.IANA)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.IANA__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.IANA__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.IANA Current_Cast = (Goedel.Tool.Constant.IANA)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.IANA__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.IANA__Title:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.IANA__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.IANA__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.IANA Current_Cast = (Goedel.Tool.Constant.IANA)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Description : {

									// Description  Description
									Current_Cast.Description = NewDescription ();
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Description ]");
									}
								}
							}
                        break;

                    case StateCode.Code_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Code Current_Cast = (Goedel.Tool.Constant.Code)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Code__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Code__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Code Current_Cast = (Goedel.Tool.Constant.Code)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Code__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Code__Title:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Code__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Code__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.Code Current_Cast = (Goedel.Tool.Constant.Code)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Description : {

									// Description  Description
									Current_Cast.Description = NewDescription ();
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Description ]");
									}
								}
							}
                        break;

                    case StateCode.String_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.String Current_Cast = (Goedel.Tool.Constant.String)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.String__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.String__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.String Current_Cast = (Goedel.Tool.Constant.String)Current;
                            Current_Cast.Value = Text;
                            State = StateCode.String__Value;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.String__Value:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.String__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.String__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.String Current_Cast = (Goedel.Tool.Constant.String)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Description : {

									// Description  Description
									Current_Cast.Description = NewDescription ();
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Description ]");
									}
								}
							}
                        break;

                    case StateCode.Parameters_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Parameters Current_Cast = (Goedel.Tool.Constant.Parameters)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Parameters__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Parameters__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Parameters Current_Cast = (Goedel.Tool.Constant.Parameters)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Parameters__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Parameters__Title:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Parameters__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Parameters__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.Parameters Current_Cast = (Goedel.Tool.Constant.Parameters)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Integer : {

									// Integer  Integer
									Current_Cast.Integer.Add (NewInteger ());
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Tag : {

									// Tag  Tag
									Current_Cast.Tag.Add (NewTag ());
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Integer Tag ]");
									}
								}
							}
                        break;

                    case StateCode.Enum_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Enum Current_Cast = (Goedel.Tool.Constant.Enum)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Enum__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Enum__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Enum Current_Cast = (Goedel.Tool.Constant.Enum)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Enum__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Enum__Title:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Enum__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Enum__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.Enum Current_Cast = (Goedel.Tool.Constant.Enum)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Code : {

									// Code  Code
									Current_Cast.Code.Add (NewCode ());
									break;
									}
								case Goedel.Tool.Constant.ConstantType.UDF : {

									// UDF  UDF
									Current_Cast.UDF.Add (NewUDF ());
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Integer : {

									// Integer  Integer
									Current_Cast.Integer.Add (NewInteger ());
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Tag : {

									// Tag  Tag
									Current_Cast.Tag.Add (NewTag ());
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Code UDF Integer Tag ]");
									}
								}
							}
                        break;

                    case StateCode.Tag_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Tag Current_Cast = (Goedel.Tool.Constant.Tag)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Tag__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Tag__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Tag Current_Cast = (Goedel.Tool.Constant.Tag)Current;
                            Current_Cast.Value = Text;
                            State = StateCode.Tag__Value;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Tag__Value:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.UDF_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Constant.UDF Current_Cast = (Goedel.Tool.Constant.UDF)Current;
                            Current_Cast.Value = Convert.ToInt32(Text);
                            State = StateCode.UDF__Value;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.UDF__Value:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.UDF Current_Cast = (Goedel.Tool.Constant.UDF)Current;
                            Current_Cast.Class = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.UDF__Class;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.UDF__Class:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.UDF__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.UDF__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.UDF Current_Cast = (Goedel.Tool.Constant.UDF)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Algorithm : {

									// Algorithm  Algorithm
									Current_Cast.Algorithm = NewAlgorithm ();
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Compress : {

									// Compress  Compress
									Current_Cast.Compress = NewCompress ();
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Note : {

									// Note  Note
									Current_Cast.Note = NewNote ();
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Algorithm Compress Note ]");
									}
								}
							}
                        break;

                    case StateCode.Note_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Note Current_Cast = (Goedel.Tool.Constant.Note)Current;
                            Current_Cast.Text = Text;
                            State = StateCode.Note__Text;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Note__Text:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Algorithm_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Algorithm Current_Cast = (Goedel.Tool.Constant.Algorithm)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Algorithm__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Algorithm__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Compress_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Constant.Compress Current_Cast = (Goedel.Tool.Constant.Compress)Current;
                            Current_Cast.Bits = Convert.ToInt32(Text);
                            State = StateCode.Compress__Bits;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Compress__Bits:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Integer_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Integer Current_Cast = (Goedel.Tool.Constant.Integer)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Integer__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Integer__Id:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Constant.Integer Current_Cast = (Goedel.Tool.Constant.Integer)Current;
                            Current_Cast.Value = Convert.ToInt32(Text);
                            State = StateCode.Integer__Value;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Integer__Value:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Integer Current_Cast = (Goedel.Tool.Constant.Integer)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Integer__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Integer__Title:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Integer__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Integer__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.Integer Current_Cast = (Goedel.Tool.Constant.Integer)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Description : {

									// Description  Description
									Current_Cast.Description = NewDescription ();
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Reserve : {

									// Reserve  Reserve
									Current_Cast.Reserve = NewReserve ();
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Description Reserve ]");
									}
								}
							}
                        break;

                    case StateCode.Reserve_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Constant.Reserve Current_Cast = (Goedel.Tool.Constant.Reserve)Current;
                            Current_Cast.End = Convert.ToInt32(Text);
                            State = StateCode.Reserve__End;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Reserve__End:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Function_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Function Current_Cast = (Goedel.Tool.Constant.Function)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Function__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Function__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Function Current_Cast = (Goedel.Tool.Constant.Function)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Function__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Function__Title:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Function Current_Cast = (Goedel.Tool.Constant.Function)Current;
                            Current_Cast.Type = Text;
                            State = StateCode.Function__Type;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Function__Type:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Function Current_Cast = (Goedel.Tool.Constant.Function)Current;
                            Current_Cast.Return = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Function__Return;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Function__Return:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Function__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Function__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.Function Current_Cast = (Goedel.Tool.Constant.Function)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Parameter : {

									// Parameter  Parameter
									Current_Cast.Parameter.Add (NewParameter ());
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Description : {

									// Description  Description
									Current_Cast.Description = NewDescription ();
									break;
									}
								case Goedel.Tool.Constant.ConstantType.Formula : {

									// Formula  Formula
									Current_Cast.Formula.Add (NewFormula ());
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Parameter Description Formula ]");
									}
								}
							}
                        break;

                    case StateCode.Description_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Description__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Description__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Constant.Description Current_Cast = (Goedel.Tool.Constant.Description)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Parameter_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Parameter Current_Cast = (Goedel.Tool.Constant.Parameter)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Parameter__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Parameter Current_Cast = (Goedel.Tool.Constant.Parameter)Current;
                            Current_Cast.Type = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Parameter__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Parameter__Type:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Parameter Current_Cast = (Goedel.Tool.Constant.Parameter)Current;
                            Current_Cast.Title = Text;
                            State = StateCode.Parameter__Title;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Parameter__Title:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Parameter__Options;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Parameter__Options: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for OPTIONS $$$$$
                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Constant.Parameter Current_Cast = (Goedel.Tool.Constant.Parameter)Current;
                            Goedel.Tool.Constant.ConstantType LabelType = _Reserved (Text);
							switch (LabelType) {
								case Goedel.Tool.Constant.ConstantType.Conv : {

									// Convert  Conv
									Current_Cast.Convert = NewConv ();
									break;
									}
								default : {
									throw new Expected("Parser Error Expected [Conv ]");
									}
								}
							}
                        break;

                    case StateCode.Conv_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Conv Current_Cast = (Goedel.Tool.Constant.Conv)Current;
                            Current_Cast.Type = Text;
                            State = StateCode.Conv__Type;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Conv__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Formula_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Constant.Formula Current_Cast = (Goedel.Tool.Constant.Formula)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__Label, Current_Cast);
                            State = StateCode.Formula__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Formula__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Constant.Formula Current_Cast = (Goedel.Tool.Constant.Formula)Current;
                            Current_Cast.Type = Text;
                            State = StateCode.Formula__Type;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Formula__Type:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Formula__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Formula__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Constant.Formula Current_Cast = (Goedel.Tool.Constant.Formula)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");



                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}


