!function () { "use strict"; function e(e) { this.content = e } function t(e, n, r) { for (let o = 0; ; o++) { if (o == e.childCount || o == n.childCount) return e.childCount == n.childCount ? null : r; let i = e.child(o), s = n.child(o); if (i != s) { if (!i.sameMarkup(s)) return r; if (i.isText && i.text != s.text) { for (let e = 0; i.text[e] == s.text[e]; e++)r++; return r } if (i.content.size || s.content.size) { let e = t(i.content, s.content, r + 1); if (null != e) return e } r += i.nodeSize } else r += i.nodeSize } } function n(e, t, r, o) { for (let i = e.childCount, s = t.childCount; ;) { if (0 == i || 0 == s) return i == s ? null : { a: r, b: o }; let l = e.child(--i), a = t.child(--s), h = l.nodeSize; if (l != a) { if (!l.sameMarkup(a)) return { a: r, b: o }; if (l.isText && l.text != a.text) { let e = 0, t = Math.min(l.text.length, a.text.length); for (; e < t && l.text[l.text.length - e - 1] == a.text[a.text.length - e - 1];)e++, r--, o--; return { a: r, b: o } } if (l.content.size || a.content.size) { let e = n(l.content, a.content, r - 1, o - 1); if (e) return e } r -= h, o -= h } else r -= h, o -= h } } e.prototype = { constructor: e, find: function (e) { for (var t = 0; t < this.content.length; t += 2)if (this.content[t] === e) return t; return -1 }, get: function (e) { var t = this.find(e); return -1 == t ? void 0 : this.content[t + 1] }, update: function (t, n, r) { var o = r && r != t ? this.remove(r) : this, i = o.find(t), s = o.content.slice(); return -1 == i ? s.push(r || t, n) : (s[i + 1] = n, r && (s[i] = r)), new e(s) }, remove: function (t) { var n = this.find(t); if (-1 == n) return this; var r = this.content.slice(); return r.splice(n, 2), new e(r) }, addToStart: function (t, n) { return new e([t, n].concat(this.remove(t).content)) }, addToEnd: function (t, n) { var r = this.remove(t).content.slice(); return r.push(t, n), new e(r) }, addBefore: function (t, n, r) { var o = this.remove(n), i = o.content.slice(), s = o.find(t); return i.splice(-1 == s ? i.length : s, 0, n, r), new e(i) }, forEach: function (e) { for (var t = 0; t < this.content.length; t += 2)e(this.content[t], this.content[t + 1]) }, prepend: function (t) { return (t = e.from(t)).size ? new e(t.content.concat(this.subtract(t).content)) : this }, append: function (t) { return (t = e.from(t)).size ? new e(this.subtract(t).content.concat(t.content)) : this }, subtract: function (t) { var n = this; t = e.from(t); for (var r = 0; r < t.content.length; r += 2)n = n.remove(t.content[r]); return n }, toObject: function () { var e = {}; return this.forEach(function (t, n) { e[t] = n }), e }, get size() { return this.content.length >> 1 } }, e.from = function (t) { if (t instanceof e) return t; var n = []; if (t) for (var r in t) n.push(r, t[r]); return new e(n) }; class r { constructor(e, t) { if (this.content = e, this.size = t || 0, null == t) for (let t = 0; t < e.length; t++)this.size += e[t].nodeSize } nodesBetween(e, t, n, r = 0, o) { for (let i = 0, s = 0; s < t; i++) { let l = this.content[i], a = s + l.nodeSize; if (a > e && !1 !== n(l, r + s, o || null, i) && l.content.size) { let o = s + 1; l.nodesBetween(Math.max(0, e - o), Math.min(l.content.size, t - o), n, r + o) } s = a } } descendants(e) { this.nodesBetween(0, this.size, e) } textBetween(e, t, n, r) { let o = "", i = !0; return this.nodesBetween(e, t, (s, l) => { let a = s.isText ? s.text.slice(Math.max(e, l) - l, t - l) : s.isLeaf ? r ? "function" == typeof r ? r(s) : r : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : ""; s.isBlock && (s.isLeaf && a || s.isTextblock) && n && (i ? i = !1 : o += n), o += a }, 0), o } append(e) { if (!e.size) return this; if (!this.size) return e; let t = this.lastChild, n = e.firstChild, o = this.content.slice(), i = 0; for (t.isText && t.sameMarkup(n) && (o[o.length - 1] = t.withText(t.text + n.text), i = 1); i < e.content.length; i++)o.push(e.content[i]); return new r(o, this.size + e.size) } cut(e, t = this.size) { if (0 == e && t == this.size) return this; let n = [], o = 0; if (t > e) for (let r = 0, i = 0; i < t; r++) { let s = this.content[r], l = i + s.nodeSize; l > e && ((i < e || l > t) && (s = s.isText ? s.cut(Math.max(0, e - i), Math.min(s.text.length, t - i)) : s.cut(Math.max(0, e - i - 1), Math.min(s.content.size, t - i - 1))), n.push(s), o += s.nodeSize), i = l } return new r(n, o) } cutByIndex(e, t) { return e == t ? r.empty : 0 == e && t == this.content.length ? this : new r(this.content.slice(e, t)) } replaceChild(e, t) { let n = this.content[e]; if (n == t) return this; let o = this.content.slice(), i = this.size + t.nodeSize - n.nodeSize; return o[e] = t, new r(o, i) } addToStart(e) { return new r([e].concat(this.content), this.size + e.nodeSize) } addToEnd(e) { return new r(this.content.concat(e), this.size + e.nodeSize) } eq(e) { if (this.content.length != e.content.length) return !1; for (let t = 0; t < this.content.length; t++)if (!this.content[t].eq(e.content[t])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(e) { let t = this.content[e]; if (!t) throw new RangeError("Index " + e + " out of range for " + this); return t } maybeChild(e) { return this.content[e] || null } forEach(e) { for (let t = 0, n = 0; t < this.content.length; t++) { let r = this.content[t]; e(r, n, t), n += r.nodeSize } } findDiffStart(e, n = 0) { return t(this, e, n) } findDiffEnd(e, t = this.size, r = e.size) { return n(this, e, t, r) } findIndex(e) { if (0 == e) return i(0, e); if (e == this.size) return i(this.content.length, e); if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`); for (let t = 0, n = 0; ; t++) { let r = n + this.child(t).nodeSize; if (r >= e) return r == e ? i(t + 1, r) : i(t, n); n = r } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map(e => e.toJSON()) : null } static fromJSON(e, t) { if (!t) return r.empty; if (!Array.isArray(t)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new r(t.map(e.nodeFromJSON)) } static fromArray(e) { if (!e.length) return r.empty; let t, n = 0; for (let r = 0; r < e.length; r++) { let o = e[r]; n += o.nodeSize, r && o.isText && e[r - 1].sameMarkup(o) ? (t || (t = e.slice(0, r)), t[t.length - 1] = o.withText(t[t.length - 1].text + o.text)) : t && t.push(o) } return new r(t || e, n) } static from(e) { if (!e) return r.empty; if (e instanceof r) return e; if (Array.isArray(e)) return this.fromArray(e); if (e.attrs) return new r([e], e.nodeSize); throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } } r.empty = new r([], 0); const o = { index: 0, offset: 0 }; function i(e, t) { return o.index = e, o.offset = t, o } function s(e, t) { if (e === t) return !0; if (!e || "object" != typeof e || !t || "object" != typeof t) return !1; let n = Array.isArray(e); if (Array.isArray(t) != n) return !1; if (n) { if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++)if (!s(e[n], t[n])) return !1 } else { for (let n in e) if (!(n in t) || !s(e[n], t[n])) return !1; for (let n in t) if (!(n in e)) return !1 } return !0 } class l { constructor(e, t) { this.type = e, this.attrs = t } addToSet(e) { let t, n = !1; for (let r = 0; r < e.length; r++) { let o = e[r]; if (this.eq(o)) return e; if (this.type.excludes(o.type)) t || (t = e.slice(0, r)); else { if (o.type.excludes(this.type)) return e; !n && o.type.rank > this.type.rank && (t || (t = e.slice(0, r)), t.push(this), n = !0), t && t.push(o) } } return t || (t = e.slice()), n || t.push(this), t } removeFromSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return e.slice(0, t).concat(e.slice(t + 1)); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return !0; return !1 } eq(e) { return this == e || this.type == e.type && s(this.attrs, e.attrs) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Mark.fromJSON"); let n = e.marks[t.type]; if (!n) throw new RangeError(`There is no mark type ${t.type} in this schema`); let r = n.create(t.attrs); return n.checkAttrs(r.attrs), r } static sameSet(e, t) { if (e == t) return !0; if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++)if (!e[n].eq(t[n])) return !1; return !0 } static setFrom(e) { if (!e || Array.isArray(e) && 0 == e.length) return l.none; if (e instanceof l) return [e]; let t = e.slice(); return t.sort((e, t) => e.type.rank - t.type.rank), t } } l.none = []; class a extends Error { } class h { constructor(e, t, n) { this.content = e, this.openStart = t, this.openEnd = n } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(e, t) { let n = d(this.content, e + this.openStart, t); return n && new h(n, this.openStart, this.openEnd) } removeBetween(e, t) { return new h(c(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd) } eq(e) { return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let e = { content: this.content.toJSON() }; return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e } static fromJSON(e, t) { if (!t) return h.empty; let n = t.openStart || 0, o = t.openEnd || 0; if ("number" != typeof n || "number" != typeof o) throw new RangeError("Invalid input for Slice.fromJSON"); return new h(r.fromJSON(e, t.content), n, o) } static maxOpen(e, t = !0) { let n = 0, r = 0; for (let r = e.firstChild; r && !r.isLeaf && (t || !r.type.spec.isolating); r = r.firstChild)n++; for (let n = e.lastChild; n && !n.isLeaf && (t || !n.type.spec.isolating); n = n.lastChild)r++; return new h(e, n, r) } } function c(e, t, n) { let { index: r, offset: o } = e.findIndex(t), i = e.maybeChild(r), { index: s, offset: l } = e.findIndex(n); if (o == t || i.isText) { if (l != n && !e.child(s).isText) throw new RangeError("Removing non-flat range"); return e.cut(0, t).append(e.cut(n)) } if (r != s) throw new RangeError("Removing non-flat range"); return e.replaceChild(r, i.copy(c(i.content, t - o - 1, n - o - 1))) } function d(e, t, n, r) { let { index: o, offset: i } = e.findIndex(t), s = e.maybeChild(o); if (i == t || s.isText) return r && !r.canReplace(o, o, n) ? null : e.cut(0, t).append(n).append(e.cut(t)); let l = d(s.content, t - i - 1, n, s); return l && e.replaceChild(o, s.copy(l)) } function p(e, t, n) { if (n.openStart > e.depth) throw new a("Inserted content deeper than insertion position"); if (e.depth - n.openStart != t.depth - n.openEnd) throw new a("Inconsistent open depths"); return u(e, t, n, 0) } function u(e, t, n, o) { let i = e.index(o), s = e.node(o); if (i == t.index(o) && o < e.depth - n.openStart) { let r = u(e, t, n, o + 1); return s.copy(s.content.replaceChild(i, r)) } if (n.content.size) { if (n.openStart || n.openEnd || e.depth != o || t.depth != o) { let { start: i, end: l } = function (e, t) { let n = t.depth - e.openStart, o = t.node(n).copy(e.content); for (let e = n - 1; e >= 0; e--)o = t.node(e).copy(r.from(o)); return { start: o.resolveNoCache(e.openStart + n), end: o.resolveNoCache(o.content.size - e.openEnd - n) } }(n, e); return w(s, v(e, i, l, t, o)) } { let r = e.parent, o = r.content; return w(r, o.cut(0, e.parentOffset).append(n.content).append(o.cut(t.parentOffset))) } } return w(s, b(e, t, o)) } function f(e, t) { if (!t.type.compatibleContent(e.type)) throw new a("Cannot join " + t.type.name + " onto " + e.type.name) } function m(e, t, n) { let r = e.node(n); return f(r, t.node(n)), r } function g(e, t) { let n = t.length - 1; n >= 0 && e.isText && e.sameMarkup(t[n]) ? t[n] = e.withText(t[n].text + e.text) : t.push(e) } function y(e, t, n, r) { let o = (t || e).node(n), i = 0, s = t ? t.index(n) : o.childCount; e && (i = e.index(n), e.depth > n ? i++ : e.textOffset && (g(e.nodeAfter, r), i++)); for (let e = i; e < s; e++)g(o.child(e), r); t && t.depth == n && t.textOffset && g(t.nodeBefore, r) } function w(e, t) { return e.type.checkContent(t), e.copy(t) } function v(e, t, n, o, i) { let s = e.depth > i && m(e, t, i + 1), l = o.depth > i && m(n, o, i + 1), a = []; return y(null, e, i, a), s && l && t.index(i) == n.index(i) ? (f(s, l), g(w(s, v(e, t, n, o, i + 1)), a)) : (s && g(w(s, b(e, t, i + 1)), a), y(t, n, i, a), l && g(w(l, b(n, o, i + 1)), a)), y(o, null, i, a), new r(a) } function b(e, t, n) { let o = []; if (y(null, e, n, o), e.depth > n) { g(w(m(e, t, n + 1), b(e, t, n + 1)), o) } return y(t, null, n, o), new r(o) } h.empty = new h(r.empty, 0, 0); class k { constructor(e, t, n) { this.pos = e, this.path = t, this.parentOffset = n, this.depth = t.length / 3 - 1 } resolveDepth(e) { return null == e ? this.depth : e < 0 ? this.depth + e : e } get parent() { return this.node(this.depth) } get doc() { return this.node(0) } node(e) { return this.path[3 * this.resolveDepth(e)] } index(e) { return this.path[3 * this.resolveDepth(e) + 1] } indexAfter(e) { return e = this.resolveDepth(e), this.index(e) + (e != this.depth || this.textOffset ? 1 : 0) } start(e) { return 0 == (e = this.resolveDepth(e)) ? 0 : this.path[3 * e - 1] + 1 } end(e) { return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size } before(e) { if (!(e = this.resolveDepth(e))) throw new RangeError("There is no position before the top-level node"); return e == this.depth + 1 ? this.pos : this.path[3 * e - 1] } after(e) { if (!(e = this.resolveDepth(e))) throw new RangeError("There is no position after the top-level node"); return e == this.depth + 1 ? this.pos : this.path[3 * e - 1] + this.path[3 * e].nodeSize } get textOffset() { return this.pos - this.path[this.path.length - 1] } get nodeAfter() { let e = this.parent, t = this.index(this.depth); if (t == e.childCount) return null; let n = this.pos - this.path[this.path.length - 1], r = e.child(t); return n ? e.child(t).cut(n) : r } get nodeBefore() { let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1]; return t ? this.parent.child(e).cut(0, t) : 0 == e ? null : this.parent.child(e - 1) } posAtIndex(e, t) { t = this.resolveDepth(t); let n = this.path[3 * t], r = 0 == t ? 0 : this.path[3 * t - 1] + 1; for (let t = 0; t < e; t++)r += n.child(t).nodeSize; return r } marks() { let e = this.parent, t = this.index(); if (0 == e.content.size) return l.none; if (this.textOffset) return e.child(t).marks; let n = e.maybeChild(t - 1), r = e.maybeChild(t); if (!n) { let e = n; n = r, r = e } let o = n.marks; for (var i = 0; i < o.length; i++)!1 !== o[i].type.spec.inclusive || r && o[i].isInSet(r.marks) || (o = o[i--].removeFromSet(o)); return o } marksAcross(e) { let t = this.parent.maybeChild(this.index()); if (!t || !t.isInline) return null; let n = t.marks, r = e.parent.maybeChild(e.index()); for (var o = 0; o < n.length; o++)!1 !== n[o].type.spec.inclusive || r && n[o].isInSet(r.marks) || (n = n[o--].removeFromSet(n)); return n } sharedDepth(e) { for (let t = this.depth; t > 0; t--)if (this.start(t) <= e && this.end(t) >= e) return t; return 0 } blockRange(e = this, t) { if (e.pos < this.pos) return e.blockRange(this); for (let n = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); n >= 0; n--)if (e.pos <= this.end(n) && (!t || t(this.node(n)))) return new M(this, e, n); return null } sameParent(e) { return this.pos - this.parentOffset == e.pos - e.parentOffset } max(e) { return e.pos > this.pos ? e : this } min(e) { return e.pos < this.pos ? e : this } toString() { let e = ""; for (let t = 1; t <= this.depth; t++)e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1); return e + ":" + this.parentOffset } static resolve(e, t) { if (!(t >= 0 && t <= e.content.size)) throw new RangeError("Position " + t + " out of range"); let n = [], r = 0, o = t; for (let t = e; ;) { let { index: e, offset: i } = t.content.findIndex(o), s = o - i; if (n.push(t, e, r + i), !s) break; if (t = t.child(e), t.isText) break; o = s - 1, r += i + 1 } return new k(t, n, o) } static resolveCached(e, t) { let n = C.get(e); if (n) for (let e = 0; e < n.elts.length; e++) { let r = n.elts[e]; if (r.pos == t) return r } else C.set(e, n = new x); let r = n.elts[n.i] = k.resolve(e, t); return n.i = (n.i + 1) % S, r } } class x { constructor() { this.elts = [], this.i = 0 } } const S = 12, C = new WeakMap; class M { constructor(e, t, n) { this.$from = e, this.$to = t, this.depth = n } get start() { return this.$from.before(this.depth + 1) } get end() { return this.$to.after(this.depth + 1) } get parent() { return this.$from.node(this.depth) } get startIndex() { return this.$from.index(this.depth) } get endIndex() { return this.$to.indexAfter(this.depth) } } const O = Object.create(null); class N { constructor(e, t, n, o = l.none) { this.type = e, this.attrs = t, this.marks = o, this.content = n || r.empty } get children() { return this.content.content } get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size } get childCount() { return this.content.childCount } child(e) { return this.content.child(e) } maybeChild(e) { return this.content.maybeChild(e) } forEach(e) { this.content.forEach(e) } nodesBetween(e, t, n, r = 0) { this.content.nodesBetween(e, t, n, r, this) } descendants(e) { this.nodesBetween(0, this.content.size, e) } get textContent() { return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "") } textBetween(e, t, n, r) { return this.content.textBetween(e, t, n, r) } get firstChild() { return this.content.firstChild } get lastChild() { return this.content.lastChild } eq(e) { return this == e || this.sameMarkup(e) && this.content.eq(e.content) } sameMarkup(e) { return this.hasMarkup(e.type, e.attrs, e.marks) } hasMarkup(e, t, n) { return this.type == e && s(this.attrs, t || e.defaultAttrs || O) && l.sameSet(this.marks, n || l.none) } copy(e = null) { return e == this.content ? this : new N(this.type, this.attrs, e, this.marks) } mark(e) { return e == this.marks ? this : new N(this.type, this.attrs, this.content, e) } cut(e, t = this.content.size) { return 0 == e && t == this.content.size ? this : this.copy(this.content.cut(e, t)) } slice(e, t = this.content.size, n = !1) { if (e == t) return h.empty; let r = this.resolve(e), o = this.resolve(t), i = n ? 0 : r.sharedDepth(t), s = r.start(i), l = r.node(i).content.cut(r.pos - s, o.pos - s); return new h(l, r.depth - i, o.depth - i) } replace(e, t, n) { return p(this.resolve(e), this.resolve(t), n) } nodeAt(e) { for (let t = this; ;) { let { index: n, offset: r } = t.content.findIndex(e); if (t = t.maybeChild(n), !t) return null; if (r == e || t.isText) return t; e -= r + 1 } } childAfter(e) { let { index: t, offset: n } = this.content.findIndex(e); return { node: this.content.maybeChild(t), index: t, offset: n } } childBefore(e) { if (0 == e) return { node: null, index: 0, offset: 0 }; let { index: t, offset: n } = this.content.findIndex(e); if (n < e) return { node: this.content.child(t), index: t, offset: n }; let r = this.content.child(t - 1); return { node: r, index: t - 1, offset: n - r.nodeSize } } resolve(e) { return k.resolveCached(this, e) } resolveNoCache(e) { return k.resolve(this, e) } rangeHasMark(e, t, n) { let r = !1; return t > e && this.nodesBetween(e, t, e => (n.isInSet(e.marks) && (r = !0), !r)), r } get isBlock() { return this.type.isBlock } get isTextblock() { return this.type.isTextblock } get inlineContent() { return this.type.inlineContent } get isInline() { return this.type.isInline } get isText() { return this.type.isText } get isLeaf() { return this.type.isLeaf } get isAtom() { return this.type.isAtom } toString() { if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this); let e = this.type.name; return this.content.size && (e += "(" + this.content.toStringInner() + ")"), T(this.marks, e) } contentMatchAt(e) { let t = this.type.contentMatch.matchFragment(this.content, 0, e); if (!t) throw new Error("Called contentMatchAt on a node with invalid content"); return t } canReplace(e, t, n = r.empty, o = 0, i = n.childCount) { let s = this.contentMatchAt(e).matchFragment(n, o, i), l = s && s.matchFragment(this.content, t); if (!l || !l.validEnd) return !1; for (let e = o; e < i; e++)if (!this.type.allowsMarks(n.child(e).marks)) return !1; return !0 } canReplaceWith(e, t, n, r) { if (r && !this.type.allowsMarks(r)) return !1; let o = this.contentMatchAt(e).matchType(n), i = o && o.matchFragment(this.content, t); return !!i && i.validEnd } canAppend(e) { return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type) } check() { this.type.checkContent(this.content), this.type.checkAttrs(this.attrs); let e = l.none; for (let t = 0; t < this.marks.length; t++) { let n = this.marks[t]; n.type.checkAttrs(n.attrs), e = n.addToSet(e) } if (!l.sameSet(e, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(e => e.type.name)}`); this.content.forEach(e => e.check()) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map(e => e.toJSON())), e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Node.fromJSON"); let n; if (t.marks) { if (!Array.isArray(t.marks)) throw new RangeError("Invalid mark data for Node.fromJSON"); n = t.marks.map(e.markFromJSON) } if ("text" == t.type) { if ("string" != typeof t.text) throw new RangeError("Invalid text node in JSON"); return e.text(t.text, n) } let o = r.fromJSON(e, t.content), i = e.nodeType(t.type).create(t.attrs, o, n); return i.type.checkAttrs(i.attrs), i } } N.prototype.text = void 0; class D extends N { constructor(e, t, n, r) { if (super(e, t, null, r), !n) throw new RangeError("Empty text nodes are not allowed"); this.text = n } toString() { return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : T(this.marks, JSON.stringify(this.text)) } get textContent() { return this.text } textBetween(e, t) { return this.text.slice(e, t) } get nodeSize() { return this.text.length } mark(e) { return e == this.marks ? this : new D(this.type, this.attrs, this.text, e) } withText(e) { return e == this.text ? this : new D(this.type, this.attrs, e, this.marks) } cut(e = 0, t = this.text.length) { return 0 == e && t == this.text.length ? this : this.withText(this.text.slice(e, t)) } eq(e) { return this.sameMarkup(e) && this.text == e.text } toJSON() { let e = super.toJSON(); return e.text = this.text, e } } function T(e, t) { for (let n = e.length - 1; n >= 0; n--)t = e[n].type.name + "(" + t + ")"; return t } class E { constructor(e) { this.validEnd = e, this.next = [], this.wrapCache = [] } static parse(e, t) { let n = new A(e, t); if (null == n.next) return E.empty; let r = R(n); n.next && n.err("Unexpected trailing text"); let o = function (e) { let t = Object.create(null); return n(V(e, 0)); function n(r) { let o = []; r.forEach(t => { e[t].forEach(({ term: t, to: n }) => { if (!t) return; let r; for (let e = 0; e < o.length; e++)o[e][0] == t && (r = o[e][1]); V(e, n).forEach(e => { r || o.push([t, r = []]), -1 == r.indexOf(e) && r.push(e) }) }) }); let i = t[r.join(",")] = new E(r.indexOf(e.length - 1) > -1); for (let e = 0; e < o.length; e++) { let r = o[e][1].sort($); i.next.push({ type: o[e][0], next: t[r.join(",")] || n(r) }) } return i } }(function (e) { let t = [[]]; return o(i(e, 0), n()), t; function n() { return t.push([]) - 1 } function r(e, n, r) { let o = { term: r, to: n }; return t[e].push(o), o } function o(e, t) { e.forEach(e => e.to = t) } function i(e, t) { if ("choice" == e.type) return e.exprs.reduce((e, n) => e.concat(i(n, t)), []); if ("seq" != e.type) { if ("star" == e.type) { let s = n(); return r(t, s), o(i(e.expr, s), s), [r(s)] } if ("plus" == e.type) { let s = n(); return o(i(e.expr, t), s), o(i(e.expr, s), s), [r(s)] } if ("opt" == e.type) return [r(t)].concat(i(e.expr, t)); if ("range" == e.type) { let s = t; for (let t = 0; t < e.min; t++) { let t = n(); o(i(e.expr, s), t), s = t } if (-1 == e.max) o(i(e.expr, s), s); else for (let t = e.min; t < e.max; t++) { let t = n(); r(s, t), o(i(e.expr, s), t), s = t } return [r(s)] } if ("name" == e.type) return [r(t, void 0, e.value)]; throw new Error("Unknown expr type") } for (let r = 0; ; r++) { let s = i(e.exprs[r], t); if (r == e.exprs.length - 1) return s; o(s, t = n()) } } }(r)); return function (e, t) { for (let n = 0, r = [e]; n < r.length; n++) { let e = r[n], o = !e.validEnd, i = []; for (let t = 0; t < e.next.length; t++) { let { type: n, next: s } = e.next[t]; i.push(n.name), !o || n.isText || n.hasRequiredAttrs() || (o = !1), -1 == r.indexOf(s) && r.push(s) } o && t.err("Only non-generatable nodes (" + i.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)") } }(o, n), o } matchType(e) { for (let t = 0; t < this.next.length; t++)if (this.next[t].type == e) return this.next[t].next; return null } matchFragment(e, t = 0, n = e.childCount) { let r = this; for (let o = t; r && o < n; o++)r = r.matchType(e.child(o).type); return r } get inlineContent() { return 0 != this.next.length && this.next[0].type.isInline } get defaultType() { for (let e = 0; e < this.next.length; e++) { let { type: t } = this.next[e]; if (!t.isText && !t.hasRequiredAttrs()) return t } return null } compatible(e) { for (let t = 0; t < this.next.length; t++)for (let n = 0; n < e.next.length; n++)if (this.next[t].type == e.next[n].type) return !0; return !1 } fillBefore(e, t = !1, n = 0) { let o = [this]; return function i(s, l) { let a = s.matchFragment(e, n); if (a && (!t || a.validEnd)) return r.from(l.map(e => e.createAndFill())); for (let e = 0; e < s.next.length; e++) { let { type: t, next: n } = s.next[e]; if (!t.isText && !t.hasRequiredAttrs() && -1 == o.indexOf(n)) { o.push(n); let e = i(n, l.concat(t)); if (e) return e } } return null }(this, []) } findWrapping(e) { for (let t = 0; t < this.wrapCache.length; t += 2)if (this.wrapCache[t] == e) return this.wrapCache[t + 1]; let t = this.computeWrapping(e); return this.wrapCache.push(e, t), t } computeWrapping(e) { let t = Object.create(null), n = [{ match: this, type: null, via: null }]; for (; n.length;) { let r = n.shift(), o = r.match; if (o.matchType(e)) { let e = []; for (let t = r; t.type; t = t.via)e.push(t.type); return e.reverse() } for (let e = 0; e < o.next.length; e++) { let { type: i, next: s } = o.next[e]; i.isLeaf || i.hasRequiredAttrs() || i.name in t || r.type && !s.validEnd || (n.push({ match: i.contentMatch, type: i, via: r }), t[i.name] = !0) } } return null } get edgeCount() { return this.next.length } edge(e) { if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`); return this.next[e] } toString() { let e = []; return function t(n) { e.push(n); for (let r = 0; r < n.next.length; r++)-1 == e.indexOf(n.next[r].next) && t(n.next[r].next) }(this), e.map((t, n) => { let r = n + (t.validEnd ? "*" : " ") + " "; for (let n = 0; n < t.next.length; n++)r += (n ? ", " : "") + t.next[n].type.name + "->" + e.indexOf(t.next[n].next); return r }).join("\n") } } E.empty = new E(!0); class A { constructor(e, t) { this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), "" == this.tokens[this.tokens.length - 1] && this.tokens.pop(), "" == this.tokens[0] && this.tokens.shift() } get next() { return this.tokens[this.pos] } eat(e) { return this.next == e && (this.pos++ || !0) } err(e) { throw new SyntaxError(e + " (in content expression '" + this.string + "')") } } function R(e) { let t = []; do { t.push(I(e)) } while (e.eat("|")); return 1 == t.length ? t[0] : { type: "choice", exprs: t } } function I(e) { let t = []; do { t.push(z(e)) } while (e.next && ")" != e.next && "|" != e.next); return 1 == t.length ? t[0] : { type: "seq", exprs: t } } function z(e) { let t = function (e) { if (e.eat("(")) { let t = R(e); return e.eat(")") || e.err("Missing closing paren"), t } if (!/\W/.test(e.next)) { let t = function (e, t) { let n = e.nodeTypes, r = n[t]; if (r) return [r]; let o = []; for (let e in n) { let r = n[e]; r.isInGroup(t) && o.push(r) } 0 == o.length && e.err("No node type or group '" + t + "' found"); return o }(e, e.next).map(t => (null == e.inline ? e.inline = t.isInline : e.inline != t.isInline && e.err("Mixing inline and block content"), { type: "name", value: t })); return e.pos++, 1 == t.length ? t[0] : { type: "choice", exprs: t } } e.err("Unexpected token '" + e.next + "'") }(e); for (; ;)if (e.eat("+")) t = { type: "plus", expr: t }; else if (e.eat("*")) t = { type: "star", expr: t }; else if (e.eat("?")) t = { type: "opt", expr: t }; else { if (!e.eat("{")) break; t = B(e, t) } return t } function P(e) { /\D/.test(e.next) && e.err("Expected number, got '" + e.next + "'"); let t = Number(e.next); return e.pos++, t } function B(e, t) { let n = P(e), r = n; return e.eat(",") && (r = "}" != e.next ? P(e) : -1), e.eat("}") || e.err("Unclosed braced range"), { type: "range", min: n, max: r, expr: t } } function $(e, t) { return t - e } function V(e, t) { let n = []; return function t(r) { let o = e[r]; if (1 == o.length && !o[0].term) return t(o[0].to); n.push(r); for (let e = 0; e < o.length; e++) { let { term: r, to: i } = o[e]; r || -1 != n.indexOf(i) || t(i) } }(t), n.sort($) } function F(e) { let t = Object.create(null); for (let n in e) { let r = e[n]; if (!r.hasDefault) return null; t[n] = r.default } return t } function q(e, t) { let n = Object.create(null); for (let r in e) { let o = t && t[r]; if (void 0 === o) { let t = e[r]; if (!t.hasDefault) throw new RangeError("No value supplied for attribute " + r); o = t.default } n[r] = o } return n } function L(e, t, n, r) { for (let r in t) if (!(r in e)) throw new RangeError(`Unsupported attribute ${r} for ${n} of type ${r}`); for (let n in e) { let r = e[n]; r.validate && r.validate(t[n]) } } function _(e, t) { let n = Object.create(null); if (t) for (let r in t) n[r] = new J(e, r, t[r]); return n } class W { constructor(e, t, n) { this.name = e, this.schema = t, this.spec = n, this.markSet = null, this.groups = n.group ? n.group.split(" ") : [], this.attrs = _(e, n.attrs), this.defaultAttrs = F(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(n.inline || "text" == e), this.isText = "text" == e } get isInline() { return !this.isBlock } get isTextblock() { return this.isBlock && this.inlineContent } get isLeaf() { return this.contentMatch == E.empty } get isAtom() { return this.isLeaf || !!this.spec.atom } isInGroup(e) { return this.groups.indexOf(e) > -1 } get whitespace() { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") } hasRequiredAttrs() { for (let e in this.attrs) if (this.attrs[e].isRequired) return !0; return !1 } compatibleContent(e) { return this == e || this.contentMatch.compatible(e.contentMatch) } computeAttrs(e) { return !e && this.defaultAttrs ? this.defaultAttrs : q(this.attrs, e) } create(e = null, t, n) { if (this.isText) throw new Error("NodeType.create can't construct text nodes"); return new N(this, this.computeAttrs(e), r.from(t), l.setFrom(n)) } createChecked(e = null, t, n) { return t = r.from(t), this.checkContent(t), new N(this, this.computeAttrs(e), t, l.setFrom(n)) } createAndFill(e = null, t, n) { if (e = this.computeAttrs(e), (t = r.from(t)).size) { let e = this.contentMatch.fillBefore(t); if (!e) return null; t = e.append(t) } let o = this.contentMatch.matchFragment(t), i = o && o.fillBefore(r.empty, !0); return i ? new N(this, e, t.append(i), l.setFrom(n)) : null } validContent(e) { let t = this.contentMatch.matchFragment(e); if (!t || !t.validEnd) return !1; for (let t = 0; t < e.childCount; t++)if (!this.allowsMarks(e.child(t).marks)) return !1; return !0 } checkContent(e) { if (!this.validContent(e)) throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`) } checkAttrs(e) { L(this.attrs, e, "node", this.name) } allowsMarkType(e) { return null == this.markSet || this.markSet.indexOf(e) > -1 } allowsMarks(e) { if (null == this.markSet) return !0; for (let t = 0; t < e.length; t++)if (!this.allowsMarkType(e[t].type)) return !1; return !0 } allowedMarks(e) { if (null == this.markSet) return e; let t; for (let n = 0; n < e.length; n++)this.allowsMarkType(e[n].type) ? t && t.push(e[n]) : t || (t = e.slice(0, n)); return t ? t.length ? t : l.none : e } static compile(e, t) { let n = Object.create(null); e.forEach((e, r) => n[e] = new W(e, t, r)); let r = t.spec.topNode || "doc"; if (!n[r]) throw new RangeError("Schema is missing its top node type ('" + r + "')"); if (!n.text) throw new RangeError("Every schema needs a 'text' type"); for (let e in n.text.attrs) throw new RangeError("The text node type should not have attributes"); return n } } class J { constructor(e, t, n) { this.hasDefault = Object.prototype.hasOwnProperty.call(n, "default"), this.default = n.default, this.validate = "string" == typeof n.validate ? function (e, t, n) { let r = n.split("|"); return n => { let o = null === n ? "null" : typeof n; if (r.indexOf(o) < 0) throw new RangeError(`Expected value of type ${r} for attribute ${t} on type ${e}, got ${o}`) } }(e, t, n.validate) : n.validate } get isRequired() { return !this.hasDefault } } class j { constructor(e, t, n, r) { this.name = e, this.rank = t, this.schema = n, this.spec = r, this.attrs = _(e, r.attrs), this.excluded = null; let o = F(this.attrs); this.instance = o ? new l(this, o) : null } create(e = null) { return !e && this.instance ? this.instance : new l(this, q(this.attrs, e)) } static compile(e, t) { let n = Object.create(null), r = 0; return e.forEach((e, o) => n[e] = new j(e, r++, t, o)), n } removeFromSet(e) { for (var t = 0; t < e.length; t++)e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (e[t].type == this) return e[t] } checkAttrs(e) { L(this.attrs, e, "mark", this.name) } excludes(e) { return this.excluded.indexOf(e) > -1 } } class K { constructor(t) { this.linebreakReplacement = null, this.cached = Object.create(null); let n = this.spec = {}; for (let e in t) n[e] = t[e]; n.nodes = e.from(t.nodes), n.marks = e.from(t.marks || {}), this.nodes = W.compile(this.spec.nodes, this), this.marks = j.compile(this.spec.marks, this); let r = Object.create(null); for (let e in this.nodes) { if (e in this.marks) throw new RangeError(e + " can not be both a node and a mark"); let t = this.nodes[e], n = t.spec.content || "", o = t.spec.marks; if (t.contentMatch = r[n] || (r[n] = E.parse(n, this.nodes)), t.inlineContent = t.contentMatch.inlineContent, t.spec.linebreakReplacement) { if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined"); if (!t.isInline || !t.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes"); this.linebreakReplacement = t } t.markSet = "_" == o ? null : o ? H(this, o.split(" ")) : "" != o && t.inlineContent ? null : [] } for (let e in this.marks) { let t = this.marks[e], n = t.spec.excludes; t.excluded = null == n ? [t] : "" == n ? [] : H(this, n.split(" ")) } this.nodeFromJSON = e => N.fromJSON(this, e), this.markFromJSON = e => l.fromJSON(this, e), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = Object.create(null) } node(e, t = null, n, r) { if ("string" == typeof e) e = this.nodeType(e); else { if (!(e instanceof W)) throw new RangeError("Invalid node type: " + e); if (e.schema != this) throw new RangeError("Node type from different schema used (" + e.name + ")") } return e.createChecked(t, n, r) } text(e, t) { let n = this.nodes.text; return new D(n, n.defaultAttrs, e, l.setFrom(t)) } mark(e, t) { return "string" == typeof e && (e = this.marks[e]), e.create(t) } nodeType(e) { let t = this.nodes[e]; if (!t) throw new RangeError("Unknown node type: " + e); return t } } function H(e, t) { let n = []; for (let r = 0; r < t.length; r++) { let o = t[r], i = e.marks[o], s = i; if (i) n.push(i); else for (let t in e.marks) { let r = e.marks[t]; ("_" == o || r.spec.group && r.spec.group.split(" ").indexOf(o) > -1) && n.push(s = r) } if (!s) throw new SyntaxError("Unknown mark type: '" + t[r] + "'") } return n } class U { constructor(e, t) { this.schema = e, this.rules = t, this.tags = [], this.styles = []; let n = this.matchedStyles = []; t.forEach(e => { if (function (e) { return null != e.tag }(e)) this.tags.push(e); else if (function (e) { return null != e.style }(e)) { let t = /[^=]*/.exec(e.style)[0]; n.indexOf(t) < 0 && n.push(t), this.styles.push(e) } }), this.normalizeLists = !this.tags.some(t => { if (!/^(ul|ol)\b/.test(t.tag) || !t.node) return !1; let n = e.nodes[t.node]; return n.contentMatch.matchType(n) }) } parse(e, t = {}) { let n = new ee(this, t, !1); return n.addAll(e, l.none, t.from, t.to), n.finish() } parseSlice(e, t = {}) { let n = new ee(this, t, !0); return n.addAll(e, l.none, t.from, t.to), h.maxOpen(n.finish()) } matchTag(e, t, n) { for (let r = n ? this.tags.indexOf(n) + 1 : 0; r < this.tags.length; r++) { let n = this.tags[r]; if (te(e, n.tag) && (void 0 === n.namespace || e.namespaceURI == n.namespace) && (!n.context || t.matchesContext(n.context))) { if (n.getAttrs) { let t = n.getAttrs(e); if (!1 === t) continue; n.attrs = t || void 0 } return n } } } matchStyle(e, t, n, r) { for (let o = r ? this.styles.indexOf(r) + 1 : 0; o < this.styles.length; o++) { let r = this.styles[o], i = r.style; if (!(0 != i.indexOf(e) || r.context && !n.matchesContext(r.context) || i.length > e.length && (61 != i.charCodeAt(e.length) || i.slice(e.length + 1) != t))) { if (r.getAttrs) { let e = r.getAttrs(t); if (!1 === e) continue; r.attrs = e || void 0 } return r } } } static schemaRules(e) { let t = []; function n(e) { let n = null == e.priority ? 50 : e.priority, r = 0; for (; r < t.length; r++) { let e = t[r]; if ((null == e.priority ? 50 : e.priority) < n) break } t.splice(r, 0, e) } for (let t in e.marks) { let r = e.marks[t].spec.parseDOM; r && r.forEach(e => { n(e = ne(e)), e.mark || e.ignore || e.clearMark || (e.mark = t) }) } for (let t in e.nodes) { let r = e.nodes[t].spec.parseDOM; r && r.forEach(e => { n(e = ne(e)), e.node || e.ignore || e.mark || (e.node = t) }) } return t } static fromSchema(e) { return e.cached.domParser || (e.cached.domParser = new U(e, U.schemaRules(e))) } } const G = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, Y = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, Q = { ol: !0, ul: !0 }; function X(e, t, n) { return null != t ? (t ? 1 : 0) | ("full" === t ? 2 : 0) : e && "pre" == e.whitespace ? 3 : -5 & n } class Z { constructor(e, t, n, r, o, i) { this.type = e, this.attrs = t, this.marks = n, this.solid = r, this.options = i, this.content = [], this.activeMarks = l.none, this.match = o || (4 & i ? null : e.contentMatch) } findWrapping(e) { if (!this.match) { if (!this.type) return []; let t = this.type.contentMatch.fillBefore(r.from(e)); if (!t) { let t, n = this.type.contentMatch; return (t = n.findWrapping(e.type)) ? (this.match = n, t) : null } this.match = this.type.contentMatch.matchFragment(t) } return this.match.findWrapping(e.type) } finish(e) { if (!(1 & this.options)) { let e, t = this.content[this.content.length - 1]; if (t && t.isText && (e = /[ \t\r\n\u000c]+$/.exec(t.text))) { let n = t; t.text.length == e[0].length ? this.content.pop() : this.content[this.content.length - 1] = n.withText(n.text.slice(0, n.text.length - e[0].length)) } } let t = r.from(this.content); return !e && this.match && (t = t.append(this.match.fillBefore(r.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t } inlineContext(e) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !G.hasOwnProperty(e.parentNode.nodeName.toLowerCase()) } } class ee { constructor(e, t, n) { this.parser = e, this.options = t, this.isOpen = n, this.open = 0, this.localPreserveWS = !1; let r, o = t.topNode, i = X(null, t.preserveWhitespace, 0) | (n ? 4 : 0); r = o ? new Z(o.type, o.attrs, l.none, !0, t.topMatch || o.type.contentMatch, i) : new Z(n ? null : e.schema.topNodeType, null, l.none, !0, null, i), this.nodes = [r], this.find = t.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(e, t) { 3 == e.nodeType ? this.addTextNode(e, t) : 1 == e.nodeType && this.addElement(e, t) } addTextNode(e, t) { let n = e.nodeValue, r = this.top, o = 2 & r.options ? "full" : this.localPreserveWS || (1 & r.options) > 0; if ("full" === o || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(n)) { if (o) n = "full" !== o ? n.replace(/\r?\n|\r/g, " ") : n.replace(/\r\n?/g, "\n"); else if (n = n.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(n) && this.open == this.nodes.length - 1) { let t = r.content[r.content.length - 1], o = e.previousSibling; (!t || o && "BR" == o.nodeName || t.isText && /[ \t\r\n\u000c]$/.test(t.text)) && (n = n.slice(1)) } n && this.insertNode(this.parser.schema.text(n), t, !/\S/.test(n)), this.findInText(e) } else this.findInside(e) } addElement(e, t, n) { let r = this.localPreserveWS, o = this.top; ("PRE" == e.tagName || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0); let i, s = e.nodeName.toLowerCase(); Q.hasOwnProperty(s) && this.parser.normalizeLists && function (e) { for (let t = e.firstChild, n = null; t; t = t.nextSibling) { let e = 1 == t.nodeType ? t.nodeName.toLowerCase() : null; e && Q.hasOwnProperty(e) && n ? (n.appendChild(t), t = n) : "li" == e ? n = t : e && (n = null) } }(e); let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (i = this.parser.matchTag(e, this, n)); e: if (l ? l.ignore : Y.hasOwnProperty(s)) this.findInside(e), this.ignoreFallback(e, t); else if (!l || l.skip || l.closeParent) { l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip); let n, r = this.needsBlock; if (G.hasOwnProperty(s)) o.content.length && o.content[0].isInline && this.open && (this.open--, o = this.top), n = !0, o.type || (this.needsBlock = !0); else if (!e.firstChild) { this.leafFallback(e, t); break e } let i = l && l.skip ? t : this.readStyles(e, t); i && this.addAll(e, i), n && this.sync(o), this.needsBlock = r } else { let n = this.readStyles(e, t); n && this.addElementByRule(e, l, n, !1 === l.consuming ? i : void 0) } this.localPreserveWS = r } leafFallback(e, t) { "BR" == e.nodeName && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode("\n"), t) } ignoreFallback(e, t) { "BR" != e.nodeName || this.top.type && this.top.type.inlineContent || this.findPlace(this.parser.schema.text("-"), t, !0) } readStyles(e, t) { let n = e.style; if (n && n.length) for (let e = 0; e < this.parser.matchedStyles.length; e++) { let r = this.parser.matchedStyles[e], o = n.getPropertyValue(r); if (o) for (let e; ;) { let n = this.parser.matchStyle(r, o, this, e); if (!n) break; if (n.ignore) return null; if (t = n.clearMark ? t.filter(e => !n.clearMark(e)) : t.concat(this.parser.schema.marks[n.mark].create(n.attrs)), !1 !== n.consuming) break; e = n } } return t } addElementByRule(e, t, n, r) { let o, i; if (t.node) if (i = this.parser.schema.nodes[t.node], i.isLeaf) this.insertNode(i.create(t.attrs), n, "BR" == e.nodeName) || this.leafFallback(e, n); else { let e = this.enter(i, t.attrs || null, n, t.preserveWhitespace); e && (o = !0, n = e) } else { let e = this.parser.schema.marks[t.mark]; n = n.concat(e.create(t.attrs)) } let s = this.top; if (i && i.isLeaf) this.findInside(e); else if (r) this.addElement(e, n, r); else if (t.getContent) this.findInside(e), t.getContent(e, this.parser.schema).forEach(e => this.insertNode(e, n, !1)); else { let r = e; "string" == typeof t.contentElement ? r = e.querySelector(t.contentElement) : "function" == typeof t.contentElement ? r = t.contentElement(e) : t.contentElement && (r = t.contentElement), this.findAround(e, r, !0), this.addAll(r, n), this.findAround(e, r, !1) } o && this.sync(s) && this.open-- } addAll(e, t, n, r) { let o = n || 0; for (let i = n ? e.childNodes[n] : e.firstChild, s = null == r ? null : e.childNodes[r]; i != s; i = i.nextSibling, ++o)this.findAtPoint(e, o), this.addDOM(i, t); this.findAtPoint(e, o) } findPlace(e, t, n) { let r, o; for (let t = this.open, i = 0; t >= 0; t--) { let s = this.nodes[t], l = s.findWrapping(e); if (l && (!r || r.length > l.length + i) && (r = l, o = s, !l.length)) break; if (s.solid) { if (n) break; i += 2 } } if (!r) return null; this.sync(o); for (let e = 0; e < r.length; e++)t = this.enterInner(r[e], null, t, !1); return t } insertNode(e, t, n) { if (e.isInline && this.needsBlock && !this.top.type) { let e = this.textblockFromContext(); e && (t = this.enterInner(e, null, t)) } let r = this.findPlace(e, t, n); if (r) { this.closeExtra(); let t = this.top; t.match && (t.match = t.match.matchType(e.type)); let n = l.none; for (let o of r.concat(e.marks)) (t.type ? t.type.allowsMarkType(o.type) : re(o.type, e.type)) && (n = o.addToSet(n)); return t.content.push(e.mark(n)), !0 } return !1 } enter(e, t, n, r) { let o = this.findPlace(e.create(t), n, !1); return o && (o = this.enterInner(e, t, n, !0, r)), o } enterInner(e, t, n, r = !1, o) { this.closeExtra(); let i = this.top; i.match = i.match && i.match.matchType(e); let s = X(e, o, i.options); 4 & i.options && 0 == i.content.length && (s |= 4); let a = l.none; return n = n.filter(t => !(i.type ? i.type.allowsMarkType(t.type) : re(t.type, e)) || (a = t.addToSet(a), !1)), this.nodes.push(new Z(e, t, a, r, null, s)), this.open++, n } closeExtra(e = !1) { let t = this.nodes.length - 1; if (t > this.open) { for (; t > this.open; t--)this.nodes[t - 1].content.push(this.nodes[t].finish(e)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!(!this.isOpen && !this.options.topOpen)) } sync(e) { for (let t = this.open; t >= 0; t--) { if (this.nodes[t] == e) return this.open = t, !0; this.localPreserveWS && (this.nodes[t].options |= 1) } return !1 } get currentPos() { this.closeExtra(); let e = 0; for (let t = this.open; t >= 0; t--) { let n = this.nodes[t].content; for (let t = n.length - 1; t >= 0; t--)e += n[t].nodeSize; t && e++ } return e } findAtPoint(e, t) { if (this.find) for (let n = 0; n < this.find.length; n++)this.find[n].node == e && this.find[n].offset == t && (this.find[n].pos = this.currentPos) } findInside(e) { if (this.find) for (let t = 0; t < this.find.length; t++)null == this.find[t].pos && 1 == e.nodeType && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos) } findAround(e, t, n) { if (e != t && this.find) for (let r = 0; r < this.find.length; r++)if (null == this.find[r].pos && 1 == e.nodeType && e.contains(this.find[r].node)) { t.compareDocumentPosition(this.find[r].node) & (n ? 2 : 4) && (this.find[r].pos = this.currentPos) } } findInText(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset)) } matchesContext(e) { if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this); let t = e.split("/"), n = this.options.context, r = !(this.isOpen || n && n.parent.type != this.nodes[0].type), o = -(n ? n.depth + 1 : 0) + (r ? 0 : 1), i = (e, s) => { for (; e >= 0; e--) { let l = t[e]; if ("" == l) { if (e == t.length - 1 || 0 == e) continue; for (; s >= o; s--)if (i(e - 1, s)) return !0; return !1 } { let e = s > 0 || 0 == s && r ? this.nodes[s].type : n && s >= o ? n.node(s - o).type : null; if (!e || e.name != l && !e.isInGroup(l)) return !1; s-- } } return !0 }; return i(t.length - 1, this.open) } textblockFromContext() { let e = this.options.context; if (e) for (let t = e.depth; t >= 0; t--) { let n = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType; if (n && n.isTextblock && n.defaultAttrs) return n } for (let e in this.parser.schema.nodes) { let t = this.parser.schema.nodes[e]; if (t.isTextblock && t.defaultAttrs) return t } } } function te(e, t) { return (e.matches || e.msMatchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector).call(e, t) } function ne(e) { let t = {}; for (let n in e) t[n] = e[n]; return t } function re(e, t) { let n = t.schema.nodes; for (let r in n) { let o = n[r]; if (!o.allowsMarkType(e)) continue; let i = [], s = e => { i.push(e); for (let n = 0; n < e.edgeCount; n++) { let { type: r, next: o } = e.edge(n); if (r == t) return !0; if (i.indexOf(o) < 0 && s(o)) return !0 } }; if (s(o.contentMatch)) return !0 } } class oe { constructor(e, t) { this.nodes = e, this.marks = t } serializeFragment(e, t = {}, n) { n || (n = se(t).createDocumentFragment()); let r = n, o = []; return e.forEach(e => { if (o.length || e.marks.length) { let n = 0, i = 0; for (; n < o.length && i < e.marks.length;) { let t = e.marks[i]; if (this.marks[t.type.name]) { if (!t.eq(o[n][0]) || !1 === t.type.spec.spanning) break; n++, i++ } else i++ } for (; n < o.length;)r = o.pop()[1]; for (; i < e.marks.length;) { let n = e.marks[i++], s = this.serializeMark(n, e.isInline, t); s && (o.push([n, r]), r.appendChild(s.dom), r = s.contentDOM || s.dom) } } r.appendChild(this.serializeNodeInner(e, t)) }), n } serializeNodeInner(e, t) { let { dom: n, contentDOM: r } = he(se(t), this.nodes[e.type.name](e), null, e.attrs); if (r) { if (e.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec"); this.serializeFragment(e.content, t, r) } return n } serializeNode(e, t = {}) { let n = this.serializeNodeInner(e, t); for (let r = e.marks.length - 1; r >= 0; r--) { let o = this.serializeMark(e.marks[r], e.isInline, t); o && ((o.contentDOM || o.dom).appendChild(n), n = o.dom) } return n } serializeMark(e, t, n = {}) { let r = this.marks[e.type.name]; return r && he(se(n), r(e, t), null, e.attrs) } static renderSpec(e, t, n = null, r) { return he(e, t, n, r) } static fromSchema(e) { return e.cached.domSerializer || (e.cached.domSerializer = new oe(this.nodesFromSchema(e), this.marksFromSchema(e))) } static nodesFromSchema(e) { let t = ie(e.nodes); return t.text || (t.text = e => e.text), t } static marksFromSchema(e) { return ie(e.marks) } } function ie(e) { let t = {}; for (let n in e) { let r = e[n].spec.toDOM; r && (t[n] = r) } return t } function se(e) { return e.document || window.document } const le = new WeakMap; function ae(e) { let t = le.get(e); return void 0 === t && le.set(e, t = function (e) { let t = null; function n(e) { if (e && "object" == typeof e) if (Array.isArray(e)) if ("string" == typeof e[0]) t || (t = []), t.push(e); else for (let t = 0; t < e.length; t++)n(e[t]); else for (let t in e) n(e[t]) } return n(e), t }(e)), t } function he(e, t, n, r) { if ("string" == typeof t) return { dom: e.createTextNode(t) }; if (null != t.nodeType) return { dom: t }; if (t.dom && null != t.dom.nodeType) return t; let o, i = t[0]; if ("string" != typeof i) throw new RangeError("Invalid array passed to renderSpec"); if (r && (o = ae(r)) && o.indexOf(t) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."); let s, l = i.indexOf(" "); l > 0 && (n = i.slice(0, l), i = i.slice(l + 1)); let a = n ? e.createElementNS(n, i) : e.createElement(i), h = t[1], c = 1; if (h && "object" == typeof h && null == h.nodeType && !Array.isArray(h)) { c = 2; for (let e in h) if (null != h[e]) { let t = e.indexOf(" "); t > 0 ? a.setAttributeNS(e.slice(0, t), e.slice(t + 1), h[e]) : "style" == e && a.style ? a.style.cssText = h[e] : a.setAttribute(e, h[e]) } } for (let o = c; o < t.length; o++) { let i = t[o]; if (0 === i) { if (o < t.length - 1 || o > c) throw new RangeError("Content hole must be the only child of its parent node"); return { dom: a, contentDOM: a } } { let { dom: t, contentDOM: o } = he(e, i, n, r); if (a.appendChild(t), o) { if (s) throw new RangeError("Multiple content holes"); s = o } } } return { dom: a, contentDOM: s } } var ce = Object.freeze({ __proto__: null, ContentMatch: E, DOMParser: U, DOMSerializer: oe, Fragment: r, Mark: l, MarkType: j, Node: N, NodeRange: M, NodeType: W, ReplaceError: a, ResolvedPos: k, Schema: K, Slice: h }); const de = Math.pow(2, 16); function pe(e, t) { return e + t * de } function ue(e) { return 65535 & e } class fe { constructor(e, t, n) { this.pos = e, this.delInfo = t, this.recover = n } get deleted() { return (8 & this.delInfo) > 0 } get deletedBefore() { return (5 & this.delInfo) > 0 } get deletedAfter() { return (6 & this.delInfo) > 0 } get deletedAcross() { return (4 & this.delInfo) > 0 } } class me { constructor(e, t = !1) { if (this.ranges = e, this.inverted = t, !e.length && me.empty) return me.empty } recover(e) { let t = 0, n = ue(e); if (!this.inverted) for (let e = 0; e < n; e++)t += this.ranges[3 * e + 2] - this.ranges[3 * e + 1]; return this.ranges[3 * n] + t + function (e) { return (e - (65535 & e)) / de }(e) } mapResult(e, t = 1) { return this._map(e, t, !1) } map(e, t = 1) { return this._map(e, t, !0) } _map(e, t, n) { let r = 0, o = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2; for (let s = 0; s < this.ranges.length; s += 3) { let l = this.ranges[s] - (this.inverted ? r : 0); if (l > e) break; let a = this.ranges[s + o], h = this.ranges[s + i], c = l + a; if (e <= c) { let o = l + r + ((a ? e == l ? -1 : e == c ? 1 : t : t) < 0 ? 0 : h); if (n) return o; let i = e == (t < 0 ? l : c) ? null : pe(s / 3, e - l), d = e == l ? 2 : e == c ? 1 : 4; return (t < 0 ? e != l : e != c) && (d |= 8), new fe(o, d, i) } r += h - a } return n ? e + r : new fe(e + r, 0, null) } touches(e, t) { let n = 0, r = ue(t), o = this.inverted ? 2 : 1, i = this.inverted ? 1 : 2; for (let t = 0; t < this.ranges.length; t += 3) { let s = this.ranges[t] - (this.inverted ? n : 0); if (s > e) break; let l = this.ranges[t + o]; if (e <= s + l && t == 3 * r) return !0; n += this.ranges[t + i] - l } return !1 } forEach(e) { let t = this.inverted ? 2 : 1, n = this.inverted ? 1 : 2; for (let r = 0, o = 0; r < this.ranges.length; r += 3) { let i = this.ranges[r], s = i - (this.inverted ? o : 0), l = i + (this.inverted ? 0 : o), a = this.ranges[r + t], h = this.ranges[r + n]; e(s, s + a, l, l + h), o += h - a } } invert() { return new me(this.ranges, !this.inverted) } toString() { return (this.inverted ? "-" : "") + JSON.stringify(this.ranges) } static offset(e) { return 0 == e ? me.empty : new me(e < 0 ? [0, -e, 0] : [0, 0, e]) } } me.empty = new me([]); class ge { constructor(e, t, n = 0, r = (e ? e.length : 0)) { this.mirror = t, this.from = n, this.to = r, this._maps = e || [], this.ownData = !(e || t) } get maps() { return this._maps } slice(e = 0, t = this.maps.length) { return new ge(this._maps, this.mirror, e, t) } appendMap(e, t) { this.ownData || (this._maps = this._maps.slice(), this.mirror = this.mirror && this.mirror.slice(), this.ownData = !0), this.to = this._maps.push(e), null != t && this.setMirror(this._maps.length - 1, t) } appendMapping(e) { for (let t = 0, n = this._maps.length; t < e._maps.length; t++) { let r = e.getMirror(t); this.appendMap(e._maps[t], null != r && r < t ? n + r : void 0) } } getMirror(e) { if (this.mirror) for (let t = 0; t < this.mirror.length; t++)if (this.mirror[t] == e) return this.mirror[t + (t % 2 ? -1 : 1)] } setMirror(e, t) { this.mirror || (this.mirror = []), this.mirror.push(e, t) } appendMappingInverted(e) { for (let t = e.maps.length - 1, n = this._maps.length + e._maps.length; t >= 0; t--) { let r = e.getMirror(t); this.appendMap(e._maps[t].invert(), null != r && r > t ? n - r - 1 : void 0) } } invert() { let e = new ge; return e.appendMappingInverted(this), e } map(e, t = 1) { if (this.mirror) return this._map(e, t, !0); for (let n = this.from; n < this.to; n++)e = this._maps[n].map(e, t); return e } mapResult(e, t = 1) { return this._map(e, t, !1) } _map(e, t, n) { let r = 0; for (let n = this.from; n < this.to; n++) { let o = this._maps[n].mapResult(e, t); if (null != o.recover) { let t = this.getMirror(n); if (null != t && t > n && t < this.to) { n = t, e = this._maps[t].recover(o.recover); continue } } r |= o.delInfo, e = o.pos } return n ? e : new fe(e, r, null) } } const ye = Object.create(null); class we { getMap() { return me.empty } merge(e) { return null } static fromJSON(e, t) { if (!t || !t.stepType) throw new RangeError("Invalid input for Step.fromJSON"); let n = ye[t.stepType]; if (!n) throw new RangeError(`No step type ${t.stepType} defined`); return n.fromJSON(e, t) } static jsonID(e, t) { if (e in ye) throw new RangeError("Duplicate use of step JSON ID " + e); return ye[e] = t, t.prototype.jsonID = e, t } } class ve { constructor(e, t) { this.doc = e, this.failed = t } static ok(e) { return new ve(e, null) } static fail(e) { return new ve(null, e) } static fromReplace(e, t, n, r) { try { return ve.ok(e.replace(t, n, r)) } catch (e) { if (e instanceof a) return ve.fail(e.message); throw e } } } function be(e, t, n) { let o = []; for (let r = 0; r < e.childCount; r++) { let i = e.child(r); i.content.size && (i = i.copy(be(i.content, t, i))), i.isInline && (i = t(i, n, r)), o.push(i) } return r.fromArray(o) } class ke extends we { constructor(e, t, n) { super(), this.from = e, this.to = t, this.mark = n } apply(e) { let t = e.slice(this.from, this.to), n = e.resolve(this.from), r = n.node(n.sharedDepth(this.to)), o = new h(be(t.content, (e, t) => e.isAtom && t.type.allowsMarkType(this.mark.type) ? e.mark(this.mark.addToSet(e.marks)) : e, r), t.openStart, t.openEnd); return ve.fromReplace(e, this.from, this.to, o) } invert() { return new xe(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deleted && n.deleted || t.pos >= n.pos ? null : new ke(t.pos, n.pos, this.mark) } merge(e) { return e instanceof ke && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new ke(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to) throw new RangeError("Invalid input for AddMarkStep.fromJSON"); return new ke(t.from, t.to, e.markFromJSON(t.mark)) } } we.jsonID("addMark", ke); class xe extends we { constructor(e, t, n) { super(), this.from = e, this.to = t, this.mark = n } apply(e) { let t = e.slice(this.from, this.to), n = new h(be(t.content, e => e.mark(this.mark.removeFromSet(e.marks)), e), t.openStart, t.openEnd); return ve.fromReplace(e, this.from, this.to, n) } invert() { return new ke(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deleted && n.deleted || t.pos >= n.pos ? null : new xe(t.pos, n.pos, this.mark) } merge(e) { return e instanceof xe && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new xe(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to) throw new RangeError("Invalid input for RemoveMarkStep.fromJSON"); return new xe(t.from, t.to, e.markFromJSON(t.mark)) } } we.jsonID("removeMark", xe); class Se extends we { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return ve.fail("No node at mark step's position"); let n = t.type.create(t.attrs, null, this.mark.addToSet(t.marks)); return ve.fromReplace(e, this.pos, this.pos + 1, new h(r.from(n), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); if (t) { let e = this.mark.addToSet(t.marks); if (e.length == t.marks.length) { for (let n = 0; n < t.marks.length; n++)if (!t.marks[n].isInSet(e)) return new Se(this.pos, t.marks[n]); return new Se(this.pos, this.mark) } } return new Ce(this.pos, this.mark) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new Se(t.pos, this.mark) } toJSON() { return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if ("number" != typeof t.pos) throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON"); return new Se(t.pos, e.markFromJSON(t.mark)) } } we.jsonID("addNodeMark", Se); class Ce extends we { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return ve.fail("No node at mark step's position"); let n = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks)); return ve.fromReplace(e, this.pos, this.pos + 1, new h(r.from(n), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); return t && this.mark.isInSet(t.marks) ? new Se(this.pos, this.mark) : this } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new Ce(t.pos, this.mark) } toJSON() { return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if ("number" != typeof t.pos) throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON"); return new Ce(t.pos, e.markFromJSON(t.mark)) } } we.jsonID("removeNodeMark", Ce); class Me extends we { constructor(e, t, n, r = !1) { super(), this.from = e, this.to = t, this.slice = n, this.structure = r } apply(e) { return this.structure && Ne(e, this.from, this.to) ? ve.fail("Structure replace would overwrite content") : ve.fromReplace(e, this.from, this.to, this.slice) } getMap() { return new me([this.from, this.to - this.from, this.slice.size]) } invert(e) { return new Me(this.from, this.from + this.slice.size, e.slice(this.from, this.to)) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1); return t.deletedAcross && n.deletedAcross ? null : new Me(t.pos, Math.max(t.pos, n.pos), this.slice, this.structure) } merge(e) { if (!(e instanceof Me) || e.structure || this.structure) return null; if (this.from + this.slice.size != e.from || this.slice.openEnd || e.slice.openStart) { if (e.to != this.from || this.slice.openStart || e.slice.openEnd) return null; { let t = this.slice.size + e.slice.size == 0 ? h.empty : new h(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd); return new Me(e.from, this.to, t, this.structure) } } { let t = this.slice.size + e.slice.size == 0 ? h.empty : new h(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd); return new Me(this.from, this.to + (e.to - e.from), t, this.structure) } } toJSON() { let e = { stepType: "replace", from: this.from, to: this.to }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to) throw new RangeError("Invalid input for ReplaceStep.fromJSON"); return new Me(t.from, t.to, h.fromJSON(e, t.slice), !!t.structure) } } we.jsonID("replace", Me); class Oe extends we { constructor(e, t, n, r, o, i, s = !1) { super(), this.from = e, this.to = t, this.gapFrom = n, this.gapTo = r, this.slice = o, this.insert = i, this.structure = s } apply(e) { if (this.structure && (Ne(e, this.from, this.gapFrom) || Ne(e, this.gapTo, this.to))) return ve.fail("Structure gap-replace would overwrite content"); let t = e.slice(this.gapFrom, this.gapTo); if (t.openStart || t.openEnd) return ve.fail("Gap is not a flat range"); let n = this.slice.insertAt(this.insert, t.content); return n ? ve.fromReplace(e, this.from, this.to, n) : ve.fail("Content does not fit in gap") } getMap() { return new me([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]) } invert(e) { let t = this.gapTo - this.gapFrom; return new Oe(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure) } map(e) { let t = e.mapResult(this.from, 1), n = e.mapResult(this.to, -1), r = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), o = this.to == this.gapTo ? n.pos : e.map(this.gapTo, 1); return t.deletedAcross && n.deletedAcross || r < t.pos || o > n.pos ? null : new Oe(t.pos, n.pos, r, o, this.slice, this.insert, this.structure) } toJSON() { let e = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if ("number" != typeof t.from || "number" != typeof t.to || "number" != typeof t.gapFrom || "number" != typeof t.gapTo || "number" != typeof t.insert) throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON"); return new Oe(t.from, t.to, t.gapFrom, t.gapTo, h.fromJSON(e, t.slice), t.insert, !!t.structure) } } function Ne(e, t, n) { let r = e.resolve(t), o = n - t, i = r.depth; for (; o > 0 && i > 0 && r.indexAfter(i) == r.node(i).childCount;)i--, o--; if (o > 0) { let e = r.node(i).maybeChild(r.indexAfter(i)); for (; o > 0;) { if (!e || e.isLeaf) return !0; e = e.firstChild, o-- } } return !1 } function De(e, t, n, o = n.contentMatch, i = !0) { let s = e.doc.nodeAt(t), l = [], a = t + 1; for (let t = 0; t < s.childCount; t++) { let c = s.child(t), d = a + c.nodeSize, p = o.matchType(c.type); if (p) { o = p; for (let t = 0; t < c.marks.length; t++)n.allowsMarkType(c.marks[t].type) || e.step(new xe(a, d, c.marks[t])); if (i && c.isText && "pre" != n.whitespace) { let e, t, o = /\r?\n|\r/g; for (; e = o.exec(c.text);)t || (t = new h(r.from(n.schema.text(" ", n.allowedMarks(c.marks))), 0, 0)), l.push(new Me(a + e.index, a + e.index + e[0].length, t)) } } else l.push(new Me(a, d, h.empty)); a = d } if (!o.validEnd) { let t = o.fillBefore(r.empty, !0); e.replace(a, a, new h(t, 0, 0)) } for (let t = l.length - 1; t >= 0; t--)e.step(l[t]) } function Te(e, t, n) { return (0 == t || e.canReplace(t, e.childCount)) && (n == e.childCount || e.canReplace(0, n)) } function Ee(e) { let t = e.parent.content.cutByIndex(e.startIndex, e.endIndex); for (let n = e.depth; ; --n) { let r = e.$from.node(n), o = e.$from.index(n), i = e.$to.indexAfter(n); if (n < e.depth && r.canReplace(o, i, t)) return n; if (0 == n || r.type.spec.isolating || !Te(r, o, i)) break } return null } function Ae(e, t, n = null, r = e) { let o = function (e, t) { let { parent: n, startIndex: r, endIndex: o } = e, i = n.contentMatchAt(r).findWrapping(t); if (!i) return null; let s = i.length ? i[0] : t; return n.canReplaceWith(r, o, s) ? i : null }(e, t), i = o && function (e, t) { let { parent: n, startIndex: r, endIndex: o } = e, i = n.child(r), s = t.contentMatch.findWrapping(i.type); if (!s) return null; let l = (s.length ? s[s.length - 1] : t).contentMatch; for (let e = r; l && e < o; e++)l = l.matchType(n.child(e).type); return l && l.validEnd ? s : null }(r, t); return i ? o.map(Re).concat({ type: t, attrs: n }).concat(i.map(Re)) : null } function Re(e) { return { type: e, attrs: null } } function Ie(e, t, n, r) { t.forEach((o, i) => { if (o.isText) { let s, l = /\r?\n|\r/g; for (; s = l.exec(o.text);) { let o = e.mapping.slice(r).map(n + 1 + i + s.index); e.replaceWith(o, o + 1, t.type.schema.linebreakReplacement.create()) } } }) } function ze(e, t, n, r) { t.forEach((o, i) => { if (o.type == o.type.schema.linebreakReplacement) { let o = e.mapping.slice(r).map(n + 1 + i); e.replaceWith(o, o + 1, t.type.schema.text("\n")) } }) } function Pe(e, t, n = 1, r) { let o = e.resolve(t), i = o.depth - n, s = r && r[r.length - 1] || o.parent; if (i < 0 || o.parent.type.spec.isolating || !o.parent.canReplace(o.index(), o.parent.childCount) || !s.type.validContent(o.parent.content.cutByIndex(o.index(), o.parent.childCount))) return !1; for (let e = o.depth - 1, t = n - 2; e > i; e--, t--) { let n = o.node(e), i = o.index(e); if (n.type.spec.isolating) return !1; let s = n.content.cutByIndex(i, n.childCount), l = r && r[t + 1]; l && (s = s.replaceChild(0, l.type.create(l.attrs))); let a = r && r[t] || n; if (!n.canReplace(i + 1, n.childCount) || !a.type.validContent(s)) return !1 } let l = o.indexAfter(i), a = r && r[0]; return o.node(i).canReplaceWith(l, l, a ? a.type : o.node(i + 1).type) } function Be(e, t) { let n = e.resolve(t), r = n.index(); return $e(n.nodeBefore, n.nodeAfter) && n.parent.canReplace(r, r + 1) } function $e(e, t) { return !(!e || !t || e.isLeaf || !function (e, t) { t.content.size || e.type.compatibleContent(t.type); let n = e.contentMatchAt(e.childCount), { linebreakReplacement: r } = e.type.schema; for (let o = 0; o < t.childCount; o++) { let i = t.child(o), s = i.type == r ? e.type.schema.nodes.text : i.type; if (n = n.matchType(s), !n) return !1; if (!e.type.allowsMarks(i.marks)) return !1 } return n.validEnd }(e, t)) } function Ve(e, t, n = -1) { let r = e.resolve(t); for (let e = r.depth; ; e--) { let o, i, s = r.index(e); if (e == r.depth ? (o = r.nodeBefore, i = r.nodeAfter) : n > 0 ? (o = r.node(e + 1), s++, i = r.node(e).maybeChild(s)) : (o = r.node(e).maybeChild(s - 1), i = r.node(e + 1)), o && !o.isTextblock && $e(o, i) && r.node(e).canReplace(s, s + 1)) return t; if (0 == e) break; t = n < 0 ? r.before(e) : r.after(e) } } function Fe(e, t, n) { let r = e.resolve(t); if (r.parent.canReplaceWith(r.index(), r.index(), n)) return t; if (0 == r.parentOffset) for (let e = r.depth - 1; e >= 0; e--) { let t = r.index(e); if (r.node(e).canReplaceWith(t, t, n)) return r.before(e + 1); if (t > 0) return null } if (r.parentOffset == r.parent.content.size) for (let e = r.depth - 1; e >= 0; e--) { let t = r.indexAfter(e); if (r.node(e).canReplaceWith(t, t, n)) return r.after(e + 1); if (t < r.node(e).childCount) return null } return null } function qe(e, t, n) { let r = e.resolve(t); if (!n.content.size) return t; let o = n.content; for (let e = 0; e < n.openStart; e++)o = o.firstChild.content; for (let e = 1; e <= (0 == n.openStart && n.size ? 2 : 1); e++)for (let t = r.depth; t >= 0; t--) { let n = t == r.depth ? 0 : r.pos <= (r.start(t + 1) + r.end(t + 1)) / 2 ? -1 : 1, i = r.index(t) + (n > 0 ? 1 : 0), s = r.node(t), l = !1; if (1 == e) l = s.canReplace(i, i, o); else { let e = s.contentMatchAt(i).findWrapping(o.firstChild.type); l = e && s.canReplaceWith(i, i, e[0]) } if (l) return 0 == n ? r.pos : n < 0 ? r.before(t + 1) : r.after(t + 1) } return null } function Le(e, t, n = t, r = h.empty) { if (t == n && !r.size) return null; let o = e.resolve(t), i = e.resolve(n); return _e(o, i, r) ? new Me(t, n, r) : new We(o, i, r).fit() } function _e(e, t, n) { return !n.openStart && !n.openEnd && e.start() == t.start() && e.parent.canReplace(e.index(), t.index(), n.content) } we.jsonID("replaceAround", Oe); class We { constructor(e, t, n) { this.$from = e, this.$to = t, this.unplaced = n, this.frontier = [], this.placed = r.empty; for (let t = 0; t <= e.depth; t++) { let n = e.node(t); this.frontier.push({ type: n.type, match: n.contentMatchAt(e.indexAfter(t)) }) } for (let t = e.depth; t > 0; t--)this.placed = r.from(e.node(t).copy(this.placed)) } get depth() { return this.frontier.length - 1 } fit() { for (; this.unplaced.size;) { let e = this.findFittable(); e ? this.placeNodes(e) : this.openMore() || this.dropNode() } let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, n = this.$from, r = this.close(e < 0 ? this.$to : n.doc.resolve(e)); if (!r) return null; let o = this.placed, i = n.depth, s = r.depth; for (; i && s && 1 == o.childCount;)o = o.firstChild.content, i--, s--; let l = new h(o, i, s); return e > -1 ? new Oe(n.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || n.pos != this.$to.pos ? new Me(n.pos, r.pos, l) : null } findFittable() { let e = this.unplaced.openStart; for (let t = this.unplaced.content, n = 0, r = this.unplaced.openEnd; n < e; n++) { let o = t.firstChild; if (t.childCount > 1 && (r = 0), o.type.spec.isolating && r <= n) { e = n; break } t = o.content } for (let t = 1; t <= 2; t++)for (let n = 1 == t ? e : this.unplaced.openStart; n >= 0; n--) { let e, o = null; n ? (o = Ke(this.unplaced.content, n - 1).firstChild, e = o.content) : e = this.unplaced.content; let i = e.firstChild; for (let e = this.depth; e >= 0; e--) { let s, { type: l, match: a } = this.frontier[e], h = null; if (1 == t && (i ? a.matchType(i.type) || (h = a.fillBefore(r.from(i), !1)) : o && l.compatibleContent(o.type))) return { sliceDepth: n, frontierDepth: e, parent: o, inject: h }; if (2 == t && i && (s = a.findWrapping(i.type))) return { sliceDepth: n, frontierDepth: e, parent: o, wrap: s }; if (o && a.matchType(o.type)) break } } } openMore() { let { content: e, openStart: t, openEnd: n } = this.unplaced, r = Ke(e, t); return !(!r.childCount || r.firstChild.isLeaf) && (this.unplaced = new h(e, t + 1, Math.max(n, r.size + t >= e.size - n ? t + 1 : 0)), !0) } dropNode() { let { content: e, openStart: t, openEnd: n } = this.unplaced, r = Ke(e, t); if (r.childCount <= 1 && t > 0) { let o = e.size - t <= t + r.size; this.unplaced = new h(Je(e, t - 1, 1), t - 1, o ? t - 1 : n) } else this.unplaced = new h(Je(e, t, 1), t, n) } placeNodes({ sliceDepth: e, frontierDepth: t, parent: n, inject: o, wrap: i }) { for (; this.depth > t;)this.closeFrontierNode(); if (i) for (let e = 0; e < i.length; e++)this.openFrontierNode(i[e]); let s = this.unplaced, l = n ? n.content : s.content, a = s.openStart - e, c = 0, d = [], { match: p, type: u } = this.frontier[t]; if (o) { for (let e = 0; e < o.childCount; e++)d.push(o.child(e)); p = p.matchFragment(o) } let f = l.size + e - (s.content.size - s.openEnd); for (; c < l.childCount;) { let e = l.child(c), t = p.matchType(e.type); if (!t) break; c++, (c > 1 || 0 == a || e.content.size) && (p = t, d.push(He(e.mark(u.allowedMarks(e.marks)), 1 == c ? a : 0, c == l.childCount ? f : -1))) } let m = c == l.childCount; m || (f = -1), this.placed = je(this.placed, t, r.from(d)), this.frontier[t].match = p, m && f < 0 && n && n.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode(); for (let e = 0, t = l; e < f; e++) { let e = t.lastChild; this.frontier.push({ type: e.type, match: e.contentMatchAt(e.childCount) }), t = e.content } this.unplaced = m ? 0 == e ? h.empty : new h(Je(s.content, e - 1, 1), e - 1, f < 0 ? s.openEnd : e - 1) : new h(Je(s.content, e, c), s.openStart, s.openEnd) } mustMoveInline() { if (!this.$to.parent.isTextblock) return -1; let e, t = this.frontier[this.depth]; if (!t.type.isTextblock || !Ue(this.$to, this.$to.depth, t.type, t.match, !1) || this.$to.depth == this.depth && (e = this.findCloseLevel(this.$to)) && e.depth == this.depth) return -1; let { depth: n } = this.$to, r = this.$to.after(n); for (; n > 1 && r == this.$to.end(--n);)++r; return r } findCloseLevel(e) { e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) { let { match: n, type: r } = this.frontier[t], o = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), i = Ue(e, t, r, n, o); if (i) { for (let n = t - 1; n >= 0; n--) { let { match: t, type: r } = this.frontier[n], o = Ue(e, n, r, t, !0); if (!o || o.childCount) continue e } return { depth: t, fit: i, move: o ? e.doc.resolve(e.after(t + 1)) : e } } } } close(e) { let t = this.findCloseLevel(e); if (!t) return null; for (; this.depth > t.depth;)this.closeFrontierNode(); t.fit.childCount && (this.placed = je(this.placed, t.depth, t.fit)), e = t.move; for (let n = t.depth + 1; n <= e.depth; n++) { let t = e.node(n), r = t.type.contentMatch.fillBefore(t.content, !0, e.index(n)); this.openFrontierNode(t.type, t.attrs, r) } return e } openFrontierNode(e, t = null, n) { let o = this.frontier[this.depth]; o.match = o.match.matchType(e), this.placed = je(this.placed, this.depth, r.from(e.create(t, n))), this.frontier.push({ type: e, match: e.contentMatch }) } closeFrontierNode() { let e = this.frontier.pop().match.fillBefore(r.empty, !0); e.childCount && (this.placed = je(this.placed, this.frontier.length, e)) } } function Je(e, t, n) { return 0 == t ? e.cutByIndex(n, e.childCount) : e.replaceChild(0, e.firstChild.copy(Je(e.firstChild.content, t - 1, n))) } function je(e, t, n) { return 0 == t ? e.append(n) : e.replaceChild(e.childCount - 1, e.lastChild.copy(je(e.lastChild.content, t - 1, n))) } function Ke(e, t) { for (let n = 0; n < t; n++)e = e.firstChild.content; return e } function He(e, t, n) { if (t <= 0) return e; let o = e.content; return t > 1 && (o = o.replaceChild(0, He(o.firstChild, t - 1, 1 == o.childCount ? n - 1 : 0))), t > 0 && (o = e.type.contentMatch.fillBefore(o).append(o), n <= 0 && (o = o.append(e.type.contentMatch.matchFragment(o).fillBefore(r.empty, !0)))), e.copy(o) } function Ue(e, t, n, r, o) { let i = e.node(t), s = o ? e.indexAfter(t) : e.index(t); if (s == i.childCount && !n.compatibleContent(i.type)) return null; let l = r.fillBefore(i.content, !0, s); return l && !function (e, t, n) { for (let r = n; r < t.childCount; r++)if (!e.allowsMarks(t.child(r).marks)) return !0; return !1 }(n, i.content, s) ? l : null } function Ge(e) { return e.spec.defining || e.spec.definingForContent } function Ye(e, t, n, o, i) { if (t < n) { let r = e.firstChild; e = e.replaceChild(0, r.copy(Ye(r.content, t + 1, n, o, r))) } if (t > o) { let t = i.contentMatchAt(0), n = t.fillBefore(e).append(e); e = n.append(t.matchFragment(n).fillBefore(r.empty, !0)) } return e } function Qe(e, t) { let n = []; for (let r = Math.min(e.depth, t.depth); r >= 0; r--) { let o = e.start(r); if (o < e.pos - (e.depth - r) || t.end(r) > t.pos + (t.depth - r) || e.node(r).type.spec.isolating || t.node(r).type.spec.isolating) break; (o == t.start(r) || r == e.depth && r == t.depth && e.parent.inlineContent && t.parent.inlineContent && r && t.start(r - 1) == o - 1) && n.push(r) } return n } class Xe extends we { constructor(e, t, n) { super(), this.pos = e, this.attr = t, this.value = n } apply(e) { let t = e.nodeAt(this.pos); if (!t) return ve.fail("No node at attribute step's position"); let n = Object.create(null); for (let e in t.attrs) n[e] = t.attrs[e]; n[this.attr] = this.value; let o = t.type.create(n, null, t.marks); return ve.fromReplace(e, this.pos, this.pos + 1, new h(r.from(o), 0, t.isLeaf ? 0 : 1)) } getMap() { return me.empty } invert(e) { return new Xe(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new Xe(t.pos, this.attr, this.value) } toJSON() { return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value } } static fromJSON(e, t) { if ("number" != typeof t.pos || "string" != typeof t.attr) throw new RangeError("Invalid input for AttrStep.fromJSON"); return new Xe(t.pos, t.attr, t.value) } } we.jsonID("attr", Xe); class Ze extends we { constructor(e, t) { super(), this.attr = e, this.value = t } apply(e) { let t = Object.create(null); for (let n in e.attrs) t[n] = e.attrs[n]; t[this.attr] = this.value; let n = e.type.create(t, e.content, e.marks); return ve.ok(n) } getMap() { return me.empty } invert(e) { return new Ze(this.attr, e.attrs[this.attr]) } map(e) { return this } toJSON() { return { stepType: "docAttr", attr: this.attr, value: this.value } } static fromJSON(e, t) { if ("string" != typeof t.attr) throw new RangeError("Invalid input for DocAttrStep.fromJSON"); return new Ze(t.attr, t.value) } } we.jsonID("docAttr", Ze); let et = class extends Error { }; et = function e(t) { let n = Error.call(this, t); return n.__proto__ = e.prototype, n }, (et.prototype = Object.create(Error.prototype)).constructor = et, et.prototype.name = "TransformError"; class tt { constructor(e) { this.doc = e, this.steps = [], this.docs = [], this.mapping = new ge } get before() { return this.docs.length ? this.docs[0] : this.doc } step(e) { let t = this.maybeStep(e); if (t.failed) throw new et(t.failed); return this } maybeStep(e) { let t = e.apply(this.doc); return t.failed || this.addStep(e, t.doc), t } get docChanged() { return this.steps.length > 0 } addStep(e, t) { this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t } replace(e, t = e, n = h.empty) { let r = Le(this.doc, e, t, n); return r && this.step(r), this } replaceWith(e, t, n) { return this.replace(e, t, new h(r.from(n), 0, 0)) } delete(e, t) { return this.replace(e, t, h.empty) } insert(e, t) { return this.replaceWith(e, e, t) } replaceRange(e, t, n) { return function (e, t, n, r) { if (!r.size) return e.deleteRange(t, n); let o = e.doc.resolve(t), i = e.doc.resolve(n); if (_e(o, i, r)) return e.step(new Me(t, n, r)); let s = Qe(o, e.doc.resolve(n)); 0 == s[s.length - 1] && s.pop(); let l = -(o.depth + 1); s.unshift(l); for (let e = o.depth, t = o.pos - 1; e > 0; e--, t--) { let n = o.node(e).type.spec; if (n.defining || n.definingAsContext || n.isolating) break; s.indexOf(e) > -1 ? l = e : o.before(e) == t && s.splice(1, 0, -e) } let a = s.indexOf(l), c = [], d = r.openStart; for (let e = r.content, t = 0; ; t++) { let n = e.firstChild; if (c.push(n), t == r.openStart) break; e = n.content } for (let e = d - 1; e >= 0; e--) { let t = c[e], n = Ge(t.type); if (n && !t.sameMarkup(o.node(Math.abs(l) - 1))) d = e; else if (n || !t.type.isTextblock) break } for (let t = r.openStart; t >= 0; t--) { let l = (t + d + 1) % (r.openStart + 1), p = c[l]; if (p) for (let t = 0; t < s.length; t++) { let c = s[(t + a) % s.length], d = !0; c < 0 && (d = !1, c = -c); let u = o.node(c - 1), f = o.index(c - 1); if (u.canReplaceWith(f, f, p.type, p.marks)) return e.replace(o.before(c), d ? i.after(c) : n, new h(Ye(r.content, 0, r.openStart, l), l, r.openEnd)) } } let p = e.steps.length; for (let l = s.length - 1; l >= 0 && (e.replace(t, n, r), !(e.steps.length > p)); l--) { let e = s[l]; e < 0 || (t = o.before(e), n = i.after(e)) } }(this, e, t, n), this } replaceRangeWith(e, t, n) { return function (e, t, n, o) { if (!o.isInline && t == n && e.doc.resolve(t).parent.content.size) { let r = Fe(e.doc, t, o.type); null != r && (t = n = r) } e.replaceRange(t, n, new h(r.from(o), 0, 0)) }(this, e, t, n), this } deleteRange(e, t) { return function (e, t, n) { let r = e.doc.resolve(t), o = e.doc.resolve(n), i = Qe(r, o); for (let t = 0; t < i.length; t++) { let n = i[t], s = t == i.length - 1; if (s && 0 == n || r.node(n).type.contentMatch.validEnd) return e.delete(r.start(n), o.end(n)); if (n > 0 && (s || r.node(n - 1).canReplace(r.index(n - 1), o.indexAfter(n - 1)))) return e.delete(r.before(n), o.after(n)) } for (let i = 1; i <= r.depth && i <= o.depth; i++)if (t - r.start(i) == r.depth - i && n > r.end(i) && o.end(i) - n != o.depth - i && r.start(i - 1) == o.start(i - 1) && r.node(i - 1).canReplace(r.index(i - 1), o.index(i - 1))) return e.delete(r.before(i), n); e.delete(t, n) }(this, e, t), this } lift(e, t) { return function (e, t, n) { let { $from: o, $to: i, depth: s } = t, l = o.before(s + 1), a = i.after(s + 1), c = l, d = a, p = r.empty, u = 0; for (let e = s, t = !1; e > n; e--)t || o.index(e) > 0 ? (t = !0, p = r.from(o.node(e).copy(p)), u++) : c--; let f = r.empty, m = 0; for (let e = s, t = !1; e > n; e--)t || i.after(e + 1) < i.end(e) ? (t = !0, f = r.from(i.node(e).copy(f)), m++) : d++; e.step(new Oe(c, d, l, a, new h(p.append(f), u, m), p.size - u, !0)) }(this, e, t), this } join(e, t = 1) { return function (e, t, n) { let r = null, { linebreakReplacement: o } = e.doc.type.schema, i = e.doc.resolve(t - n), s = i.node().type; if (o && s.inlineContent) { let e = "pre" == s.whitespace, t = !!s.contentMatch.matchType(o); e && !t ? r = !1 : !e && t && (r = !0) } let l = e.steps.length; if (!1 === r) { let r = e.doc.resolve(t + n); ze(e, r.node(), r.before(), l) } s.inlineContent && De(e, t + n - 1, s, i.node().contentMatchAt(i.index()), null == r); let a = e.mapping.slice(l), c = a.map(t - n); if (e.step(new Me(c, a.map(t + n, -1), h.empty, !0)), !0 === r) { let t = e.doc.resolve(c); Ie(e, t.node(), t.before(), e.steps.length) } }(this, e, t), this } wrap(e, t) { return function (e, t, n) { let o = r.empty; for (let e = n.length - 1; e >= 0; e--) { if (o.size) { let t = n[e].type.contentMatch.matchFragment(o); if (!t || !t.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") } o = r.from(n[e].type.create(n[e].attrs, o)) } let i = t.start, s = t.end; e.step(new Oe(i, s, i, s, new h(o, 0, 0), n.length, !0)) }(this, e, t), this } setBlockType(e, t = e, n, o = null) { return function (e, t, n, o, i) { if (!o.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock"); let s = e.steps.length; e.doc.nodesBetween(t, n, (t, n) => { let l = "function" == typeof i ? i(t) : i; if (t.isTextblock && !t.hasMarkup(o, l) && function (e, t, n) { let r = e.resolve(t), o = r.index(); return r.parent.canReplaceWith(o, o + 1, n) }(e.doc, e.mapping.slice(s).map(n), o)) { let i = null; if (o.schema.linebreakReplacement) { let e = "pre" == o.whitespace, t = !!o.contentMatch.matchType(o.schema.linebreakReplacement); e && !t ? i = !1 : !e && t && (i = !0) } !1 === i && ze(e, t, n, s), De(e, e.mapping.slice(s).map(n, 1), o, void 0, null === i); let a = e.mapping.slice(s), c = a.map(n, 1), d = a.map(n + t.nodeSize, 1); return e.step(new Oe(c, d, c + 1, d - 1, new h(r.from(o.create(l, null, t.marks)), 0, 0), 1, !0)), !0 === i && Ie(e, t, n, s), !1 } }) }(this, e, t, n, o), this } setNodeMarkup(e, t, n = null, o) { return function (e, t, n, o, i) { let s = e.doc.nodeAt(t); if (!s) throw new RangeError("No node at given position"); n || (n = s.type); let l = n.create(o, null, i || s.marks); if (s.isLeaf) return e.replaceWith(t, t + s.nodeSize, l); if (!n.validContent(s.content)) throw new RangeError("Invalid content for node type " + n.name); e.step(new Oe(t, t + s.nodeSize, t + 1, t + s.nodeSize - 1, new h(r.from(l), 0, 0), 1, !0)) }(this, e, t, n, o), this } setNodeAttribute(e, t, n) { return this.step(new Xe(e, t, n)), this } setDocAttribute(e, t) { return this.step(new Ze(e, t)), this } addNodeMark(e, t) { return this.step(new Se(e, t)), this } removeNodeMark(e, t) { let n = this.doc.nodeAt(e); if (!n) throw new RangeError("No node at position " + e); if (t instanceof l) t.isInSet(n.marks) && this.step(new Ce(e, t)); else { let r, o = n.marks, i = []; for (; r = t.isInSet(o);)i.push(new Ce(e, r)), o = r.removeFromSet(o); for (let e = i.length - 1; e >= 0; e--)this.step(i[e]) } return this } split(e, t = 1, n) { return function (e, t, n = 1, o) { let i = e.doc.resolve(t), s = r.empty, l = r.empty; for (let e = i.depth, t = i.depth - n, a = n - 1; e > t; e--, a--) { s = r.from(i.node(e).copy(s)); let t = o && o[a]; l = r.from(t ? t.type.create(t.attrs, l) : i.node(e).copy(l)) } e.step(new Me(t, t, new h(s.append(l), n, n), !0)) }(this, e, t, n), this } addMark(e, t, n) { return function (e, t, n, r) { let o, i, s = [], l = []; e.doc.nodesBetween(t, n, (e, a, h) => { if (!e.isInline) return; let c = e.marks; if (!r.isInSet(c) && h.type.allowsMarkType(r.type)) { let h = Math.max(a, t), d = Math.min(a + e.nodeSize, n), p = r.addToSet(c); for (let e = 0; e < c.length; e++)c[e].isInSet(p) || (o && o.to == h && o.mark.eq(c[e]) ? o.to = d : s.push(o = new xe(h, d, c[e]))); i && i.to == h ? i.to = d : l.push(i = new ke(h, d, r)) } }), s.forEach(t => e.step(t)), l.forEach(t => e.step(t)) }(this, e, t, n), this } removeMark(e, t, n) { return function (e, t, n, r) { let o = [], i = 0; e.doc.nodesBetween(t, n, (e, s) => { if (!e.isInline) return; i++; let l = null; if (r instanceof j) { let t, n = e.marks; for (; t = r.isInSet(n);)(l || (l = [])).push(t), n = t.removeFromSet(n) } else r ? r.isInSet(e.marks) && (l = [r]) : l = e.marks; if (l && l.length) { let r = Math.min(s + e.nodeSize, n); for (let e = 0; e < l.length; e++) { let n, a = l[e]; for (let e = 0; e < o.length; e++) { let t = o[e]; t.step == i - 1 && a.eq(o[e].style) && (n = t) } n ? (n.to = r, n.step = i) : o.push({ style: a, from: Math.max(s, t), to: r, step: i }) } } }), o.forEach(t => e.step(new xe(t.from, t.to, t.style))) }(this, e, t, n), this } clearIncompatible(e, t, n) { return De(this, e, t, n), this } } var nt = Object.freeze({ __proto__: null, AddMarkStep: ke, AddNodeMarkStep: Se, AttrStep: Xe, DocAttrStep: Ze, MapResult: fe, Mapping: ge, RemoveMarkStep: xe, RemoveNodeMarkStep: Ce, ReplaceAroundStep: Oe, ReplaceStep: Me, Step: we, StepMap: me, StepResult: ve, Transform: tt, get TransformError() { return et }, canJoin: Be, canSplit: Pe, dropPoint: qe, findWrapping: Ae, insertPoint: Fe, joinPoint: Ve, liftTarget: Ee, replaceStep: Le }); const rt = Object.create(null); class ot { constructor(e, t, n) { this.$anchor = e, this.$head = t, this.ranges = n || [new it(e.min(t), e.max(t))] } get anchor() { return this.$anchor.pos } get head() { return this.$head.pos } get from() { return this.$from.pos } get to() { return this.$to.pos } get $from() { return this.ranges[0].$from } get $to() { return this.ranges[0].$to } get empty() { let e = this.ranges; for (let t = 0; t < e.length; t++)if (e[t].$from.pos != e[t].$to.pos) return !1; return !0 } content() { return this.$from.doc.slice(this.from, this.to, !0) } replace(e, t = h.empty) { let n = t.content.lastChild, r = null; for (let e = 0; e < t.openEnd; e++)r = n, n = n.lastChild; let o = e.steps.length, i = this.ranges; for (let s = 0; s < i.length; s++) { let { $from: l, $to: a } = i[s], c = e.mapping.slice(o); e.replaceRange(c.map(l.pos), c.map(a.pos), s ? h.empty : t), 0 == s && mt(e, o, (n ? n.isInline : r && r.isTextblock) ? -1 : 1) } } replaceWith(e, t) { let n = e.steps.length, r = this.ranges; for (let o = 0; o < r.length; o++) { let { $from: i, $to: s } = r[o], l = e.mapping.slice(n), a = l.map(i.pos), h = l.map(s.pos); o ? e.deleteRange(a, h) : (e.replaceRangeWith(a, h, t), mt(e, n, t.isInline ? -1 : 1)) } } static findFrom(e, t, n = !1) { let r = e.parent.inlineContent ? new at(e) : ft(e.node(0), e.parent, e.pos, e.index(), t, n); if (r) return r; for (let r = e.depth - 1; r >= 0; r--) { let o = t < 0 ? ft(e.node(0), e.node(r), e.before(r + 1), e.index(r), t, n) : ft(e.node(0), e.node(r), e.after(r + 1), e.index(r) + 1, t, n); if (o) return o } return null } static near(e, t = 1) { return this.findFrom(e, t) || this.findFrom(e, -t) || new pt(e.node(0)) } static atStart(e) { return ft(e, e, 0, 0, 1) || new pt(e) } static atEnd(e) { return ft(e, e, e.content.size, e.childCount, -1) || new pt(e) } static fromJSON(e, t) { if (!t || !t.type) throw new RangeError("Invalid input for Selection.fromJSON"); let n = rt[t.type]; if (!n) throw new RangeError(`No selection type ${t.type} defined`); return n.fromJSON(e, t) } static jsonID(e, t) { if (e in rt) throw new RangeError("Duplicate use of selection JSON ID " + e); return rt[e] = t, t.prototype.jsonID = e, t } getBookmark() { return at.between(this.$anchor, this.$head).getBookmark() } } ot.prototype.visible = !0; class it { constructor(e, t) { this.$from = e, this.$to = t } } let st = !1; function lt(e) { st || e.parent.inlineContent || (st = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + e.parent.type.name + ")")) } class at extends ot { constructor(e, t = e) { lt(e), lt(t), super(e, t) } get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null } map(e, t) { let n = e.resolve(t.map(this.head)); if (!n.parent.inlineContent) return ot.near(n); let r = e.resolve(t.map(this.anchor)); return new at(r.parent.inlineContent ? r : n, n) } replace(e, t = h.empty) { if (super.replace(e, t), t == h.empty) { let t = this.$from.marksAcross(this.$to); t && e.ensureMarks(t) } } eq(e) { return e instanceof at && e.anchor == this.anchor && e.head == this.head } getBookmark() { return new ht(this.anchor, this.head) } toJSON() { return { type: "text", anchor: this.anchor, head: this.head } } static fromJSON(e, t) { if ("number" != typeof t.anchor || "number" != typeof t.head) throw new RangeError("Invalid input for TextSelection.fromJSON"); return new at(e.resolve(t.anchor), e.resolve(t.head)) } static create(e, t, n = t) { let r = e.resolve(t); return new this(r, n == t ? r : e.resolve(n)) } static between(e, t, n) { let r = e.pos - t.pos; if (n && !r || (n = r >= 0 ? 1 : -1), !t.parent.inlineContent) { let e = ot.findFrom(t, n, !0) || ot.findFrom(t, -n, !0); if (!e) return ot.near(t, n); t = e.$head } return e.parent.inlineContent || (0 == r || (e = (ot.findFrom(e, -n, !0) || ot.findFrom(e, n, !0)).$anchor).pos < t.pos != r < 0) && (e = t), new at(e, t) } } ot.jsonID("text", at); class ht { constructor(e, t) { this.anchor = e, this.head = t } map(e) { return new ht(e.map(this.anchor), e.map(this.head)) } resolve(e) { return at.between(e.resolve(this.anchor), e.resolve(this.head)) } } class ct extends ot { constructor(e) { let t = e.nodeAfter, n = e.node(0).resolve(e.pos + t.nodeSize); super(e, n), this.node = t } map(e, t) { let { deleted: n, pos: r } = t.mapResult(this.anchor), o = e.resolve(r); return n ? ot.near(o) : new ct(o) } content() { return new h(r.from(this.node), 0, 0) } eq(e) { return e instanceof ct && e.anchor == this.anchor } toJSON() { return { type: "node", anchor: this.anchor } } getBookmark() { return new dt(this.anchor) } static fromJSON(e, t) { if ("number" != typeof t.anchor) throw new RangeError("Invalid input for NodeSelection.fromJSON"); return new ct(e.resolve(t.anchor)) } static create(e, t) { return new ct(e.resolve(t)) } static isSelectable(e) { return !e.isText && !1 !== e.type.spec.selectable } } ct.prototype.visible = !1, ot.jsonID("node", ct); class dt { constructor(e) { this.anchor = e } map(e) { let { deleted: t, pos: n } = e.mapResult(this.anchor); return t ? new ht(n, n) : new dt(n) } resolve(e) { let t = e.resolve(this.anchor), n = t.nodeAfter; return n && ct.isSelectable(n) ? new ct(t) : ot.near(t) } } class pt extends ot { constructor(e) { super(e.resolve(0), e.resolve(e.content.size)) } replace(e, t = h.empty) { if (t == h.empty) { e.delete(0, e.doc.content.size); let t = ot.atStart(e.doc); t.eq(e.selection) || e.setSelection(t) } else super.replace(e, t) } toJSON() { return { type: "all" } } static fromJSON(e) { return new pt(e) } map(e) { return new pt(e) } eq(e) { return e instanceof pt } getBookmark() { return ut } } ot.jsonID("all", pt); const ut = { map() { return this }, resolve: e => new pt(e) }; function ft(e, t, n, r, o, i = !1) { if (t.inlineContent) return at.create(e, n); for (let s = r - (o > 0 ? 0 : 1); o > 0 ? s < t.childCount : s >= 0; s += o) { let r = t.child(s); if (r.isAtom) { if (!i && ct.isSelectable(r)) return ct.create(e, n - (o < 0 ? r.nodeSize : 0)) } else { let t = ft(e, r, n + o, o < 0 ? r.childCount : 0, o, i); if (t) return t } n += r.nodeSize * o } return null } function mt(e, t, n) { let r = e.steps.length - 1; if (r < t) return; let o, i = e.steps[r]; (i instanceof Me || i instanceof Oe) && (e.mapping.maps[r].forEach((e, t, n, r) => { null == o && (o = r) }), e.setSelection(ot.near(e.doc.resolve(o), n))) } class gt extends tt { constructor(e) { super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks } get selection() { return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection } setSelection(e) { if (e.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document"); return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = -3 & this.updated | 1, this.storedMarks = null, this } get selectionSet() { return (1 & this.updated) > 0 } setStoredMarks(e) { return this.storedMarks = e, this.updated |= 2, this } ensureMarks(e) { return l.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this } addStoredMark(e) { return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks())) } removeStoredMark(e) { return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks())) } get storedMarksSet() { return (2 & this.updated) > 0 } addStep(e, t) { super.addStep(e, t), this.updated = -3 & this.updated, this.storedMarks = null } setTime(e) { return this.time = e, this } replaceSelection(e) { return this.selection.replace(this, e), this } replaceSelectionWith(e, t = !0) { let n = this.selection; return t && (e = e.mark(this.storedMarks || (n.empty ? n.$from.marks() : n.$from.marksAcross(n.$to) || l.none))), n.replaceWith(this, e), this } deleteSelection() { return this.selection.replace(this), this } insertText(e, t, n) { let r = this.doc.type.schema; if (null == t) return e ? this.replaceSelectionWith(r.text(e), !0) : this.deleteSelection(); { if (null == n && (n = t), n = null == n ? t : n, !e) return this.deleteRange(t, n); let o = this.storedMarks; if (!o) { let e = this.doc.resolve(t); o = n == t ? e.marks() : e.marksAcross(this.doc.resolve(n)) } return this.replaceRangeWith(t, n, r.text(e, o)), this.selection.empty || this.setSelection(ot.near(this.selection.$to)), this } } setMeta(e, t) { return this.meta["string" == typeof e ? e : e.key] = t, this } getMeta(e) { return this.meta["string" == typeof e ? e : e.key] } get isGeneric() { for (let e in this.meta) return !1; return !0 } scrollIntoView() { return this.updated |= 4, this } get scrolledIntoView() { return (4 & this.updated) > 0 } } function yt(e, t) { return t && e ? e.bind(t) : e } class wt { constructor(e, t, n) { this.name = e, this.init = yt(t.init, n), this.apply = yt(t.apply, n) } } const vt = [new wt("doc", { init: e => e.doc || e.schema.topNodeType.createAndFill(), apply: e => e.doc }), new wt("selection", { init: (e, t) => e.selection || ot.atStart(t.doc), apply: e => e.selection }), new wt("storedMarks", { init: e => e.storedMarks || null, apply: (e, t, n, r) => r.selection.$cursor ? e.storedMarks : null }), new wt("scrollToSelection", { init: () => 0, apply: (e, t) => e.scrolledIntoView ? t + 1 : t })]; class bt { constructor(e, t) { this.schema = e, this.plugins = [], this.pluginsByKey = Object.create(null), this.fields = vt.slice(), t && t.forEach(e => { if (this.pluginsByKey[e.key]) throw new RangeError("Adding different instances of a keyed plugin (" + e.key + ")"); this.plugins.push(e), this.pluginsByKey[e.key] = e, e.spec.state && this.fields.push(new wt(e.key, e.spec.state, e)) }) } } class kt { constructor(e) { this.config = e } get schema() { return this.config.schema } get plugins() { return this.config.plugins } apply(e) { return this.applyTransaction(e).state } filterTransaction(e, t = -1) { for (let n = 0; n < this.config.plugins.length; n++)if (n != t) { let t = this.config.plugins[n]; if (t.spec.filterTransaction && !t.spec.filterTransaction.call(t, e, this)) return !1 } return !0 } applyTransaction(e) { if (!this.filterTransaction(e)) return { state: this, transactions: [] }; let t = [e], n = this.applyInner(e), r = null; for (; ;) { let o = !1; for (let i = 0; i < this.config.plugins.length; i++) { let s = this.config.plugins[i]; if (s.spec.appendTransaction) { let l = r ? r[i].n : 0, a = r ? r[i].state : this, h = l < t.length && s.spec.appendTransaction.call(s, l ? t.slice(l) : t, a, n); if (h && n.filterTransaction(h, i)) { if (h.setMeta("appendedTransaction", e), !r) { r = []; for (let e = 0; e < this.config.plugins.length; e++)r.push(e < i ? { state: n, n: t.length } : { state: this, n: 0 }) } t.push(h), n = n.applyInner(h), o = !0 } r && (r[i] = { state: n, n: t.length }) } } if (!o) return { state: n, transactions: t } } } applyInner(e) { if (!e.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction"); let t = new kt(this.config), n = this.config.fields; for (let r = 0; r < n.length; r++) { let o = n[r]; t[o.name] = o.apply(e, this[o.name], this, t) } return t } get tr() { return new gt(this) } static create(e) { let t = new bt(e.doc ? e.doc.type.schema : e.schema, e.plugins), n = new kt(t); for (let r = 0; r < t.fields.length; r++)n[t.fields[r].name] = t.fields[r].init(e, n); return n } reconfigure(e) { let t = new bt(this.schema, e.plugins), n = t.fields, r = new kt(t); for (let t = 0; t < n.length; t++) { let o = n[t].name; r[o] = this.hasOwnProperty(o) ? this[o] : n[t].init(e, r) } return r } toJSON(e) { let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }; if (this.storedMarks && (t.storedMarks = this.storedMarks.map(e => e.toJSON())), e && "object" == typeof e) for (let n in e) { if ("doc" == n || "selection" == n) throw new RangeError("The JSON fields `doc` and `selection` are reserved"); let r = e[n], o = r.spec.state; o && o.toJSON && (t[n] = o.toJSON.call(r, this[r.key])) } return t } static fromJSON(e, t, n) { if (!t) throw new RangeError("Invalid input for EditorState.fromJSON"); if (!e.schema) throw new RangeError("Required config field 'schema' missing"); let r = new bt(e.schema, e.plugins), o = new kt(r); return r.fields.forEach(r => { if ("doc" == r.name) o.doc = N.fromJSON(e.schema, t.doc); else if ("selection" == r.name) o.selection = ot.fromJSON(o.doc, t.selection); else if ("storedMarks" == r.name) t.storedMarks && (o.storedMarks = t.storedMarks.map(e.schema.markFromJSON)); else { if (n) for (let i in n) { let s = n[i], l = s.spec.state; if (s.key == r.name && l && l.fromJSON && Object.prototype.hasOwnProperty.call(t, i)) return void (o[r.name] = l.fromJSON.call(s, e, t[i], o)) } o[r.name] = r.init(e, o) } }), o } } function xt(e, t, n) { for (let r in e) { let o = e[r]; o instanceof Function ? o = o.bind(t) : "handleDOMEvents" == r && (o = xt(o, t, {})), n[r] = o } return n } class St { constructor(e) { this.spec = e, this.props = {}, e.props && xt(e.props, this, this.props), this.key = e.key ? e.key.key : Mt("plugin") } getState(e) { return e[this.key] } } const Ct = Object.create(null); function Mt(e) { return e in Ct ? e + "$" + ++Ct[e] : (Ct[e] = 0, e + "$") } class Ot { constructor(e = "key") { this.key = Mt(e) } get(e) { return e.config.pluginsByKey[this.key] } getState(e) { return e[this.key] } } var Nt = Object.freeze({ __proto__: null, AllSelection: pt, EditorState: kt, NodeSelection: ct, Plugin: St, PluginKey: Ot, Selection: ot, SelectionRange: it, TextSelection: at, Transaction: gt }); const Dt = function (e) { for (var t = 0; ; t++)if (!(e = e.previousSibling)) return t }, Tt = function (e) { let t = e.assignedSlot || e.parentNode; return t && 11 == t.nodeType ? t.host : t }; let Et = null; const At = function (e, t, n) { let r = Et || (Et = document.createRange()); return r.setEnd(e, null == n ? e.nodeValue.length : n), r.setStart(e, t || 0), r }, Rt = function (e, t, n, r) { return n && (zt(e, t, n, r, -1) || zt(e, t, n, r, 1)) }, It = /^(img|br|input|textarea|hr)$/i; function zt(e, t, n, r, o) { for (var i; ;) { if (e == n && t == r) return !0; if (t == (o < 0 ? 0 : Pt(e))) { let n = e.parentNode; if (!n || 1 != n.nodeType || Bt(e) || It.test(e.nodeName) || "false" == e.contentEditable) return !1; t = Dt(e) + (o < 0 ? 0 : 1), e = n } else { if (1 != e.nodeType) return !1; { let n = e.childNodes[t + (o < 0 ? -1 : 0)]; if (1 == n.nodeType && "false" == n.contentEditable) { if (!(null === (i = n.pmViewDesc) || void 0 === i ? void 0 : i.ignoreForSelection)) return !1; t += o } else e = n, t = o < 0 ? Pt(e) : 0 } } } } function Pt(e) { return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length } function Bt(e) { let t; for (let n = e; n && !(t = n.pmViewDesc); n = n.parentNode); return t && t.node && t.node.isBlock && (t.dom == e || t.contentDOM == e) } const $t = function (e) { return e.focusNode && Rt(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset) }; function Vt(e, t) { let n = document.createEvent("Event"); return n.initEvent("keydown", !0, !0), n.keyCode = e, n.key = n.code = t, n } const Ft = "undefined" != typeof navigator ? navigator : null, qt = "undefined" != typeof document ? document : null, Lt = Ft && Ft.userAgent || "", _t = /Edge\/(\d+)/.exec(Lt), Wt = /MSIE \d/.exec(Lt), Jt = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Lt), jt = !!(Wt || Jt || _t), Kt = Wt ? document.documentMode : Jt ? +Jt[1] : _t ? +_t[1] : 0, Ht = !jt && /gecko\/(\d+)/i.test(Lt); Ht && (/Firefox\/(\d+)/.exec(Lt) || [0, 0])[1]; const Ut = !jt && /Chrome\/(\d+)/.exec(Lt), Gt = !!Ut, Yt = Ut ? +Ut[1] : 0, Qt = !jt && !!Ft && /Apple Computer/.test(Ft.vendor), Xt = Qt && (/Mobile\/\w+/.test(Lt) || !!Ft && Ft.maxTouchPoints > 2), Zt = Xt || !!Ft && /Mac/.test(Ft.platform), en = !!Ft && /Win/.test(Ft.platform), tn = /Android \d/.test(Lt), nn = !!qt && "webkitFontSmoothing" in qt.documentElement.style, rn = nn ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0; function on(e) { let t = e.defaultView && e.defaultView.visualViewport; return t ? { left: 0, right: t.width, top: 0, bottom: t.height } : { left: 0, right: e.documentElement.clientWidth, top: 0, bottom: e.documentElement.clientHeight } } function sn(e, t) { return "number" == typeof e ? e : e[t] } function ln(e) { let t = e.getBoundingClientRect(), n = t.width / e.offsetWidth || 1, r = t.height / e.offsetHeight || 1; return { left: t.left, right: t.left + e.clientWidth * n, top: t.top, bottom: t.top + e.clientHeight * r } } function an(e, t, n) { let r = e.someProp("scrollThreshold") || 0, o = e.someProp("scrollMargin") || 5, i = e.dom.ownerDocument; for (let s = n || e.dom; s;) { if (1 != s.nodeType) { s = Tt(s); continue } let e = s, n = e == i.body, l = n ? on(i) : ln(e), a = 0, h = 0; if (t.top < l.top + sn(r, "top") ? h = -(l.top - t.top + sn(o, "top")) : t.bottom > l.bottom - sn(r, "bottom") && (h = t.bottom - t.top > l.bottom - l.top ? t.top + sn(o, "top") - l.top : t.bottom - l.bottom + sn(o, "bottom")), t.left < l.left + sn(r, "left") ? a = -(l.left - t.left + sn(o, "left")) : t.right > l.right - sn(r, "right") && (a = t.right - l.right + sn(o, "right")), a || h) if (n) i.defaultView.scrollBy(a, h); else { let n = e.scrollLeft, r = e.scrollTop; h && (e.scrollTop += h), a && (e.scrollLeft += a); let o = e.scrollLeft - n, i = e.scrollTop - r; t = { left: t.left - o, top: t.top - i, right: t.right - o, bottom: t.bottom - i } } let c = n ? "fixed" : getComputedStyle(s).position; if (/^(fixed|sticky)$/.test(c)) break; s = "absolute" == c ? s.offsetParent : Tt(s) } } function hn(e) { let t = [], n = e.ownerDocument; for (let r = e; r && (t.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), e != n); r = Tt(r)); return t } function cn(e, t) { for (let n = 0; n < e.length; n++) { let { dom: r, top: o, left: i } = e[n]; r.scrollTop != o + t && (r.scrollTop = o + t), r.scrollLeft != i && (r.scrollLeft = i) } } let dn = null; function pn(e, t) { let n, r, o, i, s = 2e8, l = 0, a = t.top, h = t.top; for (let c = e.firstChild, d = 0; c; c = c.nextSibling, d++) { let e; if (1 == c.nodeType) e = c.getClientRects(); else { if (3 != c.nodeType) continue; e = At(c).getClientRects() } for (let p = 0; p < e.length; p++) { let u = e[p]; if (u.top <= a && u.bottom >= h) { a = Math.max(u.bottom, a), h = Math.min(u.top, h); let e = u.left > t.left ? u.left - t.left : u.right < t.left ? t.left - u.right : 0; if (e < s) { n = c, s = e, r = e && 3 == n.nodeType ? { left: u.right < t.left ? u.right : u.left, top: t.top } : t, 1 == c.nodeType && e && (l = d + (t.left >= (u.left + u.right) / 2 ? 1 : 0)); continue } } else u.top > t.top && !o && u.left <= t.left && u.right >= t.left && (o = c, i = { left: Math.max(u.left, Math.min(u.right, t.left)), top: u.top }); !n && (t.left >= u.right && t.top >= u.top || t.left >= u.left && t.top >= u.bottom) && (l = d + 1) } } return !n && o && (n = o, r = i, s = 0), n && 3 == n.nodeType ? function (e, t) { let n = e.nodeValue.length, r = document.createRange(); for (let o = 0; o < n; o++) { r.setEnd(e, o + 1), r.setStart(e, o); let n = yn(r, 1); if (n.top != n.bottom && un(t, n)) return { node: e, offset: o + (t.left >= (n.left + n.right) / 2 ? 1 : 0) } } return { node: e, offset: 0 } }(n, r) : !n || s && 1 == n.nodeType ? { node: e, offset: l } : pn(n, r) } function un(e, t) { return e.left >= t.left - 1 && e.left <= t.right + 1 && e.top >= t.top - 1 && e.top <= t.bottom + 1 } function fn(e, t, n) { let r = e.childNodes.length; if (r && n.top < n.bottom) for (let o = Math.max(0, Math.min(r - 1, Math.floor(r * (t.top - n.top) / (n.bottom - n.top)) - 2)), i = o; ;) { let n = e.childNodes[i]; if (1 == n.nodeType) { let e = n.getClientRects(); for (let r = 0; r < e.length; r++) { let o = e[r]; if (un(t, o)) return fn(n, t, o) } } if ((i = (i + 1) % r) == o) break } return e } function mn(e, t) { let n, r = e.dom.ownerDocument, o = 0, i = function (e, t, n) { if (e.caretPositionFromPoint) try { let r = e.caretPositionFromPoint(t, n); if (r) return { node: r.offsetNode, offset: Math.min(Pt(r.offsetNode), r.offset) } } catch (e) { } if (e.caretRangeFromPoint) { let r = e.caretRangeFromPoint(t, n); if (r) return { node: r.startContainer, offset: Math.min(Pt(r.startContainer), r.startOffset) } } }(r, t.left, t.top); i && ({ node: n, offset: o } = i); let s, l = (e.root.elementFromPoint ? e.root : r).elementFromPoint(t.left, t.top); if (!l || !e.dom.contains(1 != l.nodeType ? l.parentNode : l)) { let n = e.dom.getBoundingClientRect(); if (!un(t, n)) return null; if (l = fn(e.dom, t, n), !l) return null } if (Qt) for (let e = l; n && e; e = Tt(e))e.draggable && (n = void 0); if (l = function (e, t) { let n = e.parentNode; return n && /^li$/i.test(n.nodeName) && t.left < e.getBoundingClientRect().left ? n : e }(l, t), n) { if (Ht && 1 == n.nodeType && (o = Math.min(o, n.childNodes.length), o < n.childNodes.length)) { let e, r = n.childNodes[o]; "IMG" == r.nodeName && (e = r.getBoundingClientRect()).right <= t.left && e.bottom > t.top && o++ } let r; nn && o && 1 == n.nodeType && 1 == (r = n.childNodes[o - 1]).nodeType && "false" == r.contentEditable && r.getBoundingClientRect().top >= t.top && o--, n == e.dom && o == n.childNodes.length - 1 && 1 == n.lastChild.nodeType && t.top > n.lastChild.getBoundingClientRect().bottom ? s = e.state.doc.content.size : 0 != o && 1 == n.nodeType && "BR" == n.childNodes[o - 1].nodeName || (s = function (e, t, n, r) { let o = -1; for (let n = t, i = !1; n != e.dom;) { let t, s = e.docView.nearestDesc(n, !0); if (!s) return null; if (1 == s.dom.nodeType && (s.node.isBlock && s.parent || !s.contentDOM) && ((t = s.dom.getBoundingClientRect()).width || t.height) && (s.node.isBlock && s.parent && !/^T(R|BODY|HEAD|FOOT)$/.test(s.dom.nodeName) && (!i && t.left > r.left || t.top > r.top ? o = s.posBefore : (!i && t.right < r.left || t.bottom < r.top) && (o = s.posAfter), i = !0), !s.contentDOM && o < 0 && !s.node.isText)) return (s.node.isBlock ? r.top < (t.top + t.bottom) / 2 : r.left < (t.left + t.right) / 2) ? s.posBefore : s.posAfter; n = s.dom.parentNode } return o > -1 ? o : e.docView.posFromDOM(t, n, -1) }(e, n, o, t)) } null == s && (s = function (e, t, n) { let { node: r, offset: o } = pn(t, n), i = -1; if (1 == r.nodeType && !r.firstChild) { let e = r.getBoundingClientRect(); i = e.left != e.right && n.left > (e.left + e.right) / 2 ? 1 : -1 } return e.docView.posFromDOM(r, o, i) }(e, l, t)); let a = e.docView.nearestDesc(l, !0); return { pos: s, inside: a ? a.posAtStart - a.border : -1 } } function gn(e) { return e.top < e.bottom || e.left < e.right } function yn(e, t) { let n = e.getClientRects(); if (n.length) { let e = n[t < 0 ? 0 : n.length - 1]; if (gn(e)) return e } return Array.prototype.find.call(n, gn) || e.getBoundingClientRect() } const wn = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; function vn(e, t, n) { let { node: r, offset: o, atom: i } = e.docView.domFromPos(t, n < 0 ? -1 : 1), s = nn || Ht; if (3 == r.nodeType) { if (!s || !wn.test(r.nodeValue) && (n < 0 ? o : o != r.nodeValue.length)) { let e = o, t = o, i = n < 0 ? 1 : -1; return n < 0 && !o ? (t++, i = -1) : n >= 0 && o == r.nodeValue.length ? (e--, i = 1) : n < 0 ? e-- : t++, bn(yn(At(r, e, t), i), i < 0) } { let e = yn(At(r, o, o), n); if (Ht && o && /\s/.test(r.nodeValue[o - 1]) && o < r.nodeValue.length) { let t = yn(At(r, o - 1, o - 1), -1); if (t.top == e.top) { let n = yn(At(r, o, o + 1), -1); if (n.top != e.top) return bn(n, n.left < t.left) } } return e } } if (!e.state.doc.resolve(t - (i || 0)).parent.inlineContent) { if (null == i && o && (n < 0 || o == Pt(r))) { let e = r.childNodes[o - 1]; if (1 == e.nodeType) return kn(e.getBoundingClientRect(), !1) } if (null == i && o < Pt(r)) { let e = r.childNodes[o]; if (1 == e.nodeType) return kn(e.getBoundingClientRect(), !0) } return kn(r.getBoundingClientRect(), n >= 0) } if (null == i && o && (n < 0 || o == Pt(r))) { let e = r.childNodes[o - 1], t = 3 == e.nodeType ? At(e, Pt(e) - (s ? 0 : 1)) : 1 != e.nodeType || "BR" == e.nodeName && e.nextSibling ? null : e; if (t) return bn(yn(t, 1), !1) } if (null == i && o < Pt(r)) { let e = r.childNodes[o]; for (; e.pmViewDesc && e.pmViewDesc.ignoreForCoords;)e = e.nextSibling; let t = e ? 3 == e.nodeType ? At(e, 0, s ? 0 : 1) : 1 == e.nodeType ? e : null : null; if (t) return bn(yn(t, -1), !0) } return bn(yn(3 == r.nodeType ? At(r) : r, -n), n >= 0) } function bn(e, t) { if (0 == e.width) return e; let n = t ? e.left : e.right; return { top: e.top, bottom: e.bottom, left: n, right: n } } function kn(e, t) { if (0 == e.height) return e; let n = t ? e.top : e.bottom; return { top: n, bottom: n, left: e.left, right: e.right } } function xn(e, t, n) { let r = e.state, o = e.root.activeElement; r != t && e.updateState(t), o != e.dom && e.focus(); try { return n() } finally { r != t && e.updateState(r), o != e.dom && o && o.focus() } } const Sn = /[\u0590-\u08ac]/; let Cn = null, Mn = null, On = !1; function Nn(e, t, n) { return Cn == t && Mn == n ? On : (Cn = t, Mn = n, On = "up" == n || "down" == n ? function (e, t, n) { let r = t.selection, o = "up" == n ? r.$from : r.$to; return xn(e, t, () => { let { node: t } = e.docView.domFromPos(o.pos, "up" == n ? -1 : 1); for (; ;) { let n = e.docView.nearestDesc(t, !0); if (!n) break; if (n.node.isBlock) { t = n.contentDOM || n.dom; break } t = n.dom.parentNode } let r = vn(e, o.pos, 1); for (let e = t.firstChild; e; e = e.nextSibling) { let t; if (1 == e.nodeType) t = e.getClientRects(); else { if (3 != e.nodeType) continue; t = At(e, 0, e.nodeValue.length).getClientRects() } for (let e = 0; e < t.length; e++) { let o = t[e]; if (o.bottom > o.top + 1 && ("up" == n ? r.top - o.top > 2 * (o.bottom - r.top) : o.bottom - r.bottom > 2 * (r.bottom - o.top))) return !1 } } return !0 }) }(e, t, n) : function (e, t, n) { let { $head: r } = t.selection; if (!r.parent.isTextblock) return !1; let o = r.parentOffset, i = !o, s = o == r.parent.content.size, l = e.domSelection(); return l ? Sn.test(r.parent.textContent) && l.modify ? xn(e, t, () => { let { focusNode: t, focusOffset: o, anchorNode: i, anchorOffset: s } = e.domSelectionRange(), a = l.caretBidiLevel; l.modify("move", n, "character"); let h = r.depth ? e.docView.domAfterPos(r.before()) : e.dom, { focusNode: c, focusOffset: d } = e.domSelectionRange(), p = c && !h.contains(1 == c.nodeType ? c : c.parentNode) || t == c && o == d; try { l.collapse(i, s), t && (t != i || o != s) && l.extend && l.extend(t, o) } catch (e) { } return null != a && (l.caretBidiLevel = a), p }) : "left" == n || "backward" == n ? i : s : r.pos == r.start() || r.pos == r.end() }(e, t, n)) } class Dn { constructor(e, t, n, r) { this.parent = e, this.children = t, this.dom = n, this.contentDOM = r, this.dirty = 0, n.pmViewDesc = this } matchesWidget(e) { return !1 } matchesMark(e) { return !1 } matchesNode(e, t, n) { return !1 } matchesHack(e) { return !1 } parseRule() { return null } stopEvent(e) { return !1 } get size() { let e = 0; for (let t = 0; t < this.children.length; t++)e += this.children[t].size; return e } get border() { return 0 } destroy() { this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0); for (let e = 0; e < this.children.length; e++)this.children[e].destroy() } posBeforeChild(e) { for (let t = 0, n = this.posAtStart; ; t++) { let r = this.children[t]; if (r == e) return n; n += r.size } } get posBefore() { return this.parent.posBeforeChild(this) } get posAtStart() { return this.parent ? this.parent.posBeforeChild(this) + this.border : 0 } get posAfter() { return this.posBefore + this.size } get posAtEnd() { return this.posAtStart + this.size - 2 * this.border } localPosFromDOM(e, t, n) { if (this.contentDOM && this.contentDOM.contains(1 == e.nodeType ? e : e.parentNode)) { if (n < 0) { let n, r; if (e == this.contentDOM) n = e.childNodes[t - 1]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; n = e.previousSibling } for (; n && (!(r = n.pmViewDesc) || r.parent != this);)n = n.previousSibling; return n ? this.posBeforeChild(r) + r.size : this.posAtStart } { let n, r; if (e == this.contentDOM) n = e.childNodes[t]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; n = e.nextSibling } for (; n && (!(r = n.pmViewDesc) || r.parent != this);)n = n.nextSibling; return n ? this.posBeforeChild(r) : this.posAtEnd } } let r; if (e == this.dom && this.contentDOM) r = t > Dt(this.contentDOM); else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) r = 2 & e.compareDocumentPosition(this.contentDOM); else if (this.dom.firstChild) { if (0 == t) for (let t = e; ; t = t.parentNode) { if (t == this.dom) { r = !1; break } if (t.previousSibling) break } if (null == r && t == e.childNodes.length) for (let t = e; ; t = t.parentNode) { if (t == this.dom) { r = !0; break } if (t.nextSibling) break } } return (null == r ? n > 0 : r) ? this.posAtEnd : this.posAtStart } nearestDesc(e, t = !1) { for (let n = !0, r = e; r; r = r.parentNode) { let o, i = this.getDesc(r); if (i && (!t || i.node)) { if (!n || !(o = i.nodeDOM) || (1 == o.nodeType ? o.contains(1 == e.nodeType ? e : e.parentNode) : o == e)) return i; n = !1 } } } getDesc(e) { let t = e.pmViewDesc; for (let e = t; e; e = e.parent)if (e == this) return t } posFromDOM(e, t, n) { for (let r = e; r; r = r.parentNode) { let o = this.getDesc(r); if (o) return o.localPosFromDOM(e, t, n) } return -1 } descAt(e) { for (let t = 0, n = 0; t < this.children.length; t++) { let r = this.children[t], o = n + r.size; if (n == e && o != n) { for (; !r.border && r.children.length;)for (let e = 0; e < r.children.length; e++) { let t = r.children[e]; if (t.size) { r = t; break } } return r } if (e < o) return r.descAt(e - n - r.border); n = o } } domFromPos(e, t) { if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 }; let n = 0, r = 0; for (let t = 0; n < this.children.length; n++) { let o = this.children[n], i = t + o.size; if (i > e || o instanceof Pn) { r = e - t; break } t = i } if (r) return this.children[n].domFromPos(r - this.children[n].border, t); for (let e; n && !(e = this.children[n - 1]).size && e instanceof Tn && e.side >= 0; n--); if (t <= 0) { let e, r = !0; for (; e = n ? this.children[n - 1] : null, e && e.dom.parentNode != this.contentDOM; n--, r = !1); return e && t && r && !e.border && !e.domAtom ? e.domFromPos(e.size, t) : { node: this.contentDOM, offset: e ? Dt(e.dom) + 1 : 0 } } { let e, r = !0; for (; e = n < this.children.length ? this.children[n] : null, e && e.dom.parentNode != this.contentDOM; n++, r = !1); return e && r && !e.border && !e.domAtom ? e.domFromPos(0, t) : { node: this.contentDOM, offset: e ? Dt(e.dom) : this.contentDOM.childNodes.length } } } parseRange(e, t, n = 0) { if (0 == this.children.length) return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length }; let r = -1, o = -1; for (let i = n, s = 0; ; s++) { let n = this.children[s], l = i + n.size; if (-1 == r && e <= l) { let o = i + n.border; if (e >= o && t <= l - n.border && n.node && n.contentDOM && this.contentDOM.contains(n.contentDOM)) return n.parseRange(e, t, o); e = i; for (let t = s; t > 0; t--) { let n = this.children[t - 1]; if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(1)) { r = Dt(n.dom) + 1; break } e -= n.size } -1 == r && (r = 0) } if (r > -1 && (l > t || s == this.children.length - 1)) { t = l; for (let e = s + 1; e < this.children.length; e++) { let n = this.children[e]; if (n.size && n.dom.parentNode == this.contentDOM && !n.emptyChildAt(-1)) { o = Dt(n.dom); break } t += n.size } -1 == o && (o = this.contentDOM.childNodes.length); break } i = l } return { node: this.contentDOM, from: e, to: t, fromOffset: r, toOffset: o } } emptyChildAt(e) { if (this.border || !this.contentDOM || !this.children.length) return !1; let t = this.children[e < 0 ? 0 : this.children.length - 1]; return 0 == t.size || t.emptyChildAt(e) } domAfterPos(e) { let { node: t, offset: n } = this.domFromPos(e, 0); if (1 != t.nodeType || n == t.childNodes.length) throw new RangeError("No node after pos " + e); return t.childNodes[n] } setSelection(e, t, n, r = !1) { let o = Math.min(e, t), i = Math.max(e, t); for (let s = 0, l = 0; s < this.children.length; s++) { let a = this.children[s], h = l + a.size; if (o > l && i < h) return a.setSelection(e - l - a.border, t - l - a.border, n, r); l = h } let s = this.domFromPos(e, e ? -1 : 1), l = t == e ? s : this.domFromPos(t, t ? -1 : 1), a = n.root.getSelection(), h = n.domSelectionRange(), c = !1; if ((Ht || Qt) && e == t) { let { node: e, offset: t } = s; if (3 == e.nodeType) { if (c = !(!t || "\n" != e.nodeValue[t - 1]), c && t == e.nodeValue.length) for (let t, n = e; n; n = n.parentNode) { if (t = n.nextSibling) { "BR" == t.nodeName && (s = l = { node: t.parentNode, offset: Dt(t) + 1 }); break } let e = n.pmViewDesc; if (e && e.node && e.node.isBlock) break } } else { let n = e.childNodes[t - 1]; c = n && ("BR" == n.nodeName || "false" == n.contentEditable) } } if (Ht && h.focusNode && h.focusNode != l.node && 1 == h.focusNode.nodeType) { let e = h.focusNode.childNodes[h.focusOffset]; e && "false" == e.contentEditable && (r = !0) } if (!(r || c && Qt) && Rt(s.node, s.offset, h.anchorNode, h.anchorOffset) && Rt(l.node, l.offset, h.focusNode, h.focusOffset)) return; let d = !1; if ((a.extend || e == t) && !c) { a.collapse(s.node, s.offset); try { e != t && a.extend(l.node, l.offset), d = !0 } catch (e) { } } if (!d) { if (e > t) { let e = s; s = l, l = e } let n = document.createRange(); n.setEnd(l.node, l.offset), n.setStart(s.node, s.offset), a.removeAllRanges(), a.addRange(n) } } ignoreMutation(e) { return !this.contentDOM && "selection" != e.type } get contentLost() { return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM) } markDirty(e, t) { for (let n = 0, r = 0; r < this.children.length; r++) { let o = this.children[r], i = n + o.size; if (n == i ? e <= i && t >= n : e < i && t > n) { let r = n + o.border, s = i - o.border; if (e >= r && t <= s) return this.dirty = e == n || t == i ? 2 : 1, void (e != r || t != s || !o.contentLost && o.dom.parentNode == this.contentDOM ? o.markDirty(e - r, t - r) : o.dirty = 3); o.dirty = o.dom != o.contentDOM || o.dom.parentNode != this.contentDOM || o.children.length ? 3 : 2 } n = i } this.dirty = 2 } markParentsDirty() { let e = 1; for (let t = this.parent; t; t = t.parent, e++) { let n = 1 == e ? 2 : 1; t.dirty < n && (t.dirty = n) } } get domAtom() { return !1 } get ignoreForCoords() { return !1 } get ignoreForSelection() { return !1 } isText(e) { return !1 } } class Tn extends Dn { constructor(e, t, n, r) { let o, i = t.type.toDOM; if ("function" == typeof i && (i = i(n, () => o ? o.parent ? o.parent.posBeforeChild(o) : void 0 : r)), !t.type.spec.raw) { if (1 != i.nodeType) { let e = document.createElement("span"); e.appendChild(i), i = e } i.contentEditable = "false", i.classList.add("ProseMirror-widget") } super(e, [], i, null), this.widget = t, this.widget = t, o = this } matchesWidget(e) { return 0 == this.dirty && e.type.eq(this.widget.type) } parseRule() { return { ignore: !0 } } stopEvent(e) { let t = this.widget.spec.stopEvent; return !!t && t(e) } ignoreMutation(e) { return "selection" != e.type || this.widget.spec.ignoreSelection } destroy() { this.widget.type.destroy(this.dom), super.destroy() } get domAtom() { return !0 } get ignoreForSelection() { return !!this.widget.type.spec.relaxedSide } get side() { return this.widget.type.side } } class En extends Dn { constructor(e, t, n, r) { super(e, [], t, null), this.textDOM = n, this.text = r } get size() { return this.text.length } localPosFromDOM(e, t) { return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t } domFromPos(e) { return { node: this.textDOM, offset: e } } ignoreMutation(e) { return "characterData" === e.type && e.target.nodeValue == e.oldValue } } class An extends Dn { constructor(e, t, n, r, o) { super(e, [], n, r), this.mark = t, this.spec = o } static create(e, t, n, r) { let o = r.nodeViews[t.type.name], i = o && o(t, r, n); return i && i.dom || (i = oe.renderSpec(document, t.type.spec.toDOM(t, n), null, t.attrs)), new An(e, t, i.dom, i.contentDOM || i.dom, i) } parseRule() { return 3 & this.dirty || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM } } matchesMark(e) { return 3 != this.dirty && this.mark.eq(e) } markDirty(e, t) { if (super.markDirty(e, t), 0 != this.dirty) { let e = this.parent; for (; !e.node;)e = e.parent; e.dirty < this.dirty && (e.dirty = this.dirty), this.dirty = 0 } } slice(e, t, n) { let r = An.create(this.parent, this.mark, !0, n), o = this.children, i = this.size; t < i && (o = Un(o, t, i, n)), e > 0 && (o = Un(o, 0, e, n)); for (let e = 0; e < o.length; e++)o[e].parent = r; return r.children = o, r } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } } class Rn extends Dn { constructor(e, t, n, r, o, i, s, l, a) { super(e, [], o, i), this.node = t, this.outerDeco = n, this.innerDeco = r, this.nodeDOM = s } static create(e, t, n, r, o, i) { let s, l = o.nodeViews[t.type.name], a = l && l(t, o, () => s ? s.parent ? s.parent.posBeforeChild(s) : void 0 : i, n, r), h = a && a.dom, c = a && a.contentDOM; if (t.isText) if (h) { if (3 != h.nodeType) throw new RangeError("Text must be rendered as a DOM text node") } else h = document.createTextNode(t.text); else if (!h) { let e = oe.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs); ({ dom: h, contentDOM: c } = e) } c || t.isText || "BR" == h.nodeName || (h.hasAttribute("contenteditable") || (h.contentEditable = "false"), t.type.spec.draggable && (h.draggable = !0)); let d = h; return h = Wn(h, n, t), a ? s = new Bn(e, t, n, r, h, c || null, d, a, o, i + 1) : t.isText ? new zn(e, t, n, r, h, d, o) : new Rn(e, t, n, r, h, c || null, d, o, i + 1) } parseRule() { if (this.node.type.spec.reparseInView) return null; let e = { node: this.node.type.name, attrs: this.node.attrs }; if ("pre" == this.node.type.whitespace && (e.preserveWhitespace = "full"), this.contentDOM) if (this.contentLost) { for (let t = this.children.length - 1; t >= 0; t--) { let n = this.children[t]; if (this.dom.contains(n.dom.parentNode)) { e.contentElement = n.dom.parentNode; break } } e.contentElement || (e.getContent = () => r.empty) } else e.contentElement = this.contentDOM; else e.getContent = () => this.node.content; return e } matchesNode(e, t, n) { return 0 == this.dirty && e.eq(this.node) && Jn(t, this.outerDeco) && n.eq(this.innerDeco) } get size() { return this.node.nodeSize } get border() { return this.node.isLeaf ? 0 : 1 } updateChildren(e, t) { let n = this.node.inlineContent, r = t, o = e.composing ? this.localCompositionInfo(e, t) : null, i = o && o.pos > -1 ? o : null, s = o && o.pos < 0, a = new Kn(this, i && i.node, e); !function (e, t, n, r) { let o = t.locals(e), i = 0; if (0 == o.length) { for (let n = 0; n < e.childCount; n++) { let s = e.child(n); r(s, o, t.forChild(i, s), n), i += s.nodeSize } return } let s = 0, l = [], a = null; for (let h = 0; ;) { let c, d, p, u; for (; s < o.length && o[s].to == i;) { let e = o[s++]; e.widget && (c ? (d || (d = [c])).push(e) : c = e) } if (c) if (d) { d.sort(Hn); for (let e = 0; e < d.length; e++)n(d[e], h, !!a) } else n(c, h, !!a); if (a) u = -1, p = a, a = null; else { if (!(h < e.childCount)) break; u = h, p = e.child(h++) } for (let e = 0; e < l.length; e++)l[e].to <= i && l.splice(e--, 1); for (; s < o.length && o[s].from <= i && o[s].to > i;)l.push(o[s++]); let f = i + p.nodeSize; if (p.isText) { let e = f; s < o.length && o[s].from < e && (e = o[s].from); for (let t = 0; t < l.length; t++)l[t].to < e && (e = l[t].to); e < f && (a = p.cut(e - i), p = p.cut(0, e - i), f = e, u = -1) } else for (; s < o.length && o[s].to < f;)s++; r(p, p.isInline && !p.isLeaf ? l.filter(e => !e.inline) : l.slice(), t.forChild(i, p), u), i = f } }(this.node, this.innerDeco, (t, o, i) => { t.spec.marks ? a.syncToMarks(t.spec.marks, n, e) : t.type.side >= 0 && !i && a.syncToMarks(o == this.node.childCount ? l.none : this.node.child(o).marks, n, e), a.placeWidget(t, e, r) }, (t, i, l, h) => { let c; a.syncToMarks(t.marks, n, e), a.findNodeMatch(t, i, l, h) || s && e.state.selection.from > r && e.state.selection.to < r + t.nodeSize && (c = a.findIndexWithChild(o.node)) > -1 && a.updateNodeAt(t, i, l, c, e) || a.updateNextNode(t, i, l, e, h, r) || a.addNode(t, i, l, e, r), r += t.nodeSize }), a.syncToMarks([], n, e), this.node.isTextblock && a.addTextblockHacks(), a.destroyRest(), (a.changed || 2 == this.dirty) && (i && this.protectLocalComposition(e, i), $n(this.contentDOM, this.children, e), Xt && function (e) { if ("UL" == e.nodeName || "OL" == e.nodeName) { let t = e.style.cssText; e.style.cssText = t + "; list-style: square !important", window.getComputedStyle(e).listStyle, e.style.cssText = t } }(this.dom)) } localCompositionInfo(e, t) { let { from: n, to: r } = e.state.selection; if (!(e.state.selection instanceof at) || n < t || r > t + this.node.content.size) return null; let o = e.input.compositionNode; if (!o || !this.dom.contains(o.parentNode)) return null; if (this.node.inlineContent) { let e = o.nodeValue, i = function (e, t, n, r) { for (let o = 0, i = 0; o < e.childCount && i <= r;) { let s = e.child(o++), l = i; if (i += s.nodeSize, !s.isText) continue; let a = s.text; for (; o < e.childCount;) { let t = e.child(o++); if (i += t.nodeSize, !t.isText) break; a += t.text } if (i >= n) { if (i >= r && a.slice(r - t.length - l, r - l) == t) return r - t.length; let e = l < r ? a.lastIndexOf(t, r - l - 1) : -1; if (e >= 0 && e + t.length + l >= n) return l + e; if (n == r && a.length >= r + t.length - l && a.slice(r - l, r - l + t.length) == t) return r } } return -1 }(this.node.content, e, n - t, r - t); return i < 0 ? null : { node: o, pos: i, text: e } } return { node: o, pos: -1, text: "" } } protectLocalComposition(e, { node: t, pos: n, text: r }) { if (this.getDesc(t)) return; let o = t; for (; o.parentNode != this.contentDOM; o = o.parentNode) { for (; o.previousSibling;)o.parentNode.removeChild(o.previousSibling); for (; o.nextSibling;)o.parentNode.removeChild(o.nextSibling); o.pmViewDesc && (o.pmViewDesc = void 0) } let i = new En(this, o, t, r); e.input.compositionNodes.push(i), this.children = Un(this.children, n, n + r.length, e, i) } update(e, t, n, r) { return !(3 == this.dirty || !e.sameMarkup(this.node)) && (this.updateInner(e, t, n, r), !0) } updateInner(e, t, n, r) { this.updateOuterDeco(t), this.node = e, this.innerDeco = n, this.contentDOM && this.updateChildren(r, this.posAtStart), this.dirty = 0 } updateOuterDeco(e) { if (Jn(e, this.outerDeco)) return; let t = 1 != this.nodeDOM.nodeType, n = this.dom; this.dom = Ln(this.dom, this.nodeDOM, qn(this.outerDeco, this.node, t), qn(e, this.node, t)), this.dom != n && (n.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e } selectNode() { 1 == this.nodeDOM.nodeType && this.nodeDOM.classList.add("ProseMirror-selectednode"), !this.contentDOM && this.node.type.spec.draggable || (this.dom.draggable = !0) } deselectNode() { 1 == this.nodeDOM.nodeType && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), !this.contentDOM && this.node.type.spec.draggable || this.dom.removeAttribute("draggable")) } get domAtom() { return this.node.isAtom } } function In(e, t, n, r, o) { Wn(r, t, e); let i = new Rn(void 0, e, t, n, r, r, r, o, 0); return i.contentDOM && i.updateChildren(o, 0), i } class zn extends Rn { constructor(e, t, n, r, o, i, s) { super(e, t, n, r, o, null, i, s, 0) } parseRule() { let e = this.nodeDOM.parentNode; for (; e && e != this.dom && !e.pmIsDeco;)e = e.parentNode; return { skip: e || !0 } } update(e, t, n, r) { return !(3 == this.dirty || 0 != this.dirty && !this.inParent() || !e.sameMarkup(this.node)) && (this.updateOuterDeco(t), 0 == this.dirty && e.text == this.node.text || e.text == this.nodeDOM.nodeValue || (this.nodeDOM.nodeValue = e.text, r.trackWrites == this.nodeDOM && (r.trackWrites = null)), this.node = e, this.dirty = 0, !0) } inParent() { let e = this.parent.contentDOM; for (let t = this.nodeDOM; t; t = t.parentNode)if (t == e) return !0; return !1 } domFromPos(e) { return { node: this.nodeDOM, offset: e } } localPosFromDOM(e, t, n) { return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, n) } ignoreMutation(e) { return "characterData" != e.type && "selection" != e.type } slice(e, t, n) { let r = this.node.cut(e, t), o = document.createTextNode(r.text); return new zn(this.parent, r, this.outerDeco, this.innerDeco, o, o, n) } markDirty(e, t) { super.markDirty(e, t), this.dom == this.nodeDOM || 0 != e && t != this.nodeDOM.nodeValue.length || (this.dirty = 3) } get domAtom() { return !1 } isText(e) { return this.node.text == e } } class Pn extends Dn { parseRule() { return { ignore: !0 } } matchesHack(e) { return 0 == this.dirty && this.dom.nodeName == e } get domAtom() { return !0 } get ignoreForCoords() { return "IMG" == this.dom.nodeName } } class Bn extends Rn { constructor(e, t, n, r, o, i, s, l, a, h) { super(e, t, n, r, o, i, s, a, h), this.spec = l } update(e, t, n, r) { if (3 == this.dirty) return !1; if (this.spec.update && (this.node.type == e.type || this.spec.multiType)) { let o = this.spec.update(e, t, n); return o && this.updateInner(e, t, n, r), o } return !(!this.contentDOM && !e.isLeaf) && super.update(e, t, n, r) } selectNode() { this.spec.selectNode ? this.spec.selectNode() : super.selectNode() } deselectNode() { this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode() } setSelection(e, t, n, r) { this.spec.setSelection ? this.spec.setSelection(e, t, n.root) : super.setSelection(e, t, n, r) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } stopEvent(e) { return !!this.spec.stopEvent && this.spec.stopEvent(e) } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } } function $n(e, t, n) { let r = e.firstChild, o = !1; for (let i = 0; i < t.length; i++) { let s = t[i], l = s.dom; if (l.parentNode == e) { for (; l != r;)r = jn(r), o = !0; r = r.nextSibling } else o = !0, e.insertBefore(l, r); if (s instanceof An) { let t = r ? r.previousSibling : e.lastChild; $n(s.contentDOM, s.children, n), r = t ? t.nextSibling : e.firstChild } } for (; r;)r = jn(r), o = !0; o && n.trackWrites == e && (n.trackWrites = null) } const Vn = function (e) { e && (this.nodeName = e) }; Vn.prototype = Object.create(null); const Fn = [new Vn]; function qn(e, t, n) { if (0 == e.length) return Fn; let r = n ? Fn[0] : new Vn, o = [r]; for (let i = 0; i < e.length; i++) { let s = e[i].type.attrs; if (s) { s.nodeName && o.push(r = new Vn(s.nodeName)); for (let e in s) { let i = s[e]; null != i && (n && 1 == o.length && o.push(r = new Vn(t.isInline ? "span" : "div")), "class" == e ? r.class = (r.class ? r.class + " " : "") + i : "style" == e ? r.style = (r.style ? r.style + ";" : "") + i : "nodeName" != e && (r[e] = i)) } } } return o } function Ln(e, t, n, r) { if (n == Fn && r == Fn) return t; let o = t; for (let t = 0; t < r.length; t++) { let i = r[t], s = n[t]; if (t) { let t; s && s.nodeName == i.nodeName && o != e && (t = o.parentNode) && t.nodeName.toLowerCase() == i.nodeName || (t = document.createElement(i.nodeName), t.pmIsDeco = !0, t.appendChild(o), s = Fn[0]), o = t } _n(o, s || Fn[0], i) } return o } function _n(e, t, n) { for (let r in t) "class" == r || "style" == r || "nodeName" == r || r in n || e.removeAttribute(r); for (let r in n) "class" != r && "style" != r && "nodeName" != r && n[r] != t[r] && e.setAttribute(r, n[r]); if (t.class != n.class) { let r = t.class ? t.class.split(" ").filter(Boolean) : [], o = n.class ? n.class.split(" ").filter(Boolean) : []; for (let t = 0; t < r.length; t++)-1 == o.indexOf(r[t]) && e.classList.remove(r[t]); for (let t = 0; t < o.length; t++)-1 == r.indexOf(o[t]) && e.classList.add(o[t]); 0 == e.classList.length && e.removeAttribute("class") } if (t.style != n.style) { if (t.style) { let n, r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g; for (; n = r.exec(t.style);)e.style.removeProperty(n[1]) } n.style && (e.style.cssText += n.style) } } function Wn(e, t, n) { return Ln(e, e, Fn, qn(t, n, 1 != e.nodeType)) } function Jn(e, t) { if (e.length != t.length) return !1; for (let n = 0; n < e.length; n++)if (!e[n].type.eq(t[n].type)) return !1; return !0 } function jn(e) { let t = e.nextSibling; return e.parentNode.removeChild(e), t } class Kn { constructor(e, t, n) { this.lock = t, this.view = n, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = function (e, t) { let n = t, r = n.children.length, o = e.childCount, i = new Map, s = []; e: for (; o > 0;) { let l; for (; ;)if (r) { let e = n.children[r - 1]; if (!(e instanceof An)) { l = e, r--; break } n = e, r = e.children.length } else { if (n == t) break e; r = n.parent.children.indexOf(n), n = n.parent } let a = l.node; if (a) { if (a != e.child(o - 1)) break; --o, i.set(l, o), s.push(l) } } return { index: o, matched: i, matches: s.reverse() } }(e.node.content, e) } destroyBetween(e, t) { if (e != t) { for (let n = e; n < t; n++)this.top.children[n].destroy(); this.top.children.splice(e, t - e), this.changed = !0 } } destroyRest() { this.destroyBetween(this.index, this.top.children.length) } syncToMarks(e, t, n) { let r = 0, o = this.stack.length >> 1, i = Math.min(o, e.length); for (; r < i && (r == o - 1 ? this.top : this.stack[r + 1 << 1]).matchesMark(e[r]) && !1 !== e[r].type.spec.spanning;)r++; for (; r < o;)this.destroyRest(), this.top.dirty = 0, this.index = this.stack.pop(), this.top = this.stack.pop(), o--; for (; o < e.length;) { this.stack.push(this.top, this.index + 1); let r = -1; for (let t = this.index; t < Math.min(this.index + 3, this.top.children.length); t++) { let n = this.top.children[t]; if (n.matchesMark(e[o]) && !this.isLocked(n.dom)) { r = t; break } } if (r > -1) r > this.index && (this.changed = !0, this.destroyBetween(this.index, r)), this.top = this.top.children[this.index]; else { let r = An.create(this.top, e[o], t, n); this.top.children.splice(this.index, 0, r), this.top = r, this.changed = !0 } this.index = 0, o++ } } findNodeMatch(e, t, n, r) { let o, i = -1; if (r >= this.preMatch.index && (o = this.preMatch.matches[r - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, n)) i = this.top.children.indexOf(o, this.index); else for (let r = this.index, o = Math.min(this.top.children.length, r + 5); r < o; r++) { let o = this.top.children[r]; if (o.matchesNode(e, t, n) && !this.preMatch.matched.has(o)) { i = r; break } } return !(i < 0) && (this.destroyBetween(this.index, i), this.index++, !0) } updateNodeAt(e, t, n, r, o) { let i = this.top.children[r]; return 3 == i.dirty && i.dom == i.contentDOM && (i.dirty = 2), !!i.update(e, t, n, o) && (this.destroyBetween(this.index, r), this.index++, !0) } findIndexWithChild(e) { for (; ;) { let t = e.parentNode; if (!t) return -1; if (t == this.top.contentDOM) { let t = e.pmViewDesc; if (t) for (let e = this.index; e < this.top.children.length; e++)if (this.top.children[e] == t) return e; return -1 } e = t } } updateNextNode(e, t, n, r, o, i) { for (let s = this.index; s < this.top.children.length; s++) { let l = this.top.children[s]; if (l instanceof Rn) { let a = this.preMatch.matched.get(l); if (null != a && a != o) return !1; let h, c = l.dom, d = this.isLocked(c) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && 3 != l.dirty && Jn(t, l.outerDeco)); if (!d && l.update(e, t, n, r)) return this.destroyBetween(this.index, s), l.dom != c && (this.changed = !0), this.index++, !0; if (!d && (h = this.recreateWrapper(l, e, t, n, r, i))) return this.destroyBetween(this.index, s), this.top.children[this.index] = h, h.contentDOM && (h.dirty = 2, h.updateChildren(r, i + 1), h.dirty = 0), this.changed = !0, this.index++, !0; break } } return !1 } recreateWrapper(e, t, n, r, o, i) { if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !Jn(n, e.outerDeco) || !r.eq(e.innerDeco)) return null; let s = Rn.create(this.top, t, n, r, o, i); if (s.contentDOM) { s.children = e.children, e.children = []; for (let e of s.children) e.parent = s } return e.destroy(), s } addNode(e, t, n, r, o) { let i = Rn.create(this.top, e, t, n, r, o); i.contentDOM && i.updateChildren(r, o + 1), this.top.children.splice(this.index++, 0, i), this.changed = !0 } placeWidget(e, t, n) { let r = this.index < this.top.children.length ? this.top.children[this.index] : null; if (!r || !r.matchesWidget(e) || e != r.widget && r.widget.type.toDOM.parentNode) { let r = new Tn(this.top, e, t, n); this.top.children.splice(this.index++, 0, r), this.changed = !0 } else this.index++ } addTextblockHacks() { let e = this.top.children[this.index - 1], t = this.top; for (; e instanceof An;)t = e, e = t.children[t.children.length - 1]; (!e || !(e instanceof zn) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Qt || Gt) && e && "false" == e.dom.contentEditable && this.addHackNode("IMG", t), this.addHackNode("BR", this.top)) } addHackNode(e, t) { if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e)) this.index++; else { let n = document.createElement(e); "IMG" == e && (n.className = "ProseMirror-separator", n.alt = ""), "BR" == e && (n.className = "ProseMirror-trailingBreak"); let r = new Pn(this.top, [], n, null); t != this.top ? t.children.push(r) : t.children.splice(this.index++, 0, r), this.changed = !0 } } isLocked(e) { return this.lock && (e == this.lock || 1 == e.nodeType && e.contains(this.lock.parentNode)) } } function Hn(e, t) { return e.type.side - t.type.side } function Un(e, t, n, r, o) { let i = []; for (let s = 0, l = 0; s < e.length; s++) { let a = e[s], h = l, c = l += a.size; h >= n || c <= t ? i.push(a) : (h < t && i.push(a.slice(0, t - h, r)), o && (i.push(o), o = void 0), c > n && i.push(a.slice(n - h, a.size, r))) } return i } function Gn(e, t = null) { let n = e.domSelectionRange(), r = e.state.doc; if (!n.focusNode) return null; let o = e.docView.nearestDesc(n.focusNode), i = o && 0 == o.size, s = e.docView.posFromDOM(n.focusNode, n.focusOffset, 1); if (s < 0) return null; let l, a, h = r.resolve(s); if ($t(n)) { for (l = s; o && !o.node;)o = o.parent; let e = o.node; if (o && e.isAtom && ct.isSelectable(e) && o.parent && (!e.isInline || !function (e, t, n) { for (let r = 0 == t, o = t == Pt(e); r || o;) { if (e == n) return !0; let t = Dt(e); if (!(e = e.parentNode)) return !1; r = r && 0 == t, o = o && t == Pt(e) } }(n.focusNode, n.focusOffset, o.dom))) { let e = o.posBefore; a = new ct(s == e ? h : r.resolve(e)) } } else { if (n instanceof e.dom.ownerDocument.defaultView.Selection && n.rangeCount > 1) { let t = s, o = s; for (let r = 0; r < n.rangeCount; r++) { let i = n.getRangeAt(r); t = Math.min(t, e.docView.posFromDOM(i.startContainer, i.startOffset, 1)), o = Math.max(o, e.docView.posFromDOM(i.endContainer, i.endOffset, -1)) } if (t < 0) return null;[l, s] = o == e.state.selection.anchor ? [o, t] : [t, o], h = r.resolve(s) } else l = e.docView.posFromDOM(n.anchorNode, n.anchorOffset, 1); if (l < 0) return null } let c = r.resolve(l); if (!a) { a = or(e, c, h, "pointer" == t || e.state.selection.head < h.pos && !i ? 1 : -1) } return a } function Yn(e) { return e.editable ? e.hasFocus() : sr(e) && document.activeElement && document.activeElement.contains(e.dom) } function Qn(e, t = !1) { let n = e.state.selection; if (nr(e, n), Yn(e)) { if (!t && e.input.mouseDown && e.input.mouseDown.allowDefault && Gt) { let t = e.domSelectionRange(), n = e.domObserver.currentSelection; if (t.anchorNode && n.anchorNode && Rt(t.anchorNode, t.anchorOffset, n.anchorNode, n.anchorOffset)) return e.input.mouseDown.delayedSelectionSync = !0, void e.domObserver.setCurSelection() } if (e.domObserver.disconnectSelection(), e.cursorWrapper) !function (e) { let t = e.domSelection(), n = document.createRange(); if (!t) return; let r = e.cursorWrapper.dom, o = "IMG" == r.nodeName; o ? n.setStart(r.parentNode, Dt(r) + 1) : n.setStart(r, 0); n.collapse(!0), t.removeAllRanges(), t.addRange(n), !o && !e.state.selection.visible && jt && Kt <= 11 && (r.disabled = !0, r.disabled = !1) }(e); else { let r, o, { anchor: i, head: s } = n; !Xn || n instanceof at || (n.$from.parent.inlineContent || (r = Zn(e, n.from)), n.empty || n.$from.parent.inlineContent || (o = Zn(e, n.to))), e.docView.setSelection(i, s, e, t), Xn && (r && tr(r), o && tr(o)), n.visible ? e.dom.classList.remove("ProseMirror-hideselection") : (e.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && function (e) { let t = e.dom.ownerDocument; t.removeEventListener("selectionchange", e.input.hideSelectionGuard); let n = e.domSelectionRange(), r = n.anchorNode, o = n.anchorOffset; t.addEventListener("selectionchange", e.input.hideSelectionGuard = () => { n.anchorNode == r && n.anchorOffset == o || (t.removeEventListener("selectionchange", e.input.hideSelectionGuard), setTimeout(() => { Yn(e) && !e.state.selection.visible || e.dom.classList.remove("ProseMirror-hideselection") }, 20)) }) }(e)) } e.domObserver.setCurSelection(), e.domObserver.connectSelection() } } const Xn = Qt || Gt && Yt < 63; function Zn(e, t) { let { node: n, offset: r } = e.docView.domFromPos(t, 0), o = r < n.childNodes.length ? n.childNodes[r] : null, i = r ? n.childNodes[r - 1] : null; if (Qt && o && "false" == o.contentEditable) return er(o); if (!(o && "false" != o.contentEditable || i && "false" != i.contentEditable)) { if (o) return er(o); if (i) return er(i) } } function er(e) { return e.contentEditable = "true", Qt && e.draggable && (e.draggable = !1, e.wasDraggable = !0), e } function tr(e) { e.contentEditable = "false", e.wasDraggable && (e.draggable = !0, e.wasDraggable = null) } function nr(e, t) { if (t instanceof ct) { let n = e.docView.descAt(t.from); n != e.lastSelectedViewDesc && (rr(e), n && n.selectNode(), e.lastSelectedViewDesc = n) } else rr(e) } function rr(e) { e.lastSelectedViewDesc && (e.lastSelectedViewDesc.parent && e.lastSelectedViewDesc.deselectNode(), e.lastSelectedViewDesc = void 0) } function or(e, t, n, r) { return e.someProp("createSelectionBetween", r => r(e, t, n)) || at.between(t, n, r) } function ir(e) { return !(e.editable && !e.hasFocus()) && sr(e) } function sr(e) { let t = e.domSelectionRange(); if (!t.anchorNode) return !1; try { return e.dom.contains(3 == t.anchorNode.nodeType ? t.anchorNode.parentNode : t.anchorNode) && (e.editable || e.dom.contains(3 == t.focusNode.nodeType ? t.focusNode.parentNode : t.focusNode)) } catch (e) { return !1 } } function lr(e, t) { let { $anchor: n, $head: r } = e.selection, o = t > 0 ? n.max(r) : n.min(r), i = o.parent.inlineContent ? o.depth ? e.doc.resolve(t > 0 ? o.after() : o.before()) : null : o; return i && ot.findFrom(i, t) } function ar(e, t) { return e.dispatch(e.state.tr.setSelection(t).scrollIntoView()), !0 } function hr(e, t, n) { let r = e.state.selection; if (!(r instanceof at)) { if (r instanceof ct && r.node.isInline) return ar(e, new at(t > 0 ? r.$to : r.$from)); { let n = lr(e.state, t); return !!n && ar(e, n) } } if (n.indexOf("s") > -1) { let { $head: n } = r, o = n.textOffset ? null : t < 0 ? n.nodeBefore : n.nodeAfter; if (!o || o.isText || !o.isLeaf) return !1; let i = e.state.doc.resolve(n.pos + o.nodeSize * (t < 0 ? -1 : 1)); return ar(e, new at(r.$anchor, i)) } if (!r.empty) return !1; if (e.endOfTextblock(t > 0 ? "forward" : "backward")) { let n = lr(e.state, t); return !!(n && n instanceof ct) && ar(e, n) } if (!(Zt && n.indexOf("m") > -1)) { let n, o = r.$head, i = o.textOffset ? null : t < 0 ? o.nodeBefore : o.nodeAfter; if (!i || i.isText) return !1; let s = t < 0 ? o.pos - i.nodeSize : o.pos; return !!(i.isAtom || (n = e.docView.descAt(s)) && !n.contentDOM) && (ct.isSelectable(i) ? ar(e, new ct(t < 0 ? e.state.doc.resolve(o.pos - i.nodeSize) : o)) : !!nn && ar(e, new at(e.state.doc.resolve(t < 0 ? s : s + i.nodeSize)))) } } function cr(e) { return 3 == e.nodeType ? e.nodeValue.length : e.childNodes.length } function dr(e, t) { let n = e.pmViewDesc; return n && 0 == n.size && (t < 0 || e.nextSibling || "BR" != e.nodeName) } function pr(e, t) { return t < 0 ? function (e) { let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset; if (!n) return; let o, i, s = !1; Ht && 1 == n.nodeType && r < cr(n) && dr(n.childNodes[r], -1) && (s = !0); for (; ;)if (r > 0) { if (1 != n.nodeType) break; { let e = n.childNodes[r - 1]; if (dr(e, -1)) o = n, i = --r; else { if (3 != e.nodeType) break; n = e, r = n.nodeValue.length } } } else { if (ur(n)) break; { let t = n.previousSibling; for (; t && dr(t, -1);)o = n.parentNode, i = Dt(t), t = t.previousSibling; if (t) n = t, r = cr(n); else { if (n = n.parentNode, n == e.dom) break; r = 0 } } } s ? fr(e, n, r) : o && fr(e, o, i) }(e) : function (e) { let t = e.domSelectionRange(), n = t.focusNode, r = t.focusOffset; if (!n) return; let o, i, s = cr(n); for (; ;)if (r < s) { if (1 != n.nodeType) break; if (!dr(n.childNodes[r], 1)) break; o = n, i = ++r } else { if (ur(n)) break; { let t = n.nextSibling; for (; t && dr(t, 1);)o = t.parentNode, i = Dt(t) + 1, t = t.nextSibling; if (t) n = t, r = 0, s = cr(n); else { if (n = n.parentNode, n == e.dom) break; r = s = 0 } } } o && fr(e, o, i) }(e) } function ur(e) { let t = e.pmViewDesc; return t && t.node && t.node.isBlock } function fr(e, t, n) { if (3 != t.nodeType) { let e, r; (r = function (e, t) { for (; e && t == e.childNodes.length && !Bt(e);)t = Dt(e) + 1, e = e.parentNode; for (; e && t < e.childNodes.length;) { let n = e.childNodes[t]; if (3 == n.nodeType) return n; if (1 == n.nodeType && "false" == n.contentEditable) break; e = n, t = 0 } }(t, n)) ? (t = r, n = 0) : (e = function (e, t) { for (; e && !t && !Bt(e);)t = Dt(e), e = e.parentNode; for (; e && t;) { let n = e.childNodes[t - 1]; if (3 == n.nodeType) return n; if (1 == n.nodeType && "false" == n.contentEditable) break; t = (e = n).childNodes.length } }(t, n)) && (t = e, n = e.nodeValue.length) } let r = e.domSelection(); if (!r) return; if ($t(r)) { let e = document.createRange(); e.setEnd(t, n), e.setStart(t, n), r.removeAllRanges(), r.addRange(e) } else r.extend && r.extend(t, n); e.domObserver.setCurSelection(); let { state: o } = e; setTimeout(() => { e.state == o && Qn(e) }, 50) } function mr(e, t) { let n = e.state.doc.resolve(t); if (!Gt && !en && n.parent.inlineContent) { let r = e.coordsAtPos(t); if (t > n.start()) { let n = e.coordsAtPos(t - 1), o = (n.top + n.bottom) / 2; if (o > r.top && o < r.bottom && Math.abs(n.left - r.left) > 1) return n.left < r.left ? "ltr" : "rtl" } if (t < n.end()) { let n = e.coordsAtPos(t + 1), o = (n.top + n.bottom) / 2; if (o > r.top && o < r.bottom && Math.abs(n.left - r.left) > 1) return n.left > r.left ? "ltr" : "rtl" } } return "rtl" == getComputedStyle(e.dom).direction ? "rtl" : "ltr" } function gr(e, t, n) { let r = e.state.selection; if (r instanceof at && !r.empty || n.indexOf("s") > -1) return !1; if (Zt && n.indexOf("m") > -1) return !1; let { $from: o, $to: i } = r; if (!o.parent.inlineContent || e.endOfTextblock(t < 0 ? "up" : "down")) { let n = lr(e.state, t); if (n && n instanceof ct) return ar(e, n) } if (!o.parent.inlineContent) { let n = t < 0 ? o : i, s = r instanceof pt ? ot.near(n, t) : ot.findFrom(n, t); return !!s && ar(e, s) } return !1 } function yr(e, t) { if (!(e.state.selection instanceof at)) return !0; let { $head: n, $anchor: r, empty: o } = e.state.selection; if (!n.sameParent(r)) return !0; if (!o) return !1; if (e.endOfTextblock(t > 0 ? "forward" : "backward")) return !0; let i = !n.textOffset && (t < 0 ? n.nodeBefore : n.nodeAfter); if (i && !i.isText) { let r = e.state.tr; return t < 0 ? r.delete(n.pos - i.nodeSize, n.pos) : r.delete(n.pos, n.pos + i.nodeSize), e.dispatch(r), !0 } return !1 } function wr(e, t, n) { e.domObserver.stop(), t.contentEditable = n, e.domObserver.start() } function vr(e, t) { let n = t.keyCode, r = function (e) { let t = ""; return e.ctrlKey && (t += "c"), e.metaKey && (t += "m"), e.altKey && (t += "a"), e.shiftKey && (t += "s"), t }(t); if (8 == n || Zt && 72 == n && "c" == r) return yr(e, -1) || pr(e, -1); if (46 == n && !t.shiftKey || Zt && 68 == n && "c" == r) return yr(e, 1) || pr(e, 1); if (13 == n || 27 == n) return !0; if (37 == n || Zt && 66 == n && "c" == r) { let t = 37 == n ? "ltr" == mr(e, e.state.selection.from) ? -1 : 1 : -1; return hr(e, t, r) || pr(e, t) } if (39 == n || Zt && 70 == n && "c" == r) { let t = 39 == n ? "ltr" == mr(e, e.state.selection.from) ? 1 : -1 : 1; return hr(e, t, r) || pr(e, t) } return 38 == n || Zt && 80 == n && "c" == r ? gr(e, -1, r) || pr(e, -1) : 40 == n || Zt && 78 == n && "c" == r ? function (e) { if (!Qt || e.state.selection.$head.parentOffset > 0) return !1; let { focusNode: t, focusOffset: n } = e.domSelectionRange(); if (t && 1 == t.nodeType && 0 == n && t.firstChild && "false" == t.firstChild.contentEditable) { let n = t.firstChild; wr(e, n, "true"), setTimeout(() => wr(e, n, "false"), 20) } return !1 }(e) || gr(e, 1, r) || pr(e, 1) : r == (Zt ? "m" : "c") && (66 == n || 73 == n || 89 == n || 90 == n) } function br(e, t) { e.someProp("transformCopied", n => { t = n(t, e) }); let n = [], { content: r, openStart: o, openEnd: i } = t; for (; o > 1 && i > 1 && 1 == r.childCount && 1 == r.firstChild.childCount;) { o--, i--; let e = r.firstChild; n.push(e.type.name, e.attrs != e.type.defaultAttrs ? e.attrs : null), r = e.content } let s = e.someProp("clipboardSerializer") || oe.fromSchema(e.state.schema), l = Er(), a = l.createElement("div"); a.appendChild(s.serializeFragment(r, { document: l })); let h, c = a.firstChild, d = 0; for (; c && 1 == c.nodeType && (h = Dr[c.nodeName.toLowerCase()]);) { for (let e = h.length - 1; e >= 0; e--) { let t = l.createElement(h[e]); for (; a.firstChild;)t.appendChild(a.firstChild); a.appendChild(t), d++ } c = a.firstChild } return c && 1 == c.nodeType && c.setAttribute("data-pm-slice", `${o} ${i}${d ? ` -${d}` : ""} ${JSON.stringify(n)}`), { dom: a, text: e.someProp("clipboardTextSerializer", n => n(t, e)) || t.content.textBetween(0, t.content.size, "\n\n"), slice: t } } function kr(e, t, n, o, i) { let s, l, a = i.parent.type.spec.code; if (!n && !t) return null; let c = t && (o || a || !n); if (c) { if (e.someProp("transformPastedText", n => { t = n(t, a || o, e) }), a) return t ? new h(r.from(e.state.schema.text(t.replace(/\r\n?/g, "\n"))), 0, 0) : h.empty; let n = e.someProp("clipboardTextParser", n => n(t, i, o, e)); if (n) l = n; else { let n = i.marks(), { schema: r } = e.state, o = oe.fromSchema(r); s = document.createElement("div"), t.split(/(?:\r\n?|\n)+/).forEach(e => { let t = s.appendChild(document.createElement("p")); e && t.appendChild(o.serializeNode(r.text(e, n))) }) } } else e.someProp("transformPastedHTML", t => { n = t(n, e) }), s = function (e) { let t = /^(\s*<meta [^>]*>)*/.exec(e); t && (e = e.slice(t[0].length)); let n, r = Er().createElement("div"), o = /<([a-z][^>\s]+)/i.exec(e); (n = o && Dr[o[1].toLowerCase()]) && (e = n.map(e => "<" + e + ">").join("") + e + n.map(e => "</" + e + ">").reverse().join("")); if (r.innerHTML = function (e) { let t = window.trustedTypes; if (!t) return e; Ar || (Ar = t.defaultPolicy || t.createPolicy("ProseMirrorClipboard", { createHTML: e => e })); return Ar.createHTML(e) }(e), n) for (let e = 0; e < n.length; e++)r = r.querySelector(n[e]) || r; return r }(n), nn && function (e) { let t = e.querySelectorAll(Gt ? "span:not([class]):not([style])" : "span.Apple-converted-space"); for (let n = 0; n < t.length; n++) { let r = t[n]; 1 == r.childNodes.length && " " == r.textContent && r.parentNode && r.parentNode.replaceChild(e.ownerDocument.createTextNode(" "), r) } }(s); let d = s && s.querySelector("[data-pm-slice]"), p = d && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(d.getAttribute("data-pm-slice") || ""); if (p && p[3]) for (let e = +p[3]; e > 0; e--) { let e = s.firstChild; for (; e && 1 != e.nodeType;)e = e.nextSibling; if (!e) break; s = e } if (!l) { let t = e.someProp("clipboardParser") || e.someProp("domParser") || U.fromSchema(e.state.schema); l = t.parseSlice(s, { preserveWhitespace: !(!c && !p), context: i, ruleFromNode: e => "BR" != e.nodeName || e.nextSibling || !e.parentNode || xr.test(e.parentNode.nodeName) ? null : { ignore: !0 } }) } if (p) l = function (e, t) { if (!e.size) return e; let n, o = e.content.firstChild.type.schema; try { n = JSON.parse(t) } catch (t) { return e } let { content: i, openStart: s, openEnd: l } = e; for (let e = n.length - 2; e >= 0; e -= 2) { let t = o.nodes[n[e]]; if (!t || t.hasRequiredAttrs()) break; i = r.from(t.create(n[e + 1], i)), s++, l++ } return new h(i, s, l) }(Nr(l, +p[1], +p[2]), p[4]); else if (l = h.maxOpen(function (e, t) { if (e.childCount < 2) return e; for (let n = t.depth; n >= 0; n--) { let o, i = t.node(n).contentMatchAt(t.index(n)), s = []; if (e.forEach(e => { if (!s) return; let t, n = i.findWrapping(e.type); if (!n) return s = null; if (t = s.length && o.length && Cr(n, o, e, s[s.length - 1], 0)) s[s.length - 1] = t; else { s.length && (s[s.length - 1] = Mr(s[s.length - 1], o.length)); let t = Sr(e, n); s.push(t), i = i.matchType(t.type), o = n } }), s) return r.from(s) } return e }(l.content, i), !0), l.openStart || l.openEnd) { let e = 0, t = 0; for (let t = l.content.firstChild; e < l.openStart && !t.type.spec.isolating; e++, t = t.firstChild); for (let e = l.content.lastChild; t < l.openEnd && !e.type.spec.isolating; t++, e = e.lastChild); l = Nr(l, e, t) } return e.someProp("transformPasted", t => { l = t(l, e) }), l } const xr = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i; function Sr(e, t, n = 0) { for (let o = t.length - 1; o >= n; o--)e = t[o].create(null, r.from(e)); return e } function Cr(e, t, n, o, i) { if (i < e.length && i < t.length && e[i] == t[i]) { let s = Cr(e, t, n, o.lastChild, i + 1); if (s) return o.copy(o.content.replaceChild(o.childCount - 1, s)); if (o.contentMatchAt(o.childCount).matchType(i == e.length - 1 ? n.type : e[i + 1])) return o.copy(o.content.append(r.from(Sr(n, e, i + 1)))) } } function Mr(e, t) { if (0 == t) return e; let n = e.content.replaceChild(e.childCount - 1, Mr(e.lastChild, t - 1)), o = e.contentMatchAt(e.childCount).fillBefore(r.empty, !0); return e.copy(n.append(o)) } function Or(e, t, n, o, i, s) { let l = t < 0 ? e.firstChild : e.lastChild, a = l.content; return e.childCount > 1 && (s = 0), i < o - 1 && (a = Or(a, t, n, o, i + 1, s)), i >= n && (a = t < 0 ? l.contentMatchAt(0).fillBefore(a, s <= i).append(a) : a.append(l.contentMatchAt(l.childCount).fillBefore(r.empty, !0))), e.replaceChild(t < 0 ? 0 : e.childCount - 1, l.copy(a)) } function Nr(e, t, n) { return t < e.openStart && (e = new h(Or(e.content, -1, t, e.openStart, 0, e.openEnd), t, e.openEnd)), n < e.openEnd && (e = new h(Or(e.content, 1, n, e.openEnd, 0, 0), e.openStart, n)), e } const Dr = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] }; let Tr = null; function Er() { return Tr || (Tr = document.implementation.createHTMLDocument("title")) } let Ar = null; const Rr = {}, Ir = {}, zr = { touchstart: !0, touchmove: !0 }; class Pr { constructor() { this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "", button: 0 }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastChromeDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = Object.create(null), this.hideSelectionGuard = null } } function Br(e, t) { e.input.lastSelectionOrigin = t, e.input.lastSelectionTime = Date.now() } function $r(e) { e.someProp("handleDOMEvents", t => { for (let n in t) e.input.eventHandlers[n] || e.dom.addEventListener(n, e.input.eventHandlers[n] = t => Vr(e, t)) }) } function Vr(e, t) { return e.someProp("handleDOMEvents", n => { let r = n[t.type]; return !!r && (r(e, t) || t.defaultPrevented) }) } function Fr(e, t) { if (!t.bubbles) return !0; if (t.defaultPrevented) return !1; for (let n = t.target; n != e.dom; n = n.parentNode)if (!n || 11 == n.nodeType || n.pmViewDesc && n.pmViewDesc.stopEvent(t)) return !1; return !0 } function qr(e) { return { left: e.clientX, top: e.clientY } } function Lr(e, t, n, r, o) { if (-1 == r) return !1; let i = e.state.doc.resolve(r); for (let r = i.depth + 1; r > 0; r--)if (e.someProp(t, t => r > i.depth ? t(e, n, i.nodeAfter, i.before(r), o, !0) : t(e, n, i.node(r), i.before(r), o, !1))) return !0; return !1 } function _r(e, t, n) { if (e.focused || e.focus(), e.state.selection.eq(t)) return; let r = e.state.tr.setSelection(t); "pointer" == n && r.setMeta("pointer", !0), e.dispatch(r) } function Wr(e, t, n, r, o) { return Lr(e, "handleClickOn", t, n, r) || e.someProp("handleClick", n => n(e, t, r)) || (o ? function (e, t) { if (-1 == t) return !1; let n, r, o = e.state.selection; o instanceof ct && (n = o.node); let i = e.state.doc.resolve(t); for (let e = i.depth + 1; e > 0; e--) { let t = e > i.depth ? i.nodeAfter : i.node(e); if (ct.isSelectable(t)) { r = n && o.$from.depth > 0 && e >= o.$from.depth && i.before(o.$from.depth + 1) == o.$from.pos ? i.before(o.$from.depth) : i.before(e); break } } return null != r && (_r(e, ct.create(e.state.doc, r), "pointer"), !0) }(e, n) : function (e, t) { if (-1 == t) return !1; let n = e.state.doc.resolve(t), r = n.nodeAfter; return !!(r && r.isAtom && ct.isSelectable(r)) && (_r(e, new ct(n), "pointer"), !0) }(e, n)) } function Jr(e, t, n, r) { return Lr(e, "handleDoubleClickOn", t, n, r) || e.someProp("handleDoubleClick", n => n(e, t, r)) } function jr(e, t, n, r) { return Lr(e, "handleTripleClickOn", t, n, r) || e.someProp("handleTripleClick", n => n(e, t, r)) || function (e, t, n) { if (0 != n.button) return !1; let r = e.state.doc; if (-1 == t) return !!r.inlineContent && (_r(e, at.create(r, 0, r.content.size), "pointer"), !0); let o = r.resolve(t); for (let t = o.depth + 1; t > 0; t--) { let n = t > o.depth ? o.nodeAfter : o.node(t), i = o.before(t); if (n.inlineContent) _r(e, at.create(r, i + 1, i + 1 + n.content.size), "pointer"); else { if (!ct.isSelectable(n)) continue; _r(e, ct.create(r, i), "pointer") } return !0 } }(e, n, r) } function Kr(e) { return eo(e) } Ir.keydown = (e, t) => { let n = t; if (e.input.shiftKey = 16 == n.keyCode || n.shiftKey, !Gr(e, n) && (e.input.lastKeyCode = n.keyCode, e.input.lastKeyCodeTime = Date.now(), !tn || !Gt || 13 != n.keyCode)) if (229 != n.keyCode && e.domObserver.forceFlush(), !Xt || 13 != n.keyCode || n.ctrlKey || n.altKey || n.metaKey) e.someProp("handleKeyDown", t => t(e, n)) || vr(e, n) ? n.preventDefault() : Br(e, "key"); else { let t = Date.now(); e.input.lastIOSEnter = t, e.input.lastIOSEnterFallbackTimeout = setTimeout(() => { e.input.lastIOSEnter == t && (e.someProp("handleKeyDown", t => t(e, Vt(13, "Enter"))), e.input.lastIOSEnter = 0) }, 200) } }, Ir.keyup = (e, t) => { 16 == t.keyCode && (e.input.shiftKey = !1) }, Ir.keypress = (e, t) => { let n = t; if (Gr(e, n) || !n.charCode || n.ctrlKey && !n.altKey || Zt && n.metaKey) return; if (e.someProp("handleKeyPress", t => t(e, n))) return void n.preventDefault(); let r = e.state.selection; if (!(r instanceof at && r.$from.sameParent(r.$to))) { let t = String.fromCharCode(n.charCode), o = () => e.state.tr.insertText(t).scrollIntoView(); /[\r\n]/.test(t) || e.someProp("handleTextInput", n => n(e, r.$from.pos, r.$to.pos, t, o)) || e.dispatch(o()), n.preventDefault() } }; const Hr = Zt ? "metaKey" : "ctrlKey"; Rr.mousedown = (e, t) => { let n = t; e.input.shiftKey = n.shiftKey; let r = Kr(e), o = Date.now(), i = "singleClick"; o - e.input.lastClick.time < 500 && function (e, t) { let n = t.x - e.clientX, r = t.y - e.clientY; return n * n + r * r < 100 }(n, e.input.lastClick) && !n[Hr] && e.input.lastClick.button == n.button && ("singleClick" == e.input.lastClick.type ? i = "doubleClick" : "doubleClick" == e.input.lastClick.type && (i = "tripleClick")), e.input.lastClick = { time: o, x: n.clientX, y: n.clientY, type: i, button: n.button }; let s = e.posAtCoords(qr(n)); s && ("singleClick" == i ? (e.input.mouseDown && e.input.mouseDown.done(), e.input.mouseDown = new Ur(e, s, n, !!r)) : ("doubleClick" == i ? Jr : jr)(e, s.pos, s.inside, n) ? n.preventDefault() : Br(e, "pointer")) }; class Ur { constructor(e, t, n, r) { let o, i; if (this.view = e, this.pos = t, this.event = n, this.flushed = r, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!n[Hr], this.allowDefault = n.shiftKey, t.inside > -1) o = e.state.doc.nodeAt(t.inside), i = t.inside; else { let n = e.state.doc.resolve(t.pos); o = n.parent, i = n.depth ? n.before() : 0 } const s = r ? null : n.target, l = s ? e.docView.nearestDesc(s, !0) : null; this.target = l && 1 == l.dom.nodeType ? l.dom : null; let { selection: a } = e.state; (0 == n.button && o.type.spec.draggable && !1 !== o.type.spec.selectable || a instanceof ct && a.from <= i && a.to > i) && (this.mightDrag = { node: o, pos: i, addAttr: !(!this.target || this.target.draggable), setUneditable: !(!this.target || !Ht || this.target.hasAttribute("contentEditable")) }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => { this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false") }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Br(e, "pointer") } done() { this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => Qn(this.view)), this.view.input.mouseDown = null } up(e) { if (this.done(), !this.view.dom.contains(e.target)) return; let t = this.pos; this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(qr(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Br(this.view, "pointer") : Wr(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : 0 == e.button && (this.flushed || Qt && this.mightDrag && !this.mightDrag.node.isAtom || Gt && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (_r(this.view, ot.near(this.view.state.doc.resolve(t.pos)), "pointer"), e.preventDefault()) : Br(this.view, "pointer") } move(e) { this.updateAllowDefault(e), Br(this.view, "pointer"), 0 == e.buttons && this.done() } updateAllowDefault(e) { !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0) } } function Gr(e, t) { return !!e.composing || !!(Qt && Math.abs(t.timeStamp - e.input.compositionEndedAt) < 500) && (e.input.compositionEndedAt = -2e8, !0) } Rr.touchstart = e => { e.input.lastTouch = Date.now(), Kr(e), Br(e, "pointer") }, Rr.touchmove = e => { e.input.lastTouch = Date.now(), Br(e, "pointer") }, Rr.contextmenu = e => Kr(e); const Yr = tn ? 5e3 : -1; function Qr(e, t) { clearTimeout(e.input.composingTimeout), t > -1 && (e.input.composingTimeout = setTimeout(() => eo(e), t)) } function Xr(e) { for (e.composing && (e.input.composing = !1, e.input.compositionEndedAt = function () { let e = document.createEvent("Event"); return e.initEvent("event", !0, !0), e.timeStamp }()); e.input.compositionNodes.length > 0;)e.input.compositionNodes.pop().markParentsDirty() } function Zr(e) { let t = e.domSelectionRange(); if (!t.focusNode) return null; let n = function (e, t) { for (; ;) { if (3 == e.nodeType && t) return e; if (1 == e.nodeType && t > 0) { if ("false" == e.contentEditable) return null; t = Pt(e = e.childNodes[t - 1]) } else { if (!e.parentNode || Bt(e)) return null; t = Dt(e), e = e.parentNode } } }(t.focusNode, t.focusOffset), r = function (e, t) { for (; ;) { if (3 == e.nodeType && t < e.nodeValue.length) return e; if (1 == e.nodeType && t < e.childNodes.length) { if ("false" == e.contentEditable) return null; e = e.childNodes[t], t = 0 } else { if (!e.parentNode || Bt(e)) return null; t = Dt(e) + 1, e = e.parentNode } } }(t.focusNode, t.focusOffset); if (n && r && n != r) { let t = r.pmViewDesc, o = e.domObserver.lastChangedTextNode; if (n == o || r == o) return o; if (!t || !t.isText(r.nodeValue)) return r; if (e.input.compositionNode == r) { let e = n.pmViewDesc; if (e && e.isText(n.nodeValue)) return r } } return n || r } function eo(e, t = !1) { if (!(tn && e.domObserver.flushingSoon >= 0)) { if (e.domObserver.forceFlush(), Xr(e), t || e.docView && e.docView.dirty) { let n = Gn(e), r = e.state.selection; return n && !n.eq(r) ? e.dispatch(e.state.tr.setSelection(n)) : !e.markCursor && !t || r.$from.node(r.$from.sharedDepth(r.to)).inlineContent ? e.updateState(e.state) : e.dispatch(e.state.tr.deleteSelection()), !0 } return !1 } } Ir.compositionstart = Ir.compositionupdate = e => { if (!e.composing) { e.domObserver.flush(); let { state: t } = e, n = t.selection.$to; if (t.selection instanceof at && (t.storedMarks || !n.textOffset && n.parentOffset && n.nodeBefore.marks.some(e => !1 === e.type.spec.inclusive))) e.markCursor = e.state.storedMarks || n.marks(), eo(e, !0), e.markCursor = null; else if (eo(e, !t.selection.empty), Ht && t.selection.empty && n.parentOffset && !n.textOffset && n.nodeBefore.marks.length) { let t = e.domSelectionRange(); for (let n = t.focusNode, r = t.focusOffset; n && 1 == n.nodeType && 0 != r;) { let t = r < 0 ? n.lastChild : n.childNodes[r - 1]; if (!t) break; if (3 == t.nodeType) { let n = e.domSelection(); n && n.collapse(t, t.nodeValue.length); break } n = t, r = -1 } } e.input.composing = !0 } Qr(e, Yr) }, Ir.compositionend = (e, t) => { e.composing && (e.input.composing = !1, e.input.compositionEndedAt = t.timeStamp, e.input.compositionPendingChanges = e.domObserver.pendingRecords().length ? e.input.compositionID : 0, e.input.compositionNode = null, e.input.compositionPendingChanges && Promise.resolve().then(() => e.domObserver.flush()), e.input.compositionID++, Qr(e, 20)) }; const to = jt && Kt < 15 || Xt && rn < 604; function no(e, t, n, r, o) { let i = kr(e, t, n, r, e.state.selection.$from); if (e.someProp("handlePaste", t => t(e, o, i || h.empty))) return !0; if (!i) return !1; let s = function (e) { return 0 == e.openStart && 0 == e.openEnd && 1 == e.content.childCount ? e.content.firstChild : null }(i), l = s ? e.state.tr.replaceSelectionWith(s, r) : e.state.tr.replaceSelection(i); return e.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0 } function ro(e) { let t = e.getData("text/plain") || e.getData("Text"); if (t) return t; let n = e.getData("text/uri-list"); return n ? n.replace(/\r?\n/g, " ") : "" } Rr.copy = Ir.cut = (e, t) => { let n = t, r = e.state.selection, o = "cut" == n.type; if (r.empty) return; let i = to ? null : n.clipboardData, s = r.content(), { dom: l, text: a } = br(e, s); i ? (n.preventDefault(), i.clearData(), i.setData("text/html", l.innerHTML), i.setData("text/plain", a)) : function (e, t) { if (!e.dom.parentNode) return; let n = e.dom.parentNode.appendChild(document.createElement("div")); n.appendChild(t), n.style.cssText = "position: fixed; left: -10000px; top: 10px"; let r = getSelection(), o = document.createRange(); o.selectNodeContents(t), e.dom.blur(), r.removeAllRanges(), r.addRange(o), setTimeout(() => { n.parentNode && n.parentNode.removeChild(n), e.focus() }, 50) }(e, l), o && e.dispatch(e.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")) }, Ir.paste = (e, t) => { let n = t; if (e.composing && !tn) return; let r = to ? null : n.clipboardData, o = e.input.shiftKey && 45 != e.input.lastKeyCode; r && no(e, ro(r), r.getData("text/html"), o, n) ? n.preventDefault() : function (e, t) { if (!e.dom.parentNode) return; let n = e.input.shiftKey || e.state.selection.$from.parent.type.spec.code, r = e.dom.parentNode.appendChild(document.createElement(n ? "textarea" : "div")); n || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(); let o = e.input.shiftKey && 45 != e.input.lastKeyCode; setTimeout(() => { e.focus(), r.parentNode && r.parentNode.removeChild(r), n ? no(e, r.value, null, o, t) : no(e, r.textContent, r.innerHTML, o, t) }, 50) }(e, n) }; class oo { constructor(e, t, n) { this.slice = e, this.move = t, this.node = n } } const io = Zt ? "altKey" : "ctrlKey"; function so(e, t) { let n = e.someProp("dragCopies", e => !e(t)); return null != n ? n : !t[io] } Rr.dragstart = (e, t) => { let n = t, r = e.input.mouseDown; if (r && r.done(), !n.dataTransfer) return; let o, i = e.state.selection, s = i.empty ? null : e.posAtCoords(qr(n)); if (s && s.pos >= i.from && s.pos <= (i instanceof ct ? i.to - 1 : i.to)); else if (r && r.mightDrag) o = ct.create(e.state.doc, r.mightDrag.pos); else if (n.target && 1 == n.target.nodeType) { let t = e.docView.nearestDesc(n.target, !0); t && t.node.type.spec.draggable && t != e.docView && (o = ct.create(e.state.doc, t.posBefore)) } let l = (o || e.state.selection).content(), { dom: a, text: h, slice: c } = br(e, l); (!n.dataTransfer.files.length || !Gt || Yt > 120) && n.dataTransfer.clearData(), n.dataTransfer.setData(to ? "Text" : "text/html", a.innerHTML), n.dataTransfer.effectAllowed = "copyMove", to || n.dataTransfer.setData("text/plain", h), e.dragging = new oo(c, so(e, n), o) }, Rr.dragend = e => { let t = e.dragging; window.setTimeout(() => { e.dragging == t && (e.dragging = null) }, 50) }, Ir.dragover = Ir.dragenter = (e, t) => t.preventDefault(), Ir.drop = (e, t) => { let n = t, r = e.dragging; if (e.dragging = null, !n.dataTransfer) return; let o = e.posAtCoords(qr(n)); if (!o) return; let i = e.state.doc.resolve(o.pos), s = r && r.slice; s ? e.someProp("transformPasted", t => { s = t(s, e) }) : s = kr(e, ro(n.dataTransfer), to ? null : n.dataTransfer.getData("text/html"), !1, i); let l = !(!r || !so(e, n)); if (e.someProp("handleDrop", t => t(e, n, s || h.empty, l))) return void n.preventDefault(); if (!s) return; n.preventDefault(); let a = s ? qe(e.state.doc, i.pos, s) : i.pos; null == a && (a = i.pos); let c = e.state.tr; if (l) { let { node: e } = r; e ? e.replace(c) : c.deleteSelection() } let d = c.mapping.map(a), p = 0 == s.openStart && 0 == s.openEnd && 1 == s.content.childCount, u = c.doc; if (p ? c.replaceRangeWith(d, d, s.content.firstChild) : c.replaceRange(d, d, s), c.doc.eq(u)) return; let f = c.doc.resolve(d); if (p && ct.isSelectable(s.content.firstChild) && f.nodeAfter && f.nodeAfter.sameMarkup(s.content.firstChild)) c.setSelection(new ct(f)); else { let t = c.mapping.map(a); c.mapping.maps[c.mapping.maps.length - 1].forEach((e, n, r, o) => t = o), c.setSelection(or(e, f, c.doc.resolve(t))) } e.focus(), e.dispatch(c.setMeta("uiEvent", "drop")) }, Rr.focus = e => { e.input.lastFocus = Date.now(), e.focused || (e.domObserver.stop(), e.dom.classList.add("ProseMirror-focused"), e.domObserver.start(), e.focused = !0, setTimeout(() => { e.docView && e.hasFocus() && !e.domObserver.currentSelection.eq(e.domSelectionRange()) && Qn(e) }, 20)) }, Rr.blur = (e, t) => { let n = t; e.focused && (e.domObserver.stop(), e.dom.classList.remove("ProseMirror-focused"), e.domObserver.start(), n.relatedTarget && e.dom.contains(n.relatedTarget) && e.domObserver.currentSelection.clear(), e.focused = !1) }, Rr.beforeinput = (e, t) => { if (Gt && tn && "deleteContentBackward" == t.inputType) { e.domObserver.flushSoon(); let { domChangeCount: t } = e.input; setTimeout(() => { if (e.input.domChangeCount != t) return; if (e.dom.blur(), e.focus(), e.someProp("handleKeyDown", t => t(e, Vt(8, "Backspace")))) return; let { $cursor: n } = e.state.selection; n && n.pos > 0 && e.dispatch(e.state.tr.delete(n.pos - 1, n.pos).scrollIntoView()) }, 50) } }; for (let e in Ir) Rr[e] = Ir[e]; function lo(e, t) { if (e == t) return !0; for (let n in e) if (e[n] !== t[n]) return !1; for (let n in t) if (!(n in e)) return !1; return !0 } class ao { constructor(e, t) { this.toDOM = e, this.spec = t || fo, this.side = this.spec.side || 0 } map(e, t, n, r) { let { pos: o, deleted: i } = e.mapResult(t.from + r, this.side < 0 ? -1 : 1); return i ? null : new po(o - n, o - n, this) } valid() { return !0 } eq(e) { return this == e || e instanceof ao && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && lo(this.spec, e.spec)) } destroy(e) { this.spec.destroy && this.spec.destroy(e) } } class ho { constructor(e, t) { this.attrs = e, this.spec = t || fo } map(e, t, n, r) { let o = e.map(t.from + r, this.spec.inclusiveStart ? -1 : 1) - n, i = e.map(t.to + r, this.spec.inclusiveEnd ? 1 : -1) - n; return o >= i ? null : new po(o, i, this) } valid(e, t) { return t.from < t.to } eq(e) { return this == e || e instanceof ho && lo(this.attrs, e.attrs) && lo(this.spec, e.spec) } static is(e) { return e.type instanceof ho } destroy() { } } class co { constructor(e, t) { this.attrs = e, this.spec = t || fo } map(e, t, n, r) { let o = e.mapResult(t.from + r, 1); if (o.deleted) return null; let i = e.mapResult(t.to + r, -1); return i.deleted || i.pos <= o.pos ? null : new po(o.pos - n, i.pos - n, this) } valid(e, t) { let n, { index: r, offset: o } = e.content.findIndex(t.from); return o == t.from && !(n = e.child(r)).isText && o + n.nodeSize == t.to } eq(e) { return this == e || e instanceof co && lo(this.attrs, e.attrs) && lo(this.spec, e.spec) } destroy() { } } class po { constructor(e, t, n) { this.from = e, this.to = t, this.type = n } copy(e, t) { return new po(e, t, this.type) } eq(e, t = 0) { return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to } map(e, t, n) { return this.type.map(e, this, t, n) } static widget(e, t, n) { return new po(e, e, new ao(t, n)) } static inline(e, t, n, r) { return new po(e, t, new ho(n, r)) } static node(e, t, n, r) { return new po(e, t, new co(n, r)) } get spec() { return this.type.spec } get inline() { return this.type instanceof ho } get widget() { return this.type instanceof ao } } const uo = [], fo = {}; class mo { constructor(e, t) { this.local = e.length ? e : uo, this.children = t.length ? t : uo } static create(e, t) { return t.length ? ko(t, e, 0, fo) : go } find(e, t, n) { let r = []; return this.findInner(null == e ? 0 : e, null == t ? 1e9 : t, r, 0, n), r } findInner(e, t, n, r, o) { for (let i = 0; i < this.local.length; i++) { let s = this.local[i]; s.from <= t && s.to >= e && (!o || o(s.spec)) && n.push(s.copy(s.from + r, s.to + r)) } for (let i = 0; i < this.children.length; i += 3)if (this.children[i] < t && this.children[i + 1] > e) { let s = this.children[i] + 1; this.children[i + 2].findInner(e - s, t - s, n, r + s, o) } } map(e, t, n) { return this == go || 0 == e.maps.length ? this : this.mapInner(e, t, 0, 0, n || fo) } mapInner(e, t, n, r, o) { let i; for (let s = 0; s < this.local.length; s++) { let l = this.local[s].map(e, n, r); l && l.type.valid(t, l) ? (i || (i = [])).push(l) : o.onRemove && o.onRemove(this.local[s].spec) } return this.children.length ? function (e, t, n, r, o, i, s) { let l = e.slice(); for (let e = 0, t = i; e < n.maps.length; e++) { let r = 0; n.maps[e].forEach((e, n, o, i) => { let s = i - o - (n - e); for (let o = 0; o < l.length; o += 3) { let i = l[o + 1]; if (i < 0 || e > i + t - r) continue; let a = l[o] + t - r; n >= a ? l[o + 1] = e <= a ? -2 : -1 : e >= t && s && (l[o] += s, l[o + 1] += s) } r += s }), t = n.maps[e].map(t, -1) } let a = !1; for (let t = 0; t < l.length; t += 3)if (l[t + 1] < 0) { if (-2 == l[t + 1]) { a = !0, l[t + 1] = -1; continue } let h = n.map(e[t] + i), c = h - o; if (c < 0 || c >= r.content.size) { a = !0; continue } let d = n.map(e[t + 1] + i, -1) - o, { index: p, offset: u } = r.content.findIndex(c), f = r.maybeChild(p); if (f && u == c && u + f.nodeSize == d) { let r = l[t + 2].mapInner(n, f, h + 1, e[t] + i + 1, s); r != go ? (l[t] = c, l[t + 1] = d, l[t + 2] = r) : (l[t + 1] = -2, a = !0) } else a = !0 } if (a) { let a = function (e, t, n, r, o, i, s) { function l(e, t) { for (let i = 0; i < e.local.length; i++) { let l = e.local[i].map(r, o, t); l ? n.push(l) : s.onRemove && s.onRemove(e.local[i].spec) } for (let n = 0; n < e.children.length; n += 3)l(e.children[n + 2], e.children[n] + t + 1) } for (let n = 0; n < e.length; n += 3)-1 == e[n + 1] && l(e[n + 2], t[n] + i + 1); return n }(l, e, t, n, o, i, s), h = ko(a, r, 0, s); t = h.local; for (let e = 0; e < l.length; e += 3)l[e + 1] < 0 && (l.splice(e, 3), e -= 3); for (let e = 0, t = 0; e < h.children.length; e += 3) { let n = h.children[e]; for (; t < l.length && l[t] < n;)t += 3; l.splice(t, 0, h.children[e], h.children[e + 1], h.children[e + 2]) } } return new mo(t.sort(xo), l) }(this.children, i || [], e, t, n, r, o) : i ? new mo(i.sort(xo), uo) : go } add(e, t) { return t.length ? this == go ? mo.create(e, t) : this.addInner(e, t, 0) : this } addInner(e, t, n) { let r, o = 0; e.forEach((e, i) => { let s, l = i + n; if (s = vo(t, e, l)) { for (r || (r = this.children.slice()); o < r.length && r[o] < i;)o += 3; r[o] == i ? r[o + 2] = r[o + 2].addInner(e, s, l + 1) : r.splice(o, 0, i, i + e.nodeSize, ko(s, e, l + 1, fo)), o += 3 } }); let i = wo(o ? bo(t) : t, -n); for (let t = 0; t < i.length; t++)i[t].type.valid(e, i[t]) || i.splice(t--, 1); return new mo(i.length ? this.local.concat(i).sort(xo) : this.local, r || this.children) } remove(e) { return 0 == e.length || this == go ? this : this.removeInner(e, 0) } removeInner(e, t) { let n = this.children, r = this.local; for (let r = 0; r < n.length; r += 3) { let o, i = n[r] + t, s = n[r + 1] + t; for (let t, n = 0; n < e.length; n++)(t = e[n]) && t.from > i && t.to < s && (e[n] = null, (o || (o = [])).push(t)); if (!o) continue; n == this.children && (n = this.children.slice()); let l = n[r + 2].removeInner(o, i + 1); l != go ? n[r + 2] = l : (n.splice(r, 3), r -= 3) } if (r.length) for (let n, o = 0; o < e.length; o++)if (n = e[o]) for (let e = 0; e < r.length; e++)r[e].eq(n, t) && (r == this.local && (r = this.local.slice()), r.splice(e--, 1)); return n == this.children && r == this.local ? this : r.length || n.length ? new mo(r, n) : go } forChild(e, t) { if (this == go) return this; if (t.isLeaf) return mo.empty; let n, r; for (let t = 0; t < this.children.length; t += 3)if (this.children[t] >= e) { this.children[t] == e && (n = this.children[t + 2]); break } let o = e + 1, i = o + t.content.size; for (let e = 0; e < this.local.length; e++) { let t = this.local[e]; if (t.from < i && t.to > o && t.type instanceof ho) { let e = Math.max(o, t.from) - o, n = Math.min(i, t.to) - o; e < n && (r || (r = [])).push(t.copy(e, n)) } } if (r) { let e = new mo(r.sort(xo), uo); return n ? new yo([e, n]) : e } return n || go } eq(e) { if (this == e) return !0; if (!(e instanceof mo) || this.local.length != e.local.length || this.children.length != e.children.length) return !1; for (let t = 0; t < this.local.length; t++)if (!this.local[t].eq(e.local[t])) return !1; for (let t = 0; t < this.children.length; t += 3)if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2])) return !1; return !0 } locals(e) { return So(this.localsInner(e)) } localsInner(e) { if (this == go) return uo; if (e.inlineContent || !this.local.some(ho.is)) return this.local; let t = []; for (let e = 0; e < this.local.length; e++)this.local[e].type instanceof ho || t.push(this.local[e]); return t } forEachSet(e) { e(this) } } mo.empty = new mo([], []), mo.removeOverlap = So; const go = mo.empty; class yo { constructor(e) { this.members = e } map(e, t) { const n = this.members.map(n => n.map(e, t, fo)); return yo.from(n) } forChild(e, t) { if (t.isLeaf) return mo.empty; let n = []; for (let r = 0; r < this.members.length; r++) { let o = this.members[r].forChild(e, t); o != go && (o instanceof yo ? n = n.concat(o.members) : n.push(o)) } return yo.from(n) } eq(e) { if (!(e instanceof yo) || e.members.length != this.members.length) return !1; for (let t = 0; t < this.members.length; t++)if (!this.members[t].eq(e.members[t])) return !1; return !0 } locals(e) { let t, n = !0; for (let r = 0; r < this.members.length; r++) { let o = this.members[r].localsInner(e); if (o.length) if (t) { n && (t = t.slice(), n = !1); for (let e = 0; e < o.length; e++)t.push(o[e]) } else t = o } return t ? So(n ? t : t.sort(xo)) : uo } static from(e) { switch (e.length) { case 0: return go; case 1: return e[0]; default: return new yo(e.every(e => e instanceof mo) ? e : e.reduce((e, t) => e.concat(t instanceof mo ? t : t.members), [])) } } forEachSet(e) { for (let t = 0; t < this.members.length; t++)this.members[t].forEachSet(e) } } function wo(e, t) { if (!t || !e.length) return e; let n = []; for (let r = 0; r < e.length; r++) { let o = e[r]; n.push(new po(o.from + t, o.to + t, o.type)) } return n } function vo(e, t, n) { if (t.isLeaf) return null; let r = n + t.nodeSize, o = null; for (let t, i = 0; i < e.length; i++)(t = e[i]) && t.from > n && t.to < r && ((o || (o = [])).push(t), e[i] = null); return o } function bo(e) { let t = []; for (let n = 0; n < e.length; n++)null != e[n] && t.push(e[n]); return t } function ko(e, t, n, r) { let o = [], i = !1; t.forEach((t, s) => { let l = vo(e, t, s + n); if (l) { i = !0; let e = ko(l, t, n + s + 1, r); e != go && o.push(s, s + t.nodeSize, e) } }); let s = wo(i ? bo(e) : e, -n).sort(xo); for (let e = 0; e < s.length; e++)s[e].type.valid(t, s[e]) || (r.onRemove && r.onRemove(s[e].spec), s.splice(e--, 1)); return s.length || o.length ? new mo(s, o) : go } function xo(e, t) { return e.from - t.from || e.to - t.to } function So(e) { let t = e; for (let n = 0; n < t.length - 1; n++) { let r = t[n]; if (r.from != r.to) for (let o = n + 1; o < t.length; o++) { let i = t[o]; if (i.from != r.from) { i.from < r.to && (t == e && (t = e.slice()), t[n] = r.copy(r.from, i.from), Co(t, o, r.copy(i.from, r.to))); break } i.to != r.to && (t == e && (t = e.slice()), t[o] = i.copy(i.from, r.to), Co(t, o + 1, i.copy(r.to, i.to))) } } return t } function Co(e, t, n) { for (; t < e.length && xo(n, e[t]) > 0;)t++; e.splice(t, 0, n) } function Mo(e) { let t = []; return e.someProp("decorations", n => { let r = n(e.state); r && r != go && t.push(r) }), e.cursorWrapper && t.push(mo.create(e.state.doc, [e.cursorWrapper.deco])), yo.from(t) } const Oo = { childList: !0, characterData: !0, characterDataOldValue: !0, attributes: !0, attributeOldValue: !0, subtree: !0 }, No = jt && Kt <= 11; class Do { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } set(e) { this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset } clear() { this.anchorNode = this.focusNode = null } eq(e) { return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset } } class To { constructor(e, t) { this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new Do, this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver(e => { for (let t = 0; t < e.length; t++)this.queue.push(e[t]); jt && Kt <= 11 && e.some(e => "childList" == e.type && e.removedNodes.length || "characterData" == e.type && e.oldValue.length > e.target.nodeValue.length) ? this.flushSoon() : this.flush() }), No && (this.onCharData = e => { this.queue.push({ target: e.target, type: "characterData", oldValue: e.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this) } flushSoon() { this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1, this.flush() }, 20)) } forceFlush() { this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush()) } start() { this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, Oo)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection() } stop() { if (this.observer) { let e = this.observer.takeRecords(); if (e.length) { for (let t = 0; t < e.length; t++)this.queue.push(e[t]); window.setTimeout(() => this.flush(), 20) } this.observer.disconnect() } this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection() } connectSelection() { this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange) } disconnectSelection() { this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange) } suppressSelectionUpdates() { this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50) } onSelectionChange() { if (ir(this.view)) { if (this.suppressingSelectionUpdates) return Qn(this.view); if (jt && Kt <= 11 && !this.view.state.selection.empty) { let e = this.view.domSelectionRange(); if (e.focusNode && Rt(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon() } this.flush() } } setCurSelection() { this.currentSelection.set(this.view.domSelectionRange()) } ignoreSelectionChange(e) { if (!e.focusNode) return !0; let t, n = new Set; for (let t = e.focusNode; t; t = Tt(t))n.add(t); for (let r = e.anchorNode; r; r = Tt(r))if (n.has(r)) { t = r; break } let r = t && this.view.docView.nearestDesc(t); return r && r.ignoreMutation({ type: "selection", target: 3 == t.nodeType ? t.parentNode : t }) ? (this.setCurSelection(), !0) : void 0 } pendingRecords() { if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e); return this.queue } flush() { let { view: e } = this; if (!e.docView || this.flushingSoon > -1) return; let t = this.pendingRecords(); t.length && (this.queue = []); let n = e.domSelectionRange(), r = !this.suppressingSelectionUpdates && !this.currentSelection.eq(n) && ir(e) && !this.ignoreSelectionChange(n), o = -1, i = -1, s = !1, l = []; if (e.editable) for (let e = 0; e < t.length; e++) { let n = this.registerMutation(t[e], l); n && (o = o < 0 ? n.from : Math.min(n.from, o), i = i < 0 ? n.to : Math.max(n.to, i), n.typeOver && (s = !0)) } if (Ht && l.length) { let t = l.filter(e => "BR" == e.nodeName); if (2 == t.length) { let [e, n] = t; e.parentNode && e.parentNode.parentNode == n.parentNode ? n.remove() : e.remove() } else { let { focusNode: n } = this.currentSelection; for (let r of t) { let t = r.parentNode; !t || "LI" != t.nodeName || n && Io(e, n) == t || r.remove() } } } let a = null; o < 0 && r && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && $t(n) && (a = Gn(e)) && a.eq(ot.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, Qn(e), this.currentSelection.set(n), e.scrollToSelection()) : (o > -1 || r) && (o > -1 && (e.docView.markDirty(o, i), function (e) { if (Eo.has(e)) return; if (Eo.set(e, null), -1 !== ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(e.dom).whiteSpace)) { if (e.requiresGeckoHackNode = Ht, Ao) return; console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Ao = !0 } }(e)), this.handleDOMChange(o, i, s, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(n) || Qn(e), this.currentSelection.set(n)) } registerMutation(e, t) { if (t.indexOf(e.target) > -1) return null; let n = this.view.docView.nearestDesc(e.target); if ("attributes" == e.type && (n == this.view.docView || "contenteditable" == e.attributeName || "style" == e.attributeName && !e.oldValue && !e.target.getAttribute("style"))) return null; if (!n || n.ignoreMutation(e)) return null; if ("childList" == e.type) { for (let n = 0; n < e.addedNodes.length; n++) { let r = e.addedNodes[n]; t.push(r), 3 == r.nodeType && (this.lastChangedTextNode = r) } if (n.contentDOM && n.contentDOM != n.dom && !n.contentDOM.contains(e.target)) return { from: n.posBefore, to: n.posAfter }; let r = e.previousSibling, o = e.nextSibling; if (jt && Kt <= 11 && e.addedNodes.length) for (let t = 0; t < e.addedNodes.length; t++) { let { previousSibling: n, nextSibling: i } = e.addedNodes[t]; (!n || Array.prototype.indexOf.call(e.addedNodes, n) < 0) && (r = n), (!i || Array.prototype.indexOf.call(e.addedNodes, i) < 0) && (o = i) } let i = r && r.parentNode == e.target ? Dt(r) + 1 : 0, s = n.localPosFromDOM(e.target, i, -1), l = o && o.parentNode == e.target ? Dt(o) : e.target.childNodes.length; return { from: s, to: n.localPosFromDOM(e.target, l, 1) } } return "attributes" == e.type ? { from: n.posAtStart - n.border, to: n.posAtEnd + n.border } : (this.lastChangedTextNode = e.target, { from: n.posAtStart, to: n.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }) } } let Eo = new WeakMap, Ao = !1; function Ro(e, t) { let n = t.startContainer, r = t.startOffset, o = t.endContainer, i = t.endOffset, s = e.domAtPos(e.state.selection.anchor); return Rt(s.node, s.offset, o, i) && ([n, r, o, i] = [o, i, n, r]), { anchorNode: n, anchorOffset: r, focusNode: o, focusOffset: i } } function Io(e, t) { for (let n = t.parentNode; n && n != e.dom; n = n.parentNode) { let t = e.docView.nearestDesc(n, !0); if (t && t.node.isBlock) return n } return null } function zo(e) { let t = e.pmViewDesc; if (t) return t.parseRule(); if ("BR" == e.nodeName && e.parentNode) { if (Qt && /^(ul|ol)$/i.test(e.parentNode.nodeName)) { let e = document.createElement("div"); return e.appendChild(document.createElement("li")), { skip: e } } if (e.parentNode.lastChild == e || Qt && /^(tr|table)$/i.test(e.parentNode.nodeName)) return { ignore: !0 } } else if ("IMG" == e.nodeName && e.getAttribute("mark-placeholder")) return { ignore: !0 }; return null } const Po = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|img|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i; function Bo(e, t, n, o, i) { let s = e.input.compositionPendingChanges || (e.composing ? e.input.compositionID : 0); if (e.input.compositionPendingChanges = 0, t < 0) { let t = e.input.lastSelectionTime > Date.now() - 50 ? e.input.lastSelectionOrigin : null, n = Gn(e, t); if (n && !e.state.selection.eq(n)) { if (Gt && tn && 13 === e.input.lastKeyCode && Date.now() - 100 < e.input.lastKeyCodeTime && e.someProp("handleKeyDown", t => t(e, Vt(13, "Enter")))) return; let r = e.state.tr.setSelection(n); "pointer" == t ? r.setMeta("pointer", !0) : "key" == t && r.scrollIntoView(), s && r.setMeta("composition", s), e.dispatch(r) } return } let l = e.state.doc.resolve(t), a = l.sharedDepth(n); t = l.before(a + 1), n = e.state.doc.resolve(n).after(a + 1); let h, c, d = e.state.selection, p = function (e, t, n) { let r, { node: o, fromOffset: i, toOffset: s, from: l, to: a } = e.docView.parseRange(t, n), h = e.domSelectionRange(), c = h.anchorNode; if (c && e.dom.contains(1 == c.nodeType ? c : c.parentNode) && (r = [{ node: c, offset: h.anchorOffset }], $t(h) || r.push({ node: h.focusNode, offset: h.focusOffset })), Gt && 8 === e.input.lastKeyCode) for (let e = s; e > i; e--) { let t = o.childNodes[e - 1], n = t.pmViewDesc; if ("BR" == t.nodeName && !n) { s = e; break } if (!n || n.size) break } let d = e.state.doc, p = e.someProp("domParser") || U.fromSchema(e.state.schema), u = d.resolve(l), f = null, m = p.parse(o, { topNode: u.parent, topMatch: u.parent.contentMatchAt(u.index()), topOpen: !0, from: i, to: s, preserveWhitespace: "pre" != u.parent.type.whitespace || "full", findPositions: r, ruleFromNode: zo, context: u }); if (r && null != r[0].pos) { let e = r[0].pos, t = r[1] && r[1].pos; null == t && (t = e), f = { anchor: e + l, head: t + l } } return { doc: m, sel: f, from: l, to: a } }(e, t, n), u = e.state.doc, f = u.slice(p.from, p.to); 8 === e.input.lastKeyCode && Date.now() - 100 < e.input.lastKeyCodeTime ? (h = e.state.selection.to, c = "end") : (h = e.state.selection.from, c = "start"), e.input.lastKeyCode = null; let m = function (e, t, n, r, o) { let i = e.findDiffStart(t, n); if (null == i) return null; let { a: s, b: l } = e.findDiffEnd(t, n + e.size, n + t.size); if ("end" == o) { r -= s + Math.max(0, i - Math.min(s, l)) - i } if (s < i && e.size < t.size) { let e = r <= i && r >= s ? i - r : 0; i -= e, i && i < t.size && Fo(t.textBetween(i - 1, i + 1)) && (i += e ? 1 : -1), l = i + (l - s), s = i } else if (l < i) { let t = r <= i && r >= l ? i - r : 0; i -= t, i && i < e.size && Fo(e.textBetween(i - 1, i + 1)) && (i += t ? 1 : -1), s = i + (s - l), l = i } return { start: i, endA: s, endB: l } }(f.content, p.doc.content, p.from, h, c); if (m && e.input.domChangeCount++, (Xt && e.input.lastIOSEnter > Date.now() - 225 || tn) && i.some(e => 1 == e.nodeType && !Po.test(e.nodeName)) && (!m || m.endA >= m.endB) && e.someProp("handleKeyDown", t => t(e, Vt(13, "Enter")))) return void (e.input.lastIOSEnter = 0); if (!m) { if (!(o && d instanceof at && !d.empty && d.$head.sameParent(d.$anchor)) || e.composing || p.sel && p.sel.anchor != p.sel.head) { if (p.sel) { let t = $o(e, e.state.doc, p.sel); if (t && !t.eq(e.state.selection)) { let n = e.state.tr.setSelection(t); s && n.setMeta("composition", s), e.dispatch(n) } } return } m = { start: d.from, endA: d.to, endB: d.to } } e.state.selection.from < e.state.selection.to && m.start == m.endB && e.state.selection instanceof at && (m.start > e.state.selection.from && m.start <= e.state.selection.from + 2 && e.state.selection.from >= p.from ? m.start = e.state.selection.from : m.endA < e.state.selection.to && m.endA >= e.state.selection.to - 2 && e.state.selection.to <= p.to && (m.endB += e.state.selection.to - m.endA, m.endA = e.state.selection.to)), jt && Kt <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > p.from && "  " == p.doc.textBetween(m.start - p.from - 1, m.start - p.from + 1) && (m.start--, m.endA--, m.endB--); let g, y = p.doc.resolveNoCache(m.start - p.from), w = p.doc.resolveNoCache(m.endB - p.from), v = u.resolve(m.start), b = y.sameParent(w) && y.parent.inlineContent && v.end() >= m.endA; if ((Xt && e.input.lastIOSEnter > Date.now() - 225 && (!b || i.some(e => "DIV" == e.nodeName || "P" == e.nodeName)) || !b && y.pos < p.doc.content.size && (!y.sameParent(w) || !y.parent.inlineContent) && !/\S/.test(p.doc.textBetween(y.pos, w.pos, "", "")) && (g = ot.findFrom(p.doc.resolve(y.pos + 1), 1, !0)) && g.head > y.pos) && e.someProp("handleKeyDown", t => t(e, Vt(13, "Enter")))) return void (e.input.lastIOSEnter = 0); if (e.state.selection.anchor > m.start && function (e, t, n, r, o) { if (n - t <= o.pos - r.pos || Vo(r, !0, !1) < o.pos) return !1; let i = e.resolve(t); if (!r.parent.isTextblock) { let e = i.nodeAfter; return null != e && n == t + e.nodeSize } if (i.parentOffset < i.parent.content.size || !i.parent.isTextblock) return !1; let s = e.resolve(Vo(i, !0, !0)); return !(!s.parent.isTextblock || s.pos > n || Vo(s, !0, !1) < n) && r.parent.content.cut(r.parentOffset).eq(s.parent.content) }(u, m.start, m.endA, y, w) && e.someProp("handleKeyDown", t => t(e, Vt(8, "Backspace")))) return void (tn && Gt && e.domObserver.suppressSelectionUpdates()); Gt && m.endB == m.start && (e.input.lastChromeDelete = Date.now()), tn && !b && y.start() != w.start() && 0 == w.parentOffset && y.depth == w.depth && p.sel && p.sel.anchor == p.sel.head && p.sel.head == m.endA && (m.endB -= 2, w = p.doc.resolveNoCache(m.endB - p.from), setTimeout(() => { e.someProp("handleKeyDown", function (t) { return t(e, Vt(13, "Enter")) }) }, 20)); let k, x = m.start, S = m.endA, C = t => { let n = t || e.state.tr.replace(x, S, p.doc.slice(m.start - p.from, m.endB - p.from)); if (p.sel) { let t = $o(e, n.doc, p.sel); t && !(Gt && e.composing && t.empty && (m.start != m.endB || e.input.lastChromeDelete < Date.now() - 100) && (t.head == x || t.head == n.mapping.map(S) - 1) || jt && t.empty && t.head == x) && n.setSelection(t) } return s && n.setMeta("composition", s), n.scrollIntoView() }; if (b) { if (y.pos == w.pos) { jt && Kt <= 11 && 0 == y.parentOffset && (e.domObserver.suppressSelectionUpdates(), setTimeout(() => Qn(e), 20)); let t = C(e.state.tr.delete(x, S)), n = u.resolve(m.start).marksAcross(u.resolve(m.endA)); n && t.ensureMarks(n), e.dispatch(t) } else if (m.endA == m.endB && (k = function (e, t) { let n, o, i, s = e.firstChild.marks, l = t.firstChild.marks, a = s, h = l; for (let e = 0; e < l.length; e++)a = l[e].removeFromSet(a); for (let e = 0; e < s.length; e++)h = s[e].removeFromSet(h); if (1 == a.length && 0 == h.length) o = a[0], n = "add", i = e => e.mark(o.addToSet(e.marks)); else { if (0 != a.length || 1 != h.length) return null; o = h[0], n = "remove", i = e => e.mark(o.removeFromSet(e.marks)) } let c = []; for (let e = 0; e < t.childCount; e++)c.push(i(t.child(e))); if (r.from(c).eq(e)) return { mark: o, type: n } }(y.parent.content.cut(y.parentOffset, w.parentOffset), v.parent.content.cut(v.parentOffset, m.endA - v.start())))) { let t = C(e.state.tr); "add" == k.type ? t.addMark(x, S, k.mark) : t.removeMark(x, S, k.mark), e.dispatch(t) } else if (y.parent.child(y.index()).isText && y.index() == w.index() - (w.textOffset ? 0 : 1)) { let t = y.parent.textBetween(y.parentOffset, w.parentOffset), n = () => C(e.state.tr.insertText(t, x, S)); e.someProp("handleTextInput", r => r(e, x, S, t, n)) || e.dispatch(n()) } } else e.dispatch(C()) } function $o(e, t, n) { return Math.max(n.anchor, n.head) > t.content.size ? null : or(e, t.resolve(n.anchor), t.resolve(n.head)) } function Vo(e, t, n) { let r = e.depth, o = t ? e.end() : e.pos; for (; r > 0 && (t || e.indexAfter(r) == e.node(r).childCount);)r--, o++, t = !1; if (n) { let t = e.node(r).maybeChild(e.indexAfter(r)); for (; t && !t.isLeaf;)t = t.firstChild, o++ } return o } function Fo(e) { if (2 != e.length) return !1; let t = e.charCodeAt(0), n = e.charCodeAt(1); return t >= 56320 && t <= 57343 && n >= 55296 && n <= 56319 } const qo = kr, Lo = eo; class _o { constructor(e, t) { this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new Pr, this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(Ho), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : "function" == typeof e ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = jo(this), Jo(this), this.nodeViews = Ko(this), this.docView = In(this.state.doc, Wo(this), Mo(this), this.dom, this), this.domObserver = new To(this, (e, t, n, r) => Bo(this, e, t, n, r)), this.domObserver.start(), function (e) { for (let t in Rr) { let n = Rr[t]; e.dom.addEventListener(t, e.input.eventHandlers[t] = t => { !Fr(e, t) || Vr(e, t) || !e.editable && t.type in Ir || n(e, t) }, zr[t] ? { passive: !0 } : void 0) } Qt && e.dom.addEventListener("input", () => null), $r(e) }(this), this.updatePluginViews() } get composing() { return this.input.composing } get props() { if (this._props.state != this.state) { let e = this._props; this._props = {}; for (let t in e) this._props[t] = e[t]; this._props.state = this.state } return this._props } update(e) { e.handleDOMEvents != this._props.handleDOMEvents && $r(this); let t = this._props; this._props = e, e.plugins && (e.plugins.forEach(Ho), this.directPlugins = e.plugins), this.updateStateInner(e.state, t) } setProps(e) { let t = {}; for (let e in this._props) t[e] = this._props[e]; t.state = this.state; for (let n in e) t[n] = e[n]; this.update(t) } updateState(e) { this.updateStateInner(e, this._props) } updateStateInner(e, t) { var n; let r = this.state, o = !1, i = !1; e.storedMarks && this.composing && (Xr(this), i = !0), this.state = e; let s = r.plugins != e.plugins || this._props.plugins != t.plugins; if (s || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) { let e = Ko(this); (function (e, t) { let n = 0, r = 0; for (let r in e) { if (e[r] != t[r]) return !0; n++ } for (let e in t) r++; return n != r })(e, this.nodeViews) && (this.nodeViews = e, o = !0) } (s || t.handleDOMEvents != this._props.handleDOMEvents) && $r(this), this.editable = jo(this), Jo(this); let l = Mo(this), a = Wo(this), h = r.plugins == e.plugins || r.doc.eq(e.doc) ? e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve" : "reset", c = o || !this.docView.matchesNode(e.doc, a, l); !c && e.selection.eq(r.selection) || (i = !0); let d = "preserve" == h && i && null == this.dom.style.overflowAnchor && function (e) { let t, n, r = e.dom.getBoundingClientRect(), o = Math.max(0, r.top); for (let i = (r.left + r.right) / 2, s = o + 1; s < Math.min(innerHeight, r.bottom); s += 5) { let r = e.root.elementFromPoint(i, s); if (!r || r == e.dom || !e.dom.contains(r)) continue; let l = r.getBoundingClientRect(); if (l.top >= o - 20) { t = r, n = l.top; break } } return { refDOM: t, refTop: n, stack: hn(e.dom) } }(this); if (i) { this.domObserver.stop(); let t = c && (jt || Gt) && !this.composing && !r.selection.empty && !e.selection.empty && function (e, t) { let n = Math.min(e.$anchor.sharedDepth(e.head), t.$anchor.sharedDepth(t.head)); return e.$anchor.start(n) != t.$anchor.start(n) }(r.selection, e.selection); if (c) { let n = Gt ? this.trackWrites = this.domSelectionRange().focusNode : null; this.composing && (this.input.compositionNode = Zr(this)), !o && this.docView.update(e.doc, a, l, this) || (this.docView.updateOuterDeco(a), this.docView.destroy(), this.docView = In(e.doc, a, l, this.dom, this)), n && !this.trackWrites && (t = !0) } t || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && function (e) { let t = e.docView.domFromPos(e.state.selection.anchor, 0), n = e.domSelectionRange(); return Rt(t.node, t.offset, n.anchorNode, n.anchorOffset) }(this)) ? Qn(this, t) : (nr(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start() } this.updatePluginViews(r), (null === (n = this.dragging) || void 0 === n ? void 0 : n.node) && !r.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, r), "reset" == h ? this.dom.scrollTop = 0 : "to selection" == h ? this.scrollToSelection() : d && function ({ refDOM: e, refTop: t, stack: n }) { let r = e ? e.getBoundingClientRect().top : 0; cn(n, 0 == r ? 0 : r - t) }(d) } scrollToSelection() { let e = this.domSelectionRange().focusNode; if (e && this.dom.contains(1 == e.nodeType ? e : e.parentNode)) if (this.someProp("handleScrollToSelection", e => e(this))); else if (this.state.selection instanceof ct) { let t = this.docView.domAfterPos(this.state.selection.from); 1 == t.nodeType && an(this, t.getBoundingClientRect(), e) } else an(this, this.coordsAtPos(this.state.selection.head, 1), e); else; } destroyPluginViews() { let e; for (; e = this.pluginViews.pop();)e.destroy && e.destroy() } updatePluginViews(e) { if (e && e.plugins == this.state.plugins && this.directPlugins == this.prevDirectPlugins) for (let t = 0; t < this.pluginViews.length; t++) { let n = this.pluginViews[t]; n.update && n.update(this, e) } else { this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews(); for (let e = 0; e < this.directPlugins.length; e++) { let t = this.directPlugins[e]; t.spec.view && this.pluginViews.push(t.spec.view(this)) } for (let e = 0; e < this.state.plugins.length; e++) { let t = this.state.plugins[e]; t.spec.view && this.pluginViews.push(t.spec.view(this)) } } } updateDraggedNode(e, t) { let n = e.node, r = -1; if (this.state.doc.nodeAt(n.from) == n.node) r = n.from; else { let e = n.from + (this.state.doc.content.size - t.doc.content.size); (e > 0 && this.state.doc.nodeAt(e)) == n.node && (r = e) } this.dragging = new oo(e.slice, e.move, r < 0 ? void 0 : ct.create(this.state.doc, r)) } someProp(e, t) { let n, r = this._props && this._props[e]; if (null != r && (n = t ? t(r) : r)) return n; for (let r = 0; r < this.directPlugins.length; r++) { let o = this.directPlugins[r].props[e]; if (null != o && (n = t ? t(o) : o)) return n } let o = this.state.plugins; if (o) for (let r = 0; r < o.length; r++) { let i = o[r].props[e]; if (null != i && (n = t ? t(i) : i)) return n } } hasFocus() { if (jt) { let e = this.root.activeElement; if (e == this.dom) return !0; if (!e || !this.dom.contains(e)) return !1; for (; e && this.dom != e && this.dom.contains(e);) { if ("false" == e.contentEditable) return !1; e = e.parentElement } return !0 } return this.root.activeElement == this.dom } focus() { this.domObserver.stop(), this.editable && function (e) { if (e.setActive) return e.setActive(); if (dn) return e.focus(dn); let t = hn(e); e.focus(null == dn ? { get preventScroll() { return dn = { preventScroll: !0 }, !0 } } : void 0), dn || (dn = !1, cn(t, 0)) }(this.dom), Qn(this), this.domObserver.start() } get root() { let e = this._root; if (null == e) for (let e = this.dom.parentNode; e; e = e.parentNode)if (9 == e.nodeType || 11 == e.nodeType && e.host) return e.getSelection || (Object.getPrototypeOf(e).getSelection = () => e.ownerDocument.getSelection()), this._root = e; return e || document } updateRoot() { this._root = null } posAtCoords(e) { return mn(this, e) } coordsAtPos(e, t = 1) { return vn(this, e, t) } domAtPos(e, t = 0) { return this.docView.domFromPos(e, t) } nodeDOM(e) { let t = this.docView.descAt(e); return t ? t.nodeDOM : null } posAtDOM(e, t, n = -1) { let r = this.docView.posFromDOM(e, t, n); if (null == r) throw new RangeError("DOM position not inside the editor"); return r } endOfTextblock(e, t) { return Nn(this, t || this.state, e) } pasteHTML(e, t) { return no(this, "", e, !1, t || new ClipboardEvent("paste")) } pasteText(e, t) { return no(this, e, null, !0, t || new ClipboardEvent("paste")) } serializeForClipboard(e) { return br(this, e) } destroy() { this.docView && (!function (e) { e.domObserver.stop(); for (let t in e.input.eventHandlers) e.dom.removeEventListener(t, e.input.eventHandlers[t]); clearTimeout(e.input.composingTimeout), clearTimeout(e.input.lastIOSEnterFallbackTimeout) }(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Mo(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, Et = null) } get isDestroyed() { return null == this.docView } dispatchEvent(e) { return function (e, t) { Vr(e, t) || !Rr[t.type] || !e.editable && t.type in Ir || Rr[t.type](e, t) }(this, e) } domSelectionRange() { let e = this.domSelection(); return e ? Qt && 11 === this.root.nodeType && function (e) { let t = e.activeElement; for (; t && t.shadowRoot;)t = t.shadowRoot.activeElement; return t }(this.dom.ownerDocument) == this.dom && function (e, t) { if (t.getComposedRanges) { let n = t.getComposedRanges(e.root)[0]; if (n) return Ro(e, n) } let n; function r(e) { e.preventDefault(), e.stopImmediatePropagation(), n = e.getTargetRanges()[0] } return e.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), e.dom.removeEventListener("beforeinput", r, !0), n ? Ro(e, n) : null }(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 } } domSelection() { return this.root.getSelection() } } function Wo(e) { let t = Object.create(null); return t.class = "ProseMirror", t.contenteditable = String(e.editable), e.someProp("attributes", n => { if ("function" == typeof n && (n = n(e.state)), n) for (let e in n) "class" == e ? t.class += " " + n[e] : "style" == e ? t.style = (t.style ? t.style + ";" : "") + n[e] : t[e] || "contenteditable" == e || "nodeName" == e || (t[e] = String(n[e])) }), t.translate || (t.translate = "no"), [po.node(0, e.state.doc.content.size, t)] } function Jo(e) { if (e.markCursor) { let t = document.createElement("img"); t.className = "ProseMirror-separator", t.setAttribute("mark-placeholder", "true"), t.setAttribute("alt", ""), e.cursorWrapper = { dom: t, deco: po.widget(e.state.selection.from, t, { raw: !0, marks: e.markCursor }) } } else e.cursorWrapper = null } function jo(e) { return !e.someProp("editable", t => !1 === t(e.state)) } function Ko(e) { let t = Object.create(null); function n(e) { for (let n in e) Object.prototype.hasOwnProperty.call(t, n) || (t[n] = e[n]) } return e.someProp("nodeViews", n), e.someProp("markViews", n), t } function Ho(e) { if (e.spec.state || e.spec.filterTransaction || e.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component") } _o.prototype.dispatch = function (e) { let t = this._props.dispatchTransaction; t ? t.call(this, e) : this.updateState(this.state.apply(e)) }; for (var Uo = Object.freeze({ __proto__: null, Decoration: po, DecorationSet: mo, EditorView: _o, __endComposition: Lo, __parseFromClipboard: qo }), Go = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, Yo = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, Qo = "undefined" != typeof navigator && /Mac/.test(navigator.platform), Xo = "undefined" != typeof navigator && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent), Zo = 0; Zo < 10; Zo++)Go[48 + Zo] = Go[96 + Zo] = String(Zo); for (Zo = 1; Zo <= 24; Zo++)Go[Zo + 111] = "F" + Zo; for (Zo = 65; Zo <= 90; Zo++)Go[Zo] = String.fromCharCode(Zo + 32), Yo[Zo] = String.fromCharCode(Zo); for (var ei in Go) Yo.hasOwnProperty(ei) || (Yo[ei] = Go[ei]); const ti = "undefined" != typeof navigator && /Mac|iP(hone|[oa]d)/.test(navigator.platform), ni = "undefined" != typeof navigator && /Win/.test(navigator.platform); function ri(e) { let t, n, r, o, i = e.split(/-(?!$)/), s = i[i.length - 1]; "Space" == s && (s = " "); for (let e = 0; e < i.length - 1; e++) { let s = i[e]; if (/^(cmd|meta|m)$/i.test(s)) o = !0; else if (/^a(lt)?$/i.test(s)) t = !0; else if (/^(c|ctrl|control)$/i.test(s)) n = !0; else if (/^s(hift)?$/i.test(s)) r = !0; else { if (!/^mod$/i.test(s)) throw new Error("Unrecognized modifier name: " + s); ti ? o = !0 : n = !0 } } return t && (s = "Alt-" + s), n && (s = "Ctrl-" + s), o && (s = "Meta-" + s), r && (s = "Shift-" + s), s } function oi(e, t, n = !0) { return t.altKey && (e = "Alt-" + e), t.ctrlKey && (e = "Ctrl-" + e), t.metaKey && (e = "Meta-" + e), n && t.shiftKey && (e = "Shift-" + e), e } function ii(e) { return new St({ props: { handleKeyDown: si(e) } }) } function si(e) { let t = function (e) { let t = Object.create(null); for (let n in e) t[ri(n)] = e[n]; return t }(e); return function (e, n) { let r, o = function (e) { var t = !(Qo && e.metaKey && e.shiftKey && !e.ctrlKey && !e.altKey || Xo && e.shiftKey && e.key && 1 == e.key.length || "Unidentified" == e.key) && e.key || (e.shiftKey ? Yo : Go)[e.keyCode] || e.key || "Unidentified"; return "Esc" == t && (t = "Escape"), "Del" == t && (t = "Delete"), "Left" == t && (t = "ArrowLeft"), "Up" == t && (t = "ArrowUp"), "Right" == t && (t = "ArrowRight"), "Down" == t && (t = "ArrowDown"), t }(n), i = t[oi(o, n)]; if (i && i(e.state, e.dispatch, e)) return !0; if (1 == o.length && " " != o) { if (n.shiftKey) { let r = t[oi(o, n, !1)]; if (r && r(e.state, e.dispatch, e)) return !0 } if ((n.altKey || n.metaKey || n.ctrlKey) && !(ni && n.ctrlKey && n.altKey) && (r = Go[n.keyCode]) && r != o) { let o = t[oi(r, n)]; if (o && o(e.state, e.dispatch, e)) return !0 } } return !1 } } var li = Object.freeze({ __proto__: null, keydownHandler: si, keymap: ii }); class ai { constructor(e, t, n = {}) { var r; this.match = e, this.match = e, this.handler = "string" == typeof t ? (r = t, function (e, t, n, o) { let i = r; if (t[1]) { let e = t[0].lastIndexOf(t[1]); i += t[0].slice(e + t[1].length); let r = (n += e) - o; r > 0 && (i = t[0].slice(e - r, e) + i, n = o) } return e.tr.insertText(i, n, o) }) : t, this.undoable = !1 !== n.undoable, this.inCode = n.inCode || !1, this.inCodeMark = !1 !== n.inCodeMark } } function hi({ rules: e }) { let t = new St({ state: { init: () => null, apply(e, t) { let n = e.getMeta(this); return n || (e.selectionSet || e.docChanged ? null : t) } }, props: { handleTextInput: (n, r, o, i) => ci(n, r, o, i, e, t), handleDOMEvents: { compositionend: n => { setTimeout(() => { let { $cursor: r } = n.state.selection; r && ci(n, r.pos, r.pos, "", e, t) }) } } }, isInputRules: !0 }); return t } function ci(e, t, n, r, o, i) { if (e.composing) return !1; let s = e.state, l = s.doc.resolve(t), a = l.parent.textBetween(Math.max(0, l.parentOffset - 500), l.parentOffset, null, "￼") + r; for (let h = 0; h < o.length; h++) { let c = o[h]; if (!c.inCodeMark && l.marks().some(e => e.type.spec.code)) continue; if (l.parent.type.spec.code) { if (!c.inCode) continue } else if ("only" === c.inCode) continue; let d = c.match.exec(a), p = d && d[0].length >= r.length && c.handler(s, d, t - (d[0].length - r.length), n); if (p) return c.undoable && p.setMeta(i, { transform: p, from: t, to: n, text: r }), e.dispatch(p), !0 } return !1 } const di = (e, t) => { let n = e.plugins; for (let r = 0; r < n.length; r++) { let o, i = n[r]; if (i.spec.isInputRules && (o = i.getState(e))) { if (t) { let n = e.tr, r = o.transform; for (let e = r.steps.length - 1; e >= 0; e--)n.step(r.steps[e].invert(r.docs[e])); if (o.text) { let t = n.doc.resolve(o.from).marks(); n.replaceWith(o.from, o.to, e.schema.text(o.text, t)) } else n.delete(o.from, o.to); t(n) } return !0 } } return !1 }, pi = new ai(/--$/, "—", { inCodeMark: !1 }), ui = new ai(/\.\.\.$/, "…", { inCodeMark: !1 }), fi = new ai(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“", { inCodeMark: !1 }), mi = new ai(/"$/, "”", { inCodeMark: !1 }), gi = new ai(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘", { inCodeMark: !1 }), yi = new ai(/'$/, "’", { inCodeMark: !1 }), wi = [fi, mi, gi, yi]; function vi(e, t, n = null, r) { return new ai(e, (e, o, i, s) => { let l = n instanceof Function ? n(o) : n, a = e.tr.delete(i, s), h = a.doc.resolve(i).blockRange(), c = h && Ae(h, t, l); if (!c) return null; a.wrap(h, c); let d = a.doc.resolve(i - 1).nodeBefore; return d && d.type == t && Be(a.doc, i - 1) && (!r || r(o, d)) && a.join(i - 1), a }) } function bi(e, t, n = null) { return new ai(e, (e, r, o, i) => { let s = e.doc.resolve(o), l = n instanceof Function ? n(r) : n; return s.node(-1).canReplaceWith(s.index(-1), s.indexAfter(-1), t) ? e.tr.delete(o, i).setBlockType(o, o, t, l) : null }) } var ki = Object.freeze({ __proto__: null, InputRule: ai, closeDoubleQuote: mi, closeSingleQuote: yi, ellipsis: ui, emDash: pi, inputRules: hi, openDoubleQuote: fi, openSingleQuote: gi, smartQuotes: wi, textblockTypeInputRule: bi, undoInputRule: di, wrappingInputRule: vi }), xi = 200, Si = function () { }; Si.prototype.append = function (e) { return e.length ? (e = Si.from(e), !this.length && e || e.length < xi && this.leafAppend(e) || this.length < xi && e.leafPrepend(this) || this.appendInner(e)) : this }, Si.prototype.prepend = function (e) { return e.length ? Si.from(e).append(this) : this }, Si.prototype.appendInner = function (e) { return new Mi(this, e) }, Si.prototype.slice = function (e, t) { return void 0 === e && (e = 0), void 0 === t && (t = this.length), e >= t ? Si.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t)) }, Si.prototype.get = function (e) { if (!(e < 0 || e >= this.length)) return this.getInner(e) }, Si.prototype.forEach = function (e, t, n) { void 0 === t && (t = 0), void 0 === n && (n = this.length), t <= n ? this.forEachInner(e, t, n, 0) : this.forEachInvertedInner(e, t, n, 0) }, Si.prototype.map = function (e, t, n) { void 0 === t && (t = 0), void 0 === n && (n = this.length); var r = []; return this.forEach(function (t, n) { return r.push(e(t, n)) }, t, n), r }, Si.from = function (e) { return e instanceof Si ? e : e && e.length ? new Ci(e) : Si.empty }; var Ci = function (e) { function t(t) { e.call(this), this.values = t } e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t; var n = { length: { configurable: !0 }, depth: { configurable: !0 } }; return t.prototype.flatten = function () { return this.values }, t.prototype.sliceInner = function (e, n) { return 0 == e && n == this.length ? this : new t(this.values.slice(e, n)) }, t.prototype.getInner = function (e) { return this.values[e] }, t.prototype.forEachInner = function (e, t, n, r) { for (var o = t; o < n; o++)if (!1 === e(this.values[o], r + o)) return !1 }, t.prototype.forEachInvertedInner = function (e, t, n, r) { for (var o = t - 1; o >= n; o--)if (!1 === e(this.values[o], r + o)) return !1 }, t.prototype.leafAppend = function (e) { if (this.length + e.length <= xi) return new t(this.values.concat(e.flatten())) }, t.prototype.leafPrepend = function (e) { if (this.length + e.length <= xi) return new t(e.flatten().concat(this.values)) }, n.length.get = function () { return this.values.length }, n.depth.get = function () { return 0 }, Object.defineProperties(t.prototype, n), t }(Si); Si.empty = new Ci([]); var Mi = function (e) { function t(t, n) { e.call(this), this.left = t, this.right = n, this.length = t.length + n.length, this.depth = Math.max(t.depth, n.depth) + 1 } return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.flatten = function () { return this.left.flatten().concat(this.right.flatten()) }, t.prototype.getInner = function (e) { return e < this.left.length ? this.left.get(e) : this.right.get(e - this.left.length) }, t.prototype.forEachInner = function (e, t, n, r) { var o = this.left.length; return !(t < o && !1 === this.left.forEachInner(e, t, Math.min(n, o), r)) && (!(n > o && !1 === this.right.forEachInner(e, Math.max(t - o, 0), Math.min(this.length, n) - o, r + o)) && void 0) }, t.prototype.forEachInvertedInner = function (e, t, n, r) { var o = this.left.length; return !(t > o && !1 === this.right.forEachInvertedInner(e, t - o, Math.max(n, o) - o, r + o)) && (!(n < o && !1 === this.left.forEachInvertedInner(e, Math.min(t, o), n, r)) && void 0) }, t.prototype.sliceInner = function (e, t) { if (0 == e && t == this.length) return this; var n = this.left.length; return t <= n ? this.left.slice(e, t) : e >= n ? this.right.slice(e - n, t - n) : this.left.slice(e, n).append(this.right.slice(0, t - n)) }, t.prototype.leafAppend = function (e) { var n = this.right.leafAppend(e); if (n) return new t(this.left, n) }, t.prototype.leafPrepend = function (e) { var n = this.left.leafPrepend(e); if (n) return new t(n, this.right) }, t.prototype.appendInner = function (e) { return this.left.depth >= Math.max(this.right.depth, e.depth) + 1 ? new t(this.left, new t(this.right, e)) : new t(this, e) }, t }(Si); class Oi { constructor(e, t) { this.items = e, this.eventCount = t } popEvent(e, t) { if (0 == this.eventCount) return null; let n, r, o = this.items.length; for (; ; o--) { if (this.items.get(o - 1).selection) { --o; break } } t && (n = this.remapping(o, this.items.length), r = n.maps.length); let i, s, l = e.tr, a = [], h = []; return this.items.forEach((e, t) => { if (!e.step) return n || (n = this.remapping(o, t + 1), r = n.maps.length), r--, void h.push(e); if (n) { h.push(new Ni(e.map)); let t, o = e.step.map(n.slice(r)); o && l.maybeStep(o).doc && (t = l.mapping.maps[l.mapping.maps.length - 1], a.push(new Ni(t, void 0, void 0, a.length + h.length))), r--, t && n.appendMap(t, r) } else l.maybeStep(e.step); return e.selection ? (i = n ? e.selection.map(n.slice(r)) : e.selection, s = new Oi(this.items.slice(0, o).append(h.reverse().concat(a)), this.eventCount - 1), !1) : void 0 }, this.items.length, 0), { remaining: s, transform: l, selection: i } } addTransform(e, t, n, r) { let o = [], i = this.eventCount, s = this.items, l = !r && s.length ? s.get(s.length - 1) : null; for (let n = 0; n < e.steps.length; n++) { let a, h = e.steps[n].invert(e.docs[n]), c = new Ni(e.mapping.maps[n], h, t); (a = l && l.merge(c)) && (c = a, n ? o.pop() : s = s.slice(0, s.length - 1)), o.push(c), t && (i++, t = void 0), r || (l = c) } let a = i - n.depth; return a > Ti && (s = function (e, t) { let n; return e.forEach((e, r) => { if (e.selection && 0 == t--) return n = r, !1 }), e.slice(n) }(s, a), i -= a), new Oi(s.append(o), i) } remapping(e, t) { let n = new ge; return this.items.forEach((t, r) => { let o = null != t.mirrorOffset && r - t.mirrorOffset >= e ? n.maps.length - t.mirrorOffset : void 0; n.appendMap(t.map, o) }, e, t), n } addMaps(e) { return 0 == this.eventCount ? this : new Oi(this.items.append(e.map(e => new Ni(e))), this.eventCount) } rebased(e, t) { if (!this.eventCount) return this; let n = [], r = Math.max(0, this.items.length - t), o = e.mapping, i = e.steps.length, s = this.eventCount; this.items.forEach(e => { e.selection && s-- }, r); let l = t; this.items.forEach(t => { let r = o.getMirror(--l); if (null == r) return; i = Math.min(i, r); let a = o.maps[r]; if (t.step) { let i = e.steps[r].invert(e.docs[r]), h = t.selection && t.selection.map(o.slice(l + 1, r)); h && s++, n.push(new Ni(a, i, h)) } else n.push(new Ni(a)) }, r); let a = []; for (let e = t; e < i; e++)a.push(new Ni(o.maps[e])); let h = this.items.slice(0, r).append(a).append(n), c = new Oi(h, s); return c.emptyItemCount() > 500 && (c = c.compress(this.items.length - n.length)), c } emptyItemCount() { let e = 0; return this.items.forEach(t => { t.step || e++ }), e } compress(e = this.items.length) { let t = this.remapping(0, e), n = t.maps.length, r = [], o = 0; return this.items.forEach((i, s) => { if (s >= e) r.push(i), i.selection && o++; else if (i.step) { let e = i.step.map(t.slice(n)), s = e && e.getMap(); if (n--, s && t.appendMap(s, n), e) { let l = i.selection && i.selection.map(t.slice(n)); l && o++; let a, h = new Ni(s.invert(), e, l), c = r.length - 1; (a = r.length && r[c].merge(h)) ? r[c] = a : r.push(h) } } else i.map && n-- }, this.items.length, 0), new Oi(Si.from(r.reverse()), o) } } Oi.empty = new Oi(Si.empty, 0); class Ni { constructor(e, t, n, r) { this.map = e, this.step = t, this.selection = n, this.mirrorOffset = r } merge(e) { if (this.step && e.step && !e.selection) { let t = e.step.merge(this.step); if (t) return new Ni(t.getMap().invert(), t, this.selection) } } } class Di { constructor(e, t, n, r, o) { this.done = e, this.undone = t, this.prevRanges = n, this.prevTime = r, this.prevComposition = o } } const Ti = 20; function Ei(e) { let t = []; for (let n = e.length - 1; n >= 0 && 0 == t.length; n--)e[n].forEach((e, n, r, o) => t.push(r, o)); return t } function Ai(e, t) { if (!e) return null; let n = []; for (let r = 0; r < e.length; r += 2) { let o = t.map(e[r], 1), i = t.map(e[r + 1], -1); o <= i && n.push(o, i) } return n } let Ri = !1, Ii = null; function zi(e) { let t = e.plugins; if (Ii != t) { Ri = !1, Ii = t; for (let e = 0; e < t.length; e++)if (t[e].spec.historyPreserveItems) { Ri = !0; break } } return Ri } const Pi = new Ot("history"), Bi = new Ot("closeHistory"); function $i(e = {}) { return e = { depth: e.depth || 100, newGroupDelay: e.newGroupDelay || 500 }, new St({ key: Pi, state: { init: () => new Di(Oi.empty, Oi.empty, null, 0, -1), apply: (t, n, r) => function (e, t, n, r) { let o, i = n.getMeta(Pi); if (i) return i.historyState; n.getMeta(Bi) && (e = new Di(e.done, e.undone, null, 0, -1)); let s = n.getMeta("appendedTransaction"); if (0 == n.steps.length) return e; if (s && s.getMeta(Pi)) return s.getMeta(Pi).redo ? new Di(e.done.addTransform(n, void 0, r, zi(t)), e.undone, Ei(n.mapping.maps), e.prevTime, e.prevComposition) : new Di(e.done, e.undone.addTransform(n, void 0, r, zi(t)), null, e.prevTime, e.prevComposition); if (!1 === n.getMeta("addToHistory") || s && !1 === s.getMeta("addToHistory")) return (o = n.getMeta("rebased")) ? new Di(e.done.rebased(n, o), e.undone.rebased(n, o), Ai(e.prevRanges, n.mapping), e.prevTime, e.prevComposition) : new Di(e.done.addMaps(n.mapping.maps), e.undone.addMaps(n.mapping.maps), Ai(e.prevRanges, n.mapping), e.prevTime, e.prevComposition); { let o = n.getMeta("composition"), i = 0 == e.prevTime || !s && e.prevComposition != o && (e.prevTime < (n.time || 0) - r.newGroupDelay || !function (e, t) { if (!t) return !1; if (!e.docChanged) return !0; let n = !1; return e.mapping.maps[0].forEach((e, r) => { for (let o = 0; o < t.length; o += 2)e <= t[o + 1] && r >= t[o] && (n = !0) }), n }(n, e.prevRanges)), l = s ? Ai(e.prevRanges, n.mapping) : Ei(n.mapping.maps); return new Di(e.done.addTransform(n, i ? t.selection.getBookmark() : void 0, r, zi(t)), Oi.empty, l, n.time, null == o ? e.prevComposition : o) } }(n, r, t, e) }, config: e, props: { handleDOMEvents: { beforeinput(e, t) { let n = t.inputType, r = "historyUndo" == n ? Fi : "historyRedo" == n ? qi : null; return !!r && (t.preventDefault(), r(e.state, e.dispatch)) } } } }) } function Vi(e, t) { return (n, r) => { let o = Pi.getState(n); if (!o || 0 == (e ? o.undone : o.done).eventCount) return !1; if (r) { let i = function (e, t, n) { let r = zi(t), o = Pi.get(t).spec.config, i = (n ? e.undone : e.done).popEvent(t, r); if (!i) return null; let s = i.selection.resolve(i.transform.doc), l = (n ? e.done : e.undone).addTransform(i.transform, t.selection.getBookmark(), o, r), a = new Di(n ? l : i.remaining, n ? i.remaining : l, null, 0, -1); return i.transform.setSelection(s).setMeta(Pi, { redo: n, historyState: a }) }(o, n, e); i && r(t ? i.scrollIntoView() : i) } return !0 } } const Fi = Vi(!1, !0), qi = Vi(!0, !0), Li = Vi(!1, !1), _i = Vi(!0, !1); var Wi = Object.freeze({ __proto__: null, closeHistory: function (e) { return e.setMeta(Bi, !0) }, history: $i, redo: qi, redoDepth: function (e) { let t = Pi.getState(e); return t ? t.undone.eventCount : 0 }, redoNoScroll: _i, undo: Fi, undoDepth: function (e) { let t = Pi.getState(e); return t ? t.done.eventCount : 0 }, undoNoScroll: Li }); const Ji = (e, t) => !e.selection.empty && (t && t(e.tr.deleteSelection().scrollIntoView()), !0); function ji(e, t) { let { $cursor: n } = e.selection; return !n || (t ? !t.endOfTextblock("backward", e) : n.parentOffset > 0) ? null : n } const Ki = (e, t, n) => { let r = ji(e, n); if (!r) return !1; let o = Yi(r); if (!o) { let n = r.blockRange(), o = n && Ee(n); return null != o && (t && t(e.tr.lift(n, o).scrollIntoView()), !0) } let i = o.nodeBefore; if (fs(e, o, t, -1)) return !0; if (0 == r.parent.content.size && (Ui(i, "end") || ct.isSelectable(i))) for (let n = r.depth; ; n--) { let s = Le(e.doc, r.before(n), r.after(n), h.empty); if (s && s.slice.size < s.to - s.from) { if (t) { let n = e.tr.step(s); n.setSelection(Ui(i, "end") ? ot.findFrom(n.doc.resolve(n.mapping.map(o.pos, -1)), -1) : ct.create(n.doc, o.pos - i.nodeSize)), t(n.scrollIntoView()) } return !0 } if (1 == n || r.node(n - 1).childCount > 1) break } return !(!i.isAtom || o.depth != r.depth - 1) && (t && t(e.tr.delete(o.pos - i.nodeSize, o.pos).scrollIntoView()), !0) }; function Hi(e, t, n) { let r = t.nodeBefore, o = t.pos - 1; for (; !r.isTextblock; o--) { if (r.type.spec.isolating) return !1; let e = r.lastChild; if (!e) return !1; r = e } let i = t.nodeAfter, s = t.pos + 1; for (; !i.isTextblock; s++) { if (i.type.spec.isolating) return !1; let e = i.firstChild; if (!e) return !1; i = e } let l = Le(e.doc, o, s, h.empty); if (!l || l.from != o || l instanceof Me && l.slice.size >= s - o) return !1; if (n) { let t = e.tr.step(l); t.setSelection(at.create(t.doc, o)), n(t.scrollIntoView()) } return !0 } function Ui(e, t, n = !1) { for (let r = e; r; r = "start" == t ? r.firstChild : r.lastChild) { if (r.isTextblock) return !0; if (n && 1 != r.childCount) return !1 } return !1 } const Gi = (e, t, n) => { let { $head: r, empty: o } = e.selection, i = r; if (!o) return !1; if (r.parent.isTextblock) { if (n ? !n.endOfTextblock("backward", e) : r.parentOffset > 0) return !1; i = Yi(r) } let s = i && i.nodeBefore; return !(!s || !ct.isSelectable(s)) && (t && t(e.tr.setSelection(ct.create(e.doc, i.pos - s.nodeSize)).scrollIntoView()), !0) }; function Yi(e) { if (!e.parent.type.spec.isolating) for (let t = e.depth - 1; t >= 0; t--) { if (e.index(t) > 0) return e.doc.resolve(e.before(t + 1)); if (e.node(t).type.spec.isolating) break } return null } function Qi(e, t) { let { $cursor: n } = e.selection; return !n || (t ? !t.endOfTextblock("forward", e) : n.parentOffset < n.parent.content.size) ? null : n } const Xi = (e, t, n) => { let r = Qi(e, n); if (!r) return !1; let o = es(r); if (!o) return !1; let i = o.nodeAfter; if (fs(e, o, t, 1)) return !0; if (0 == r.parent.content.size && (Ui(i, "start") || ct.isSelectable(i))) { let n = Le(e.doc, r.before(), r.after(), h.empty); if (n && n.slice.size < n.to - n.from) { if (t) { let r = e.tr.step(n); r.setSelection(Ui(i, "start") ? ot.findFrom(r.doc.resolve(r.mapping.map(o.pos)), 1) : ct.create(r.doc, r.mapping.map(o.pos))), t(r.scrollIntoView()) } return !0 } } return !(!i.isAtom || o.depth != r.depth - 1) && (t && t(e.tr.delete(o.pos, o.pos + i.nodeSize).scrollIntoView()), !0) }, Zi = (e, t, n) => { let { $head: r, empty: o } = e.selection, i = r; if (!o) return !1; if (r.parent.isTextblock) { if (n ? !n.endOfTextblock("forward", e) : r.parentOffset < r.parent.content.size) return !1; i = es(r) } let s = i && i.nodeAfter; return !(!s || !ct.isSelectable(s)) && (t && t(e.tr.setSelection(ct.create(e.doc, i.pos)).scrollIntoView()), !0) }; function es(e) { if (!e.parent.type.spec.isolating) for (let t = e.depth - 1; t >= 0; t--) { let n = e.node(t); if (e.index(t) + 1 < n.childCount) return e.doc.resolve(e.after(t + 1)); if (n.type.spec.isolating) break } return null } const ts = (e, t) => { let n, r = e.selection, o = r instanceof ct; if (o) { if (r.node.isTextblock || !Be(e.doc, r.from)) return !1; n = r.from } else if (n = Ve(e.doc, r.from, -1), null == n) return !1; if (t) { let r = e.tr.join(n); o && r.setSelection(ct.create(r.doc, n - e.doc.resolve(n).nodeBefore.nodeSize)), t(r.scrollIntoView()) } return !0 }, ns = (e, t) => { let n, r = e.selection; if (r instanceof ct) { if (r.node.isTextblock || !Be(e.doc, r.to)) return !1; n = r.to } else if (n = Ve(e.doc, r.to, 1), null == n) return !1; return t && t(e.tr.join(n).scrollIntoView()), !0 }, rs = (e, t) => { let { $from: n, $to: r } = e.selection, o = n.blockRange(r), i = o && Ee(o); return null != i && (t && t(e.tr.lift(o, i).scrollIntoView()), !0) }, is = (e, t) => { let { $head: n, $anchor: r } = e.selection; return !(!n.parent.type.spec.code || !n.sameParent(r)) && (t && t(e.tr.insertText("\n").scrollIntoView()), !0) }; function ss(e) { for (let t = 0; t < e.edgeCount; t++) { let { type: n } = e.edge(t); if (n.isTextblock && !n.hasRequiredAttrs()) return n } return null } const ls = (e, t) => { let { $head: n, $anchor: r } = e.selection; if (!n.parent.type.spec.code || !n.sameParent(r)) return !1; let o = n.node(-1), i = n.indexAfter(-1), s = ss(o.contentMatchAt(i)); if (!s || !o.canReplaceWith(i, i, s)) return !1; if (t) { let r = n.after(), o = e.tr.replaceWith(r, r, s.createAndFill()); o.setSelection(ot.near(o.doc.resolve(r), 1)), t(o.scrollIntoView()) } return !0 }, as = (e, t) => { let n = e.selection, { $from: r, $to: o } = n; if (n instanceof pt || r.parent.inlineContent || o.parent.inlineContent) return !1; let i = ss(o.parent.contentMatchAt(o.indexAfter())); if (!i || !i.isTextblock) return !1; if (t) { let n = (!r.parentOffset && o.index() < o.parent.childCount ? r : o).pos, s = e.tr.insert(n, i.createAndFill()); s.setSelection(at.create(s.doc, n + 1)), t(s.scrollIntoView()) } return !0 }, hs = (e, t) => { let { $cursor: n } = e.selection; if (!n || n.parent.content.size) return !1; if (n.depth > 1 && n.after() != n.end(-1)) { let r = n.before(); if (Pe(e.doc, r)) return t && t(e.tr.split(r).scrollIntoView()), !0 } let r = n.blockRange(), o = r && Ee(r); return null != o && (t && t(e.tr.lift(r, o).scrollIntoView()), !0) }; function cs(e) { return (t, n) => { let { $from: r, $to: o } = t.selection; if (t.selection instanceof ct && t.selection.node.isBlock) return !(!r.parentOffset || !Pe(t.doc, r.pos)) && (n && n(t.tr.split(r.pos).scrollIntoView()), !0); if (!r.depth) return !1; let i, s, l = [], a = !1, h = !1; for (let t = r.depth; ; t--) { if (r.node(t).isBlock) { a = r.end(t) == r.pos + (r.depth - t), h = r.start(t) == r.pos - (r.depth - t), s = ss(r.node(t - 1).contentMatchAt(r.indexAfter(t - 1))); let n = e && e(o.parent, a, r); l.unshift(n || (a && s ? { type: s } : null)), i = t; break } if (1 == t) return !1; l.unshift(null) } let c = t.tr; (t.selection instanceof at || t.selection instanceof pt) && c.deleteSelection(); let d = c.mapping.map(r.pos), p = Pe(c.doc, d, l.length, l); if (p || (l[0] = s ? { type: s } : null, p = Pe(c.doc, d, l.length, l)), !p) return !1; if (c.split(d, l.length, l), !a && h && r.node(i).type != s) { let e = c.mapping.map(r.before(i)), t = c.doc.resolve(e); s && r.node(i - 1).canReplaceWith(t.index(), t.index() + 1, s) && c.setNodeMarkup(c.mapping.map(r.before(i)), s) } return n && n(c.scrollIntoView()), !0 } } const ds = cs(), ps = (e, t) => { let n, { $from: r, to: o } = e.selection, i = r.sharedDepth(o); return 0 != i && (n = r.before(i), t && t(e.tr.setSelection(ct.create(e.doc, n))), !0) }, us = (e, t) => (t && t(e.tr.setSelection(new pt(e.doc))), !0); function fs(e, t, n, o) { let i, s, l = t.nodeBefore, a = t.nodeAfter, c = l.type.spec.isolating || a.type.spec.isolating; if (!c && function (e, t, n) { let r = t.nodeBefore, o = t.nodeAfter, i = t.index(); return !(!(r && o && r.type.compatibleContent(o.type)) || (!r.content.size && t.parent.canReplace(i - 1, i) ? (n && n(e.tr.delete(t.pos - r.nodeSize, t.pos).scrollIntoView()), 0) : !t.parent.canReplace(i, i + 1) || !o.isTextblock && !Be(e.doc, t.pos) || (n && n(e.tr.join(t.pos).scrollIntoView()), 0))) }(e, t, n)) return !0; let d = !c && t.parent.canReplace(t.index(), t.index() + 1); if (d && (i = (s = l.contentMatchAt(l.childCount)).findWrapping(a.type)) && s.matchType(i[0] || a.type).validEnd) { if (n) { let o = t.pos + a.nodeSize, s = r.empty; for (let e = i.length - 1; e >= 0; e--)s = r.from(i[e].create(null, s)); s = r.from(l.copy(s)); let c = e.tr.step(new Oe(t.pos - 1, o, t.pos, o, new h(s, 1, 0), i.length, !0)), d = c.doc.resolve(o + 2 * i.length); d.nodeAfter && d.nodeAfter.type == l.type && Be(c.doc, d.pos) && c.join(d.pos), n(c.scrollIntoView()) } return !0 } let p = a.type.spec.isolating || o > 0 && c ? null : ot.findFrom(t, 1), u = p && p.$from.blockRange(p.$to), f = u && Ee(u); if (null != f && f >= t.depth) return n && n(e.tr.lift(u, f).scrollIntoView()), !0; if (d && Ui(a, "start", !0) && Ui(l, "end")) { let o = l, i = []; for (; i.push(o), !o.isTextblock;)o = o.lastChild; let s = a, c = 1; for (; !s.isTextblock; s = s.firstChild)c++; if (o.canReplace(o.childCount, o.childCount, s.content)) { if (n) { let o = r.empty; for (let e = i.length - 1; e >= 0; e--)o = r.from(i[e].copy(o)); n(e.tr.step(new Oe(t.pos - i.length, t.pos + a.nodeSize, t.pos + c, t.pos + a.nodeSize - c, new h(o, i.length, 0), 0, !0)).scrollIntoView()) } return !0 } } return !1 } function ms(e) { return function (t, n) { let r = t.selection, o = e < 0 ? r.$from : r.$to, i = o.depth; for (; o.node(i).isInline;) { if (!i) return !1; i-- } return !!o.node(i).isTextblock && (n && n(t.tr.setSelection(at.create(t.doc, e < 0 ? o.start(i) : o.end(i)))), !0) } } const gs = ms(-1), ys = ms(1); function ws(e, t = null) { return function (n, r) { let { $from: o, $to: i } = n.selection, s = o.blockRange(i), l = s && Ae(s, e, t); return !!l && (r && r(n.tr.wrap(s, l).scrollIntoView()), !0) } } function vs(e, t = null) { return function (n, r) { let o = !1; for (let r = 0; r < n.selection.ranges.length && !o; r++) { let { $from: { pos: i }, $to: { pos: s } } = n.selection.ranges[r]; n.doc.nodesBetween(i, s, (r, i) => { if (o) return !1; if (r.isTextblock && !r.hasMarkup(e, t)) if (r.type == e) o = !0; else { let t = n.doc.resolve(i), r = t.index(); o = t.parent.canReplaceWith(r, r + 1, e) } }) } if (!o) return !1; if (r) { let o = n.tr; for (let r = 0; r < n.selection.ranges.length; r++) { let { $from: { pos: i }, $to: { pos: s } } = n.selection.ranges[r]; o.setBlockType(i, s, e, t) } r(o.scrollIntoView()) } return !0 } } function bs(e, t = null, n) { let r = !1 !== (n && n.removeWhenPresent), o = !1 !== (n && n.enterInlineAtoms), i = !(n && n.includeWhitespace); return function (n, s) { let { empty: l, $cursor: a, ranges: h } = n.selection; if (l && !a || !function (e, t, n, r) { for (let o = 0; o < t.length; o++) { let { $from: i, $to: s } = t[o], l = 0 == i.depth && e.inlineContent && e.type.allowsMarkType(n); if (e.nodesBetween(i.pos, s.pos, (e, t) => { if (l || !r && e.isAtom && e.isInline && t >= i.pos && t + e.nodeSize <= s.pos) return !1; l = e.inlineContent && e.type.allowsMarkType(n) }), l) return !0 } return !1 }(n.doc, h, e, o)) return !1; if (s) if (a) e.isInSet(n.storedMarks || a.marks()) ? s(n.tr.removeStoredMark(e)) : s(n.tr.addStoredMark(e.create(t))); else { let l, a = n.tr; o || (h = function (e) { let t = []; for (let n = 0; n < e.length; n++) { let { $from: r, $to: o } = e[n]; r.doc.nodesBetween(r.pos, o.pos, (e, n) => { if (e.isAtom && e.content.size && e.isInline && n >= r.pos && n + e.nodeSize <= o.pos) return n + 1 > r.pos && t.push(new it(r, r.doc.resolve(n + 1))), r = r.doc.resolve(n + 1 + e.content.size), !1 }), r.pos < o.pos && t.push(new it(r, o)) } return t }(h)), l = r ? !h.some(t => n.doc.rangeHasMark(t.$from.pos, t.$to.pos, e)) : !h.every(t => { let n = !1; return a.doc.nodesBetween(t.$from.pos, t.$to.pos, (r, o, i) => { if (n) return !1; n = !e.isInSet(r.marks) && !!i && i.type.allowsMarkType(e) && !(r.isText && /^\s*$/.test(r.textBetween(Math.max(0, t.$from.pos - o), Math.min(r.nodeSize, t.$to.pos - o)))) }), !n }); for (let n = 0; n < h.length; n++) { let { $from: r, $to: o } = h[n]; if (l) { let n = r.pos, s = o.pos, l = r.nodeAfter, h = o.nodeBefore, c = i && l && l.isText ? /^\s*/.exec(l.text)[0].length : 0, d = i && h && h.isText ? /\s*$/.exec(h.text)[0].length : 0; n + c < s && (n += c, s -= d), a.addMark(n, s, e.create(t)) } else a.removeMark(r.pos, o.pos, e) } s(a.scrollIntoView()) } return !0 } } function ks(e, t) { return n => { if (!n.isGeneric) return e(n); let r = []; for (let e = 0; e < n.mapping.maps.length; e++) { let t = n.mapping.maps[e]; for (let e = 0; e < r.length; e++)r[e] = t.map(r[e]); t.forEach((e, t, n, o) => r.push(n, o)) } let o = []; for (let e = 0; e < r.length; e += 2) { let i = r[e], s = r[e + 1], l = n.doc.resolve(i), a = l.sharedDepth(s), h = l.node(a); for (let e = l.indexAfter(a), n = l.after(a + 1); n <= s; ++e) { let r = h.maybeChild(e); if (!r) break; if (e && -1 == o.indexOf(n)) { let i = h.child(e - 1); i.type == r.type && t(i, r) && o.push(n) } n += r.nodeSize } } o.sort((e, t) => e - t); for (let e = o.length - 1; e >= 0; e--)Be(n.doc, o[e]) && n.join(o[e]); e(n) } } function xs(...e) { return function (t, n, r) { for (let o = 0; o < e.length; o++)if (e[o](t, n, r)) return !0; return !1 } } let Ss = xs(Ji, Ki, Gi), Cs = xs(Ji, Xi, Zi); const Ms = { Enter: xs(is, as, hs, ds), "Mod-Enter": ls, Backspace: Ss, "Mod-Backspace": Ss, "Shift-Backspace": Ss, Delete: Cs, "Mod-Delete": Cs, "Mod-a": us }, Os = { "Ctrl-h": Ms.Backspace, "Alt-Backspace": Ms["Mod-Backspace"], "Ctrl-d": Ms.Delete, "Ctrl-Alt-Backspace": Ms["Mod-Delete"], "Alt-Delete": Ms["Mod-Delete"], "Alt-d": Ms["Mod-Delete"], "Ctrl-a": gs, "Ctrl-e": ys }; for (let e in Ms) Os[e] = Ms[e]; const Ns = ("undefined" != typeof navigator ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !("undefined" == typeof os || !os.platform) && "darwin" == os.platform()) ? Os : Ms; var Ds = Object.freeze({ __proto__: null, autoJoin: function (e, t) { let n = Array.isArray(t) ? e => t.indexOf(e.type.name) > -1 : t; return (t, r, o) => e(t, r && ks(r, n), o) }, baseKeymap: Ns, chainCommands: xs, createParagraphNear: as, deleteSelection: Ji, exitCode: ls, joinBackward: Ki, joinDown: ns, joinForward: Xi, joinTextblockBackward: (e, t, n) => { let r = ji(e, n); if (!r) return !1; let o = Yi(r); return !!o && Hi(e, o, t) }, joinTextblockForward: (e, t, n) => { let r = Qi(e, n); if (!r) return !1; let o = es(r); return !!o && Hi(e, o, t) }, joinUp: ts, lift: rs, liftEmptyBlock: hs, macBaseKeymap: Os, newlineInCode: is, pcBaseKeymap: Ms, selectAll: us, selectNodeBackward: Gi, selectNodeForward: Zi, selectParentNode: ps, selectTextblockEnd: ys, selectTextblockStart: gs, setBlockType: vs, splitBlock: ds, splitBlockAs: cs, splitBlockKeepMarks: (e, t) => ds(e, t && (n => { let r = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks(); r && n.ensureMarks(r), t(n) })), toggleMark: bs, wrapIn: ws }); const Ts = ["p", 0], Es = ["blockquote", 0], As = ["hr"], Rs = ["pre", ["code", 0]], Is = ["br"], zs = { doc: { content: "block+" }, paragraph: { content: "inline*", group: "block", parseDOM: [{ tag: "p" }], toDOM: () => Ts }, blockquote: { content: "block+", group: "block", defining: !0, parseDOM: [{ tag: "blockquote" }], toDOM: () => Es }, horizontal_rule: { group: "block", parseDOM: [{ tag: "hr" }], toDOM: () => As }, heading: { attrs: { level: { default: 1, validate: "number" } }, content: "inline*", group: "block", defining: !0, parseDOM: [{ tag: "h1", attrs: { level: 1 } }, { tag: "h2", attrs: { level: 2 } }, { tag: "h3", attrs: { level: 3 } }, { tag: "h4", attrs: { level: 4 } }, { tag: "h5", attrs: { level: 5 } }, { tag: "h6", attrs: { level: 6 } }], toDOM: e => ["h" + e.attrs.level, 0] }, code_block: { content: "text*", marks: "", group: "block", code: !0, defining: !0, parseDOM: [{ tag: "pre", preserveWhitespace: "full" }], toDOM: () => Rs }, text: { group: "inline" }, image: { inline: !0, attrs: { src: { validate: "string" }, alt: { default: null, validate: "string|null" }, title: { default: null, validate: "string|null" } }, group: "inline", draggable: !0, parseDOM: [{ tag: "img[src]", getAttrs: e => ({ src: e.getAttribute("src"), title: e.getAttribute("title"), alt: e.getAttribute("alt") }) }], toDOM(e) { let { src: t, alt: n, title: r } = e.attrs; return ["img", { src: t, alt: n, title: r }] } }, hard_break: { inline: !0, group: "inline", selectable: !1, parseDOM: [{ tag: "br" }], toDOM: () => Is } }, Ps = ["em", 0], Bs = ["strong", 0], $s = ["code", 0], Vs = { link: { attrs: { href: { validate: "string" }, title: { default: null, validate: "string|null" } }, inclusive: !1, parseDOM: [{ tag: "a[href]", getAttrs: e => ({ href: e.getAttribute("href"), title: e.getAttribute("title") }) }], toDOM(e) { let { href: t, title: n } = e.attrs; return ["a", { href: t, title: n }, 0] } }, em: { parseDOM: [{ tag: "i" }, { tag: "em" }, { style: "font-style=italic" }, { style: "font-style=normal", clearMark: e => "em" == e.type.name }], toDOM: () => Ps }, strong: { parseDOM: [{ tag: "strong" }, { tag: "b", getAttrs: e => "normal" != e.style.fontWeight && null }, { style: "font-weight=400", clearMark: e => "strong" == e.type.name }, { style: "font-weight", getAttrs: e => /^(bold(er)?|[5-9]\d{2,})$/.test(e) && null }], toDOM: () => Bs }, code: { code: !0, parseDOM: [{ tag: "code" }], toDOM: () => $s } }, Fs = new K({ nodes: zs, marks: Vs }); var qs = Object.freeze({ __proto__: null, marks: Vs, nodes: zs, schema: Fs }); const Ls = ["ol", 0], _s = ["ul", 0], Ws = ["li", 0], Js = { attrs: { order: { default: 1, validate: "number" } }, parseDOM: [{ tag: "ol", getAttrs: e => ({ order: e.hasAttribute("start") ? +e.getAttribute("start") : 1 }) }], toDOM: e => 1 == e.attrs.order ? Ls : ["ol", { start: e.attrs.order }, 0] }, js = { parseDOM: [{ tag: "ul" }], toDOM: () => _s }, Ks = { parseDOM: [{ tag: "li" }], toDOM: () => Ws, defining: !0 }; function Hs(e, t) { let n = {}; for (let t in e) n[t] = e[t]; for (let e in t) n[e] = t[e]; return n } function Us(e, t = null) { return function (n, r) { let { $from: o, $to: i } = n.selection, s = o.blockRange(i); if (!s) return !1; let l = r ? n.tr : null; return !!Gs(l, s, e, t) && (r && r(l.scrollIntoView()), !0) } } function Gs(e, t, n, o = null) { let i = !1, s = t, l = t.$from.doc; if (t.depth >= 2 && t.$from.node(t.depth - 1).type.compatibleContent(n) && 0 == t.startIndex) { if (0 == t.$from.index(t.depth - 1)) return !1; let e = l.resolve(t.start - 2); s = new M(e, e, t.depth), t.endIndex < t.parent.childCount && (t = new M(t.$from, l.resolve(t.$to.end(t.depth)), t.depth)), i = !0 } let a = Ae(s, n, o, t); return !!a && (e && function (e, t, n, o, i) { let s = r.empty; for (let e = n.length - 1; e >= 0; e--)s = r.from(n[e].type.create(n[e].attrs, s)); e.step(new Oe(t.start - (o ? 2 : 0), t.end, t.start, t.end, new h(s, 0, 0), n.length, !0)); let l = 0; for (let e = 0; e < n.length; e++)n[e].type == i && (l = e + 1); let a = n.length - l, c = t.start + n.length - (o ? 2 : 0), d = t.parent; for (let n = t.startIndex, r = t.endIndex, o = !0; n < r; n++, o = !1)!o && Pe(e.doc, c, a) && (e.split(c, a), c += 2 * a), c += d.child(n).nodeSize }(e, t, a, i, n), !0) } function Ys(e, t) { return function (n, o) { let { $from: i, $to: s, node: l } = n.selection; if (l && l.isBlock || i.depth < 2 || !i.sameParent(s)) return !1; let a = i.node(-1); if (a.type != e) return !1; if (0 == i.parent.content.size && i.node(-1).childCount == i.indexAfter(-1)) { if (3 == i.depth || i.node(-3).type != e || i.index(-2) != i.node(-2).childCount - 1) return !1; if (o) { let t = r.empty, s = i.index(-1) ? 1 : i.index(-2) ? 2 : 3; for (let e = i.depth - s; e >= i.depth - 3; e--)t = r.from(i.node(e).copy(t)); let l = i.indexAfter(-1) < i.node(-2).childCount ? 1 : i.indexAfter(-2) < i.node(-3).childCount ? 2 : 3; t = t.append(r.from(e.createAndFill())); let a = i.before(i.depth - (s - 1)), c = n.tr.replace(a, i.after(-l), new h(t, 4 - s, 0)), d = -1; c.doc.nodesBetween(a, c.doc.content.size, (e, t) => { if (d > -1) return !1; e.isTextblock && 0 == e.content.size && (d = t + 1) }), d > -1 && c.setSelection(ot.near(c.doc.resolve(d))), o(c.scrollIntoView()) } return !0 } let c = s.pos == i.end() ? a.contentMatchAt(0).defaultType : null, d = n.tr.delete(i.pos, s.pos), p = c ? [t ? { type: e, attrs: t } : null, { type: c }] : void 0; return !!Pe(d.doc, i.pos, 2, p) && (o && o(d.split(i.pos, 2, p).scrollIntoView()), !0) } } function Qs(e) { return function (t, n) { let { $from: o, $to: i } = t.selection, s = o.blockRange(i, t => t.childCount > 0 && t.firstChild.type == e); return !!s && (!n || (o.node(s.depth - 1).type == e ? function (e, t, n, o) { let i = e.tr, s = o.end, l = o.$to.end(o.depth); s < l && (i.step(new Oe(s - 1, l, s, l, new h(r.from(n.create(null, o.parent.copy())), 1, 0), 1, !0)), o = new M(i.doc.resolve(o.$from.pos), i.doc.resolve(l), o.depth)); const a = Ee(o); if (null == a) return !1; i.lift(o, a); let c = i.doc.resolve(i.mapping.map(s, -1) - 1); Be(i.doc, c.pos) && c.nodeBefore.type == c.nodeAfter.type && i.join(c.pos); return t(i.scrollIntoView()), !0 }(t, n, e, s) : function (e, t, n) { let o = e.tr, i = n.parent; for (let e = n.end, t = n.endIndex - 1, r = n.startIndex; t > r; t--)e -= i.child(t).nodeSize, o.delete(e - 1, e + 1); let s = o.doc.resolve(n.start), l = s.nodeAfter; if (o.mapping.map(n.end) != n.start + s.nodeAfter.nodeSize) return !1; let a = 0 == n.startIndex, c = n.endIndex == i.childCount, d = s.node(-1), p = s.index(-1); if (!d.canReplace(p + (a ? 0 : 1), p + 1, l.content.append(c ? r.empty : r.from(i)))) return !1; let u = s.pos, f = u + l.nodeSize; return o.step(new Oe(u - (a ? 1 : 0), f + (c ? 1 : 0), u + 1, f - 1, new h((a ? r.empty : r.from(i.copy(r.empty))).append(c ? r.empty : r.from(i.copy(r.empty))), a ? 0 : 1, c ? 0 : 1), a ? 0 : 1)), t(o.scrollIntoView()), !0 }(t, n, s))) } } function Xs(e) { return function (t, n) { let { $from: o, $to: i } = t.selection, s = o.blockRange(i, t => t.childCount > 0 && t.firstChild.type == e); if (!s) return !1; let l = s.startIndex; if (0 == l) return !1; let a = s.parent, c = a.child(l - 1); if (c.type != e) return !1; if (n) { let o = c.lastChild && c.lastChild.type == a.type, i = r.from(o ? e.create() : null), l = new h(r.from(e.create(null, r.from(a.type.create(null, i)))), o ? 3 : 1, 0), d = s.start, p = s.end; n(t.tr.step(new Oe(d - (o ? 3 : 1), p, d, p, l, 1, !0)).scrollIntoView()) } return !0 } } var Zs = Object.freeze({ __proto__: null, addListNodes: function (e, t, n) { return e.append({ ordered_list: Hs(Js, { content: "list_item+", group: n }), bullet_list: Hs(js, { content: "list_item+", group: n }), list_item: Hs(Ks, { content: t }) }) }, bulletList: js, liftListItem: Qs, listItem: Ks, orderedList: Js, sinkListItem: Xs, splitListItem: Ys, splitListItemKeepMarks: function (e, t) { let n = Ys(e, t); return (e, t) => n(e, t && (n => { let r = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks(); r && n.ensureMarks(r), t(n) })) }, wrapInList: Us, wrapRangeInList: Gs }); function el(e = {}) { return new St({ view: t => new tl(t, e) }) } class tl { constructor(e, t) { var n; this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = null !== (n = t.width) && void 0 !== n ? n : 1, this.color = !1 === t.color ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(t => { let n = e => { this[t](e) }; return e.dom.addEventListener(t, n), { name: t, handler: n } }) } destroy() { this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t)) } update(e, t) { null != this.cursorPos && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay()) } setCursor(e) { e != this.cursorPos && (this.cursorPos = e, null == e ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay()) } updateOverlay() { let e, t = this.editorView.state.doc.resolve(this.cursorPos), n = !t.parent.inlineContent, r = this.editorView.dom, o = r.getBoundingClientRect(), i = o.width / r.offsetWidth, s = o.height / r.offsetHeight; if (n) { let n = t.nodeBefore, r = t.nodeAfter; if (n || r) { let t = this.editorView.nodeDOM(this.cursorPos - (n ? n.nodeSize : 0)); if (t) { let o = t.getBoundingClientRect(), i = n ? o.bottom : o.top; n && r && (i = (i + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2); let l = this.width / 2 * s; e = { left: o.left, right: o.right, top: i - l, bottom: i + l } } } } if (!e) { let t = this.editorView.coordsAtPos(this.cursorPos), n = this.width / 2 * i; e = { left: t.left - n, right: t.left + n, top: t.top, bottom: t.bottom } } let l, a, h = this.editorView.dom.offsetParent; if (this.element || (this.element = h.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", n), this.element.classList.toggle("prosemirror-dropcursor-inline", !n), !h || h == document.body && "static" == getComputedStyle(h).position) l = -pageXOffset, a = -pageYOffset; else { let e = h.getBoundingClientRect(), t = e.width / h.offsetWidth, n = e.height / h.offsetHeight; l = e.left - h.scrollLeft * t, a = e.top - h.scrollTop * n } this.element.style.left = (e.left - l) / i + "px", this.element.style.top = (e.top - a) / s + "px", this.element.style.width = (e.right - e.left) / i + "px", this.element.style.height = (e.bottom - e.top) / s + "px" } scheduleRemoval(e) { clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e) } dragover(e) { if (!this.editorView.editable) return; let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), n = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), r = n && n.type.spec.disableDropCursor, o = "function" == typeof r ? r(this.editorView, t, e) : r; if (t && !o) { let e = t.pos; if (this.editorView.dragging && this.editorView.dragging.slice) { let t = qe(this.editorView.state.doc, e, this.editorView.dragging.slice); null != t && (e = t) } this.setCursor(e), this.scheduleRemoval(5e3) } } dragend() { this.scheduleRemoval(20) } drop() { this.scheduleRemoval(20) } dragleave(e) { this.editorView.dom.contains(e.relatedTarget) || this.setCursor(null) } } var nl = Object.freeze({ __proto__: null, dropCursor: el }); class rl extends ot { constructor(e) { super(e, e) } map(e, t) { let n = e.resolve(t.map(this.head)); return rl.valid(n) ? new rl(n) : ot.near(n) } content() { return h.empty } eq(e) { return e instanceof rl && e.head == this.head } toJSON() { return { type: "gapcursor", pos: this.head } } static fromJSON(e, t) { if ("number" != typeof t.pos) throw new RangeError("Invalid input for GapCursor.fromJSON"); return new rl(e.resolve(t.pos)) } getBookmark() { return new ol(this.anchor) } static valid(e) { let t = e.parent; if (t.isTextblock || !function (e) { for (let t = e.depth; t >= 0; t--) { let n = e.index(t), r = e.node(t); if (0 != n) for (let e = r.child(n - 1); ; e = e.lastChild) { if (0 == e.childCount && !e.inlineContent || e.isAtom || e.type.spec.isolating) return !0; if (e.inlineContent) return !1 } else if (r.type.spec.isolating) return !0 } return !0 }(e) || !function (e) { for (let t = e.depth; t >= 0; t--) { let n = e.indexAfter(t), r = e.node(t); if (n != r.childCount) for (let e = r.child(n); ; e = e.firstChild) { if (0 == e.childCount && !e.inlineContent || e.isAtom || e.type.spec.isolating) return !0; if (e.inlineContent) return !1 } else if (r.type.spec.isolating) return !0 } return !0 }(e)) return !1; let n = t.type.spec.allowGapCursor; if (null != n) return n; let r = t.contentMatchAt(e.index()).defaultType; return r && r.isTextblock } static findGapCursorFrom(e, t, n = !1) { e: for (; ;) { if (!n && rl.valid(e)) return e; let r = e.pos, o = null; for (let n = e.depth; ; n--) { let i = e.node(n); if (t > 0 ? e.indexAfter(n) < i.childCount : e.index(n) > 0) { o = i.child(t > 0 ? e.indexAfter(n) : e.index(n) - 1); break } if (0 == n) return null; r += t; let s = e.doc.resolve(r); if (rl.valid(s)) return s } for (; ;) { let i = t > 0 ? o.firstChild : o.lastChild; if (!i) { if (o.isAtom && !o.isText && !ct.isSelectable(o)) { e = e.doc.resolve(r + o.nodeSize * t), n = !1; continue e } break } o = i, r += t; let s = e.doc.resolve(r); if (rl.valid(s)) return s } return null } } } rl.prototype.visible = !1, rl.findFrom = rl.findGapCursorFrom, ot.jsonID("gapcursor", rl); class ol { constructor(e) { this.pos = e } map(e) { return new ol(e.map(this.pos)) } resolve(e) { let t = e.resolve(this.pos); return rl.valid(t) ? new rl(t) : ot.near(t) } } function il() { return new St({ props: { decorations: cl, createSelectionBetween: (e, t, n) => t.pos == n.pos && rl.valid(n) ? new rl(n) : null, handleClick: al, handleKeyDown: sl, handleDOMEvents: { beforeinput: hl } } }) } const sl = si({ ArrowLeft: ll("horiz", -1), ArrowRight: ll("horiz", 1), ArrowUp: ll("vert", -1), ArrowDown: ll("vert", 1) }); function ll(e, t) { const n = "vert" == e ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left"; return function (e, r, o) { let i = e.selection, s = t > 0 ? i.$to : i.$from, l = i.empty; if (i instanceof at) { if (!o.endOfTextblock(n) || 0 == s.depth) return !1; l = !1, s = e.doc.resolve(t > 0 ? s.after() : s.before()) } let a = rl.findGapCursorFrom(s, t, l); return !!a && (r && r(e.tr.setSelection(new rl(a))), !0) } } function al(e, t, n) { if (!e || !e.editable) return !1; let r = e.state.doc.resolve(t); if (!rl.valid(r)) return !1; let o = e.posAtCoords({ left: n.clientX, top: n.clientY }); return !(o && o.inside > -1 && ct.isSelectable(e.state.doc.nodeAt(o.inside))) && (e.dispatch(e.state.tr.setSelection(new rl(r))), !0) } function hl(e, t) { if ("insertCompositionText" != t.inputType || !(e.state.selection instanceof rl)) return !1; let { $from: n } = e.state.selection, o = n.parent.contentMatchAt(n.index()).findWrapping(e.state.schema.nodes.text); if (!o) return !1; let i = r.empty; for (let e = o.length - 1; e >= 0; e--)i = r.from(o[e].createAndFill(null, i)); let s = e.state.tr.replace(n.pos, n.pos, new h(i, 0, 0)); return s.setSelection(at.near(s.doc.resolve(n.pos + 1))), e.dispatch(s), !1 } function cl(e) { if (!(e.selection instanceof rl)) return null; let t = document.createElement("div"); return t.className = "ProseMirror-gapcursor", mo.create(e.doc, [po.widget(e.selection.head, t, { key: "gapcursor" })]) } var dl = Object.freeze({ __proto__: null, GapCursor: rl, gapCursor: il }); function pl() { var e = arguments[0]; "string" == typeof e && (e = document.createElement(e)); var t = 1, n = arguments[1]; if (n && "object" == typeof n && null == n.nodeType && !Array.isArray(n)) { for (var r in n) if (Object.prototype.hasOwnProperty.call(n, r)) { var o = n[r]; "string" == typeof o ? e.setAttribute(r, o) : null != o && (e[r] = o) } t++ } for (; t < arguments.length; t++)ul(e, arguments[t]); return e } function ul(e, t) { if ("string" == typeof t) e.appendChild(document.createTextNode(t)); else if (null == t); else if (null != t.nodeType) e.appendChild(t); else { if (!Array.isArray(t)) throw new RangeError("Unsupported child node: " + t); for (var n = 0; n < t.length; n++)ul(e, t[n]) } } const fl = "http://www.w3.org/2000/svg", ml = "ProseMirror-icon"; function gl(e, t) { let n = (9 == e.nodeType ? e : e.ownerDocument) || document, r = n.createElement("div"); if (r.className = ml, t.path) { let { path: o, width: i, height: s } = t, l = "pm-icon-" + function (e) { let t = 0; for (let n = 0; n < e.length; n++)t = (t << 5) - t + e.charCodeAt(n) | 0; return t }(o).toString(16); n.getElementById(l) || function (e, t, n) { let [r, o] = 9 == e.nodeType ? [e, e.body] : [e.ownerDocument || document, e], i = r.getElementById(ml + "-collection"); i || (i = r.createElementNS(fl, "svg"), i.id = ml + "-collection", i.style.display = "none", o.insertBefore(i, o.firstChild)); let s = r.createElementNS(fl, "symbol"); s.id = t, s.setAttribute("viewBox", "0 0 " + n.width + " " + n.height); let l = s.appendChild(r.createElementNS(fl, "path")); l.setAttribute("d", n.path), i.appendChild(s) }(e, l, t); let a = r.appendChild(n.createElementNS(fl, "svg")); a.style.width = i / s + "em", a.appendChild(n.createElementNS(fl, "use")).setAttributeNS("http://www.w3.org/1999/xlink", "href", /([^#]*)/.exec(n.location.toString())[1] + "#" + l) } else if (t.dom) r.appendChild(t.dom.cloneNode(!0)); else { let { text: e, css: o } = t; r.appendChild(n.createElement("span")).textContent = e || "", o && (r.firstChild.style.cssText = o) } return r } const yl = "ProseMirror-menu"; class wl { constructor(e) { this.spec = e } render(e) { let t = this.spec, n = t.render ? t.render(e) : t.icon ? gl(e.root, t.icon) : t.label ? pl("div", null, vl(e, t.label)) : null; if (!n) throw new RangeError("MenuItem without icon or label property"); if (t.title) { const r = "function" == typeof t.title ? t.title(e.state) : t.title; n.setAttribute("title", vl(e, r)) } return t.class && n.classList.add(t.class), t.css && (n.style.cssText += t.css), n.addEventListener("mousedown", r => { r.preventDefault(), n.classList.contains(yl + "-disabled") || t.run(e.state, e.dispatch, e, r) }), { dom: n, update: function (e) { if (t.select) { let r = t.select(e); if (n.style.display = r ? "" : "none", !r) return !1 } let r = !0; if (t.enable && (r = t.enable(e) || !1, $l(n, yl + "-disabled", !r)), t.active) { let o = r && t.active(e) || !1; $l(n, yl + "-active", o) } return !0 } } } } function vl(e, t) { return e._props.translate ? e._props.translate(t) : t } let bl = { time: 0, node: null }; function kl(e) { bl.time = Date.now(), bl.node = e.target } function xl(e) { return Date.now() - 100 < bl.time && bl.node && e.contains(bl.node) } class Sl { constructor(e, t = {}) { this.options = t, this.options = t || {}, this.content = Array.isArray(e) ? e : [e] } render(e) { let t = Cl(this.content, e), n = e.dom.ownerDocument.defaultView || window, r = pl("div", { class: yl + "-dropdown " + (this.options.class || ""), style: this.options.css }, vl(e, this.options.label || "")); this.options.title && r.setAttribute("title", vl(e, this.options.title)); let o = pl("div", { class: yl + "-dropdown-wrap" }, r), i = null, s = null, l = () => { i && i.close() && (i = null, n.removeEventListener("mousedown", s)) }; return r.addEventListener("mousedown", e => { e.preventDefault(), kl(e), i ? l() : (i = this.expand(o, t.dom), n.addEventListener("mousedown", s = () => { xl(o) || l() })) }), { dom: o, update: function (e) { let n = t.update(e); return o.style.display = n ? "" : "none", n } } } expand(e, t) { let n = pl("div", { class: yl + "-dropdown-menu " + (this.options.class || "") }, t), r = !1; return e.appendChild(n), { close: function () { return !r && (r = !0, e.removeChild(n), !0) }, node: n } } } function Cl(e, t) { let n = [], r = []; for (let o = 0; o < e.length; o++) { let { dom: i, update: s } = e[o].render(t); n.push(pl("div", { class: yl + "-dropdown-item" }, i)), r.push(s) } return { dom: n, update: Ml(r, n) } } function Ml(e, t) { return n => { let r = !1; for (let o = 0; o < e.length; o++) { let i = e[o](n); t[o].style.display = i ? "" : "none", i && (r = !0) } return r } } class Ol { constructor(e, t = {}) { this.options = t, this.content = Array.isArray(e) ? e : [e] } render(e) { let t = Cl(this.content, e), n = e.dom.ownerDocument.defaultView || window, r = pl("div", { class: yl + "-submenu-label" }, vl(e, this.options.label || "")), o = pl("div", { class: yl + "-submenu-wrap" }, r, pl("div", { class: yl + "-submenu" }, t.dom)), i = null; return r.addEventListener("mousedown", e => { e.preventDefault(), kl(e), $l(o, yl + "-submenu-wrap-active", !1), i || n.addEventListener("mousedown", i = () => { xl(o) || (o.classList.remove(yl + "-submenu-wrap-active"), n.removeEventListener("mousedown", i), i = null) }) }), { dom: o, update: function (e) { let n = t.update(e); return o.style.display = n ? "" : "none", n } } } } function Nl(e, t) { let n = document.createDocumentFragment(), r = [], o = []; for (let i = 0; i < t.length; i++) { let s = t[i], l = [], a = []; for (let t = 0; t < s.length; t++) { let { dom: r, update: o } = s[t].render(e), i = pl("span", { class: yl + "item" }, r); n.appendChild(i), a.push(i), l.push(o) } l.length && (r.push(Ml(l, a)), i < t.length - 1 && o.push(n.appendChild(Dl()))) } return { dom: n, update: function (e) { let t = !1, n = !1; for (let i = 0; i < r.length; i++) { let s = r[i](e); i && (o[i - 1].style.display = n && s ? "" : "none"), n = s, s && (t = !0) } return t } } } function Dl() { return pl("span", { class: yl + "separator" }) } const Tl = { join: { width: 800, height: 900, path: "M0 75h800v125h-800z M0 825h800v-125h-800z M250 400h100v-100h100v100h100v100h-100v100h-100v-100h-100z" }, lift: { width: 1024, height: 1024, path: "M219 310v329q0 7-5 12t-12 5q-8 0-13-5l-164-164q-5-5-5-13t5-13l164-164q5-5 13-5 7 0 12 5t5 12zM1024 749v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12zM1024 530v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 310v109q0 7-5 12t-12 5h-621q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h621q7 0 12 5t5 12zM1024 91v109q0 7-5 12t-12 5h-987q-7 0-12-5t-5-12v-109q0-7 5-12t12-5h987q7 0 12 5t5 12z" }, selectParentNode: { text: "⬚", css: "font-weight: bold" }, undo: { width: 1024, height: 1024, path: "M761 1024c113-206 132-520-313-509v253l-384-384 384-384v248c534-13 594 472 313 775z" }, redo: { width: 1024, height: 1024, path: "M576 248v-248l384 384-384 384v-253c-446-10-427 303-313 509-280-303-221-789 313-775z" }, strong: { width: 805, height: 1024, path: "M317 869q42 18 80 18 214 0 214-191 0-65-23-102-15-25-35-42t-38-26-46-14-48-6-54-1q-41 0-57 5 0 30-0 90t-0 90q0 4-0 38t-0 55 2 47 6 38zM309 442q24 4 62 4 46 0 81-7t62-25 42-51 14-81q0-40-16-70t-45-46-61-24-70-8q-28 0-74 7 0 28 2 86t2 86q0 15-0 45t-0 45q0 26 0 39zM0 950l1-53q8-2 48-9t60-15q4-6 7-15t4-19 3-18 1-21 0-19v-37q0-561-12-585-2-4-12-8t-25-6-28-4-27-2-17-1l-2-47q56-1 194-6t213-5q13 0 39 0t38 0q40 0 78 7t73 24 61 40 42 59 16 78q0 29-9 54t-22 41-36 32-41 25-48 22q88 20 146 76t58 141q0 57-20 102t-53 74-78 48-93 27-100 8q-25 0-75-1t-75-1q-60 0-175 6t-132 6z" }, em: { width: 585, height: 1024, path: "M0 949l9-48q3-1 46-12t63-21q16-20 23-57 0-4 35-165t65-310 29-169v-14q-13-7-31-10t-39-4-33-3l10-58q18 1 68 3t85 4 68 1q27 0 56-1t69-4 56-3q-2 22-10 50-17 5-58 16t-62 19q-4 10-8 24t-5 22-4 26-3 24q-15 84-50 239t-44 203q-1 5-7 33t-11 51-9 47-3 32l0 10q9 2 105 17-1 25-9 56-6 0-18 0t-18 0q-16 0-49-5t-49-5q-78-1-117-1-29 0-81 5t-69 6z" }, code: { width: 896, height: 1024, path: "M608 192l-96 96 224 224-224 224 96 96 288-320-288-320zM288 192l-288 320 288 320 96-96-224-224 224-224-96-96z" }, link: { width: 951, height: 1024, path: "M832 694q0-22-16-38l-118-118q-16-16-38-16-24 0-41 18 1 1 10 10t12 12 8 10 7 14 2 15q0 22-16 38t-38 16q-8 0-15-2t-14-7-10-8-12-12-10-10q-18 17-18 41 0 22 16 38l117 118q15 15 38 15 22 0 38-14l84-83q16-16 16-38zM430 292q0-22-16-38l-117-118q-16-16-38-16-22 0-38 15l-84 83q-16 16-16 38 0 22 16 38l118 118q15 15 38 15 24 0 41-17-1-1-10-10t-12-12-8-10-7-14-2-15q0-22 16-38t38-16q8 0 15 2t14 7 10 8 12 12 10 10q18-17 18-41zM941 694q0 68-48 116l-84 83q-47 47-116 47-69 0-116-48l-117-118q-47-47-47-116 0-70 50-119l-50-50q-49 50-118 50-68 0-116-48l-118-118q-48-48-48-116t48-116l84-83q47-47 116-47 69 0 116 48l117 118q47 47 47 116 0 70-50 119l50 50q49-50 118-50 68 0 116 48l118 118q48 48 48 116z" }, bulletList: { width: 768, height: 896, path: "M0 512h128v-128h-128v128zM0 256h128v-128h-128v128zM0 768h128v-128h-128v128zM256 512h512v-128h-512v128zM256 256h512v-128h-512v128zM256 768h512v-128h-512v128z" }, orderedList: { width: 768, height: 896, path: "M320 512h448v-128h-448v128zM320 768h448v-128h-448v128zM320 128v128h448v-128h-448zM79 384h78v-256h-36l-85 23v50l43-2v185zM189 590c0-36-12-78-96-78-33 0-64 6-83 16l1 66c21-10 42-15 67-15s32 11 32 28c0 26-30 58-110 112v50h192v-67l-91 2c49-30 87-66 87-113l1-1z" }, blockquote: { width: 640, height: 896, path: "M0 448v256h256v-256h-128c0 0 0-128 128-128v-128c0 0-256 0-256 256zM640 320v-128c0 0-256 0-256 256v256h256v-256h-128c0 0 0-128 128-128z" } }, El = new wl({ title: "Join with above block", run: ts, select: e => ts(e), icon: Tl.join }), Al = new wl({ title: "Lift out of enclosing block", run: rs, select: e => rs(e), icon: Tl.lift }), Rl = new wl({ title: "Select parent node", run: ps, select: e => ps(e), icon: Tl.selectParentNode }); let Il = new wl({ title: "Undo last change", run: Fi, enable: e => Fi(e), icon: Tl.undo }), zl = new wl({ title: "Redo last undone change", run: qi, enable: e => qi(e), icon: Tl.redo }); function Pl(e, t) { let n = { run: (n, r) => ws(e, t.attrs)(n, r), select: n => ws(e, t.attrs)(n) }; for (let e in t) n[e] = t[e]; return new wl(n) } function Bl(e, t) { let n = vs(e, t.attrs), r = { run: n, enable: e => n(e), active(n) { let { $from: r, to: o, node: i } = n.selection; return i ? i.hasMarkup(e, t.attrs) : o <= r.end() && r.parent.hasMarkup(e, t.attrs) } }; for (let e in t) r[e] = t[e]; return new wl(r) } function $l(e, t, n) { n ? e.classList.add(t) : e.classList.remove(t) } const Vl = "ProseMirror-menubar"; function Fl(e) { return new St({ view: t => new ql(t, e) }) } class ql { constructor(e, t) { this.editorView = e, this.options = t, this.spacer = null, this.maxHeight = 0, this.widthForMaxHeight = 0, this.floating = !1, this.scrollHandler = null, this.root = e.root, this.wrapper = pl("div", { class: Vl + "-wrapper" }), this.menu = this.wrapper.appendChild(pl("div", { class: Vl })), this.menu.className = Vl, e.dom.parentNode && e.dom.parentNode.replaceChild(this.wrapper, e.dom), this.wrapper.appendChild(e.dom); let { dom: n, update: r } = Nl(this.editorView, this.options.content); if (this.contentUpdate = r, this.menu.appendChild(n), this.update(), t.floating && !function () { if ("undefined" == typeof navigator) return !1; let e = navigator.userAgent; return !/Edge\/\d/.test(e) && /AppleWebKit/.test(e) && /Mobile\/\w+/.test(e) }()) { this.updateFloat(); let e = function (e) { let t = [e.ownerDocument.defaultView || window]; for (let n = e.parentNode; n; n = n.parentNode)t.push(n); return t }(this.wrapper); this.scrollHandler = t => { let n = this.editorView.root; (n.body || n).contains(this.wrapper) ? this.updateFloat(t.target.getBoundingClientRect ? t.target : void 0) : e.forEach(e => e.removeEventListener("scroll", this.scrollHandler)) }, e.forEach(e => e.addEventListener("scroll", this.scrollHandler)) } } update() { if (this.editorView.root != this.root) { let { dom: e, update: t } = Nl(this.editorView, this.options.content); this.contentUpdate = t, this.menu.replaceChild(e, this.menu.firstChild), this.root = this.editorView.root } this.contentUpdate(this.editorView.state), this.floating ? this.updateScrollCursor() : (this.menu.offsetWidth != this.widthForMaxHeight && (this.widthForMaxHeight = this.menu.offsetWidth, this.maxHeight = 0), this.menu.offsetHeight > this.maxHeight && (this.maxHeight = this.menu.offsetHeight, this.menu.style.minHeight = this.maxHeight + "px")) } updateScrollCursor() { let e = this.editorView.root.getSelection(); if (!e.focusNode) return; let t = e.getRangeAt(0).getClientRects(), n = t[function (e) { return e.anchorNode == e.focusNode ? e.anchorOffset > e.focusOffset : e.anchorNode.compareDocumentPosition(e.focusNode) == Node.DOCUMENT_POSITION_FOLLOWING }(e) ? 0 : t.length - 1]; if (!n) return; let r = this.menu.getBoundingClientRect(); if (n.top < r.bottom && n.bottom > r.top) { let e = function (e) { for (let t = e.parentNode; t; t = t.parentNode)if (t.scrollHeight > t.clientHeight) return t }(this.wrapper); e && (e.scrollTop -= r.bottom - n.top) } } updateFloat(e) { let t = this.wrapper, n = t.getBoundingClientRect(), r = e ? Math.max(0, e.getBoundingClientRect().top) : 0; if (this.floating) if (n.top >= r || n.bottom < this.menu.offsetHeight + 10) this.floating = !1, this.menu.style.position = this.menu.style.left = this.menu.style.top = this.menu.style.width = "", this.menu.style.display = "", this.spacer.parentNode.removeChild(this.spacer), this.spacer = null; else { let o = (t.offsetWidth - t.clientWidth) / 2; this.menu.style.left = n.left + o + "px", this.menu.style.display = n.top > (this.editorView.dom.ownerDocument.defaultView || window).innerHeight ? "none" : "", e && (this.menu.style.top = r + "px") } else if (n.top < r && n.bottom >= this.menu.offsetHeight + 10) { this.floating = !0; let n = this.menu.getBoundingClientRect(); this.menu.style.left = n.left + "px", this.menu.style.width = n.width + "px", e && (this.menu.style.top = r + "px"), this.menu.style.position = "fixed", this.spacer = pl("div", { class: Vl + "-spacer", style: `height: ${n.height}px` }), t.insertBefore(this.spacer, this.menu) } } destroy() { this.wrapper.parentNode && this.wrapper.parentNode.replaceChild(this.editorView.dom, this.wrapper) } } var Ll = Object.freeze({ __proto__: null, Dropdown: Sl, DropdownSubmenu: Ol, MenuItem: wl, blockTypeItem: Bl, icons: Tl, joinUpItem: El, liftItem: Al, menuBar: Fl, redoItem: zl, renderGrouped: Nl, selectParentNodeItem: Rl, undoItem: Il, wrapItem: Pl }); const _l = "ProseMirror-prompt"; function Wl(e) { let t = document.body.appendChild(document.createElement("div")); t.className = _l; let n = e => { t.contains(e.target) || r() }; setTimeout(() => window.addEventListener("mousedown", n), 50); let r = () => { window.removeEventListener("mousedown", n), t.parentNode && t.parentNode.removeChild(t) }, o = []; for (let t in e.fields) o.push(e.fields[t].render()); let i = document.createElement("button"); i.type = "submit", i.className = _l + "-submit", i.textContent = "OK"; let s = document.createElement("button"); s.type = "button", s.className = _l + "-cancel", s.textContent = "Cancel", s.addEventListener("click", r); let l = t.appendChild(document.createElement("form")); e.title && (l.appendChild(document.createElement("h5")).textContent = e.title), o.forEach(e => { l.appendChild(document.createElement("div")).appendChild(e) }); let a = l.appendChild(document.createElement("div")); a.className = _l + "-buttons", a.appendChild(i), a.appendChild(document.createTextNode(" ")), a.appendChild(s); let h = t.getBoundingClientRect(); t.style.top = (window.innerHeight - h.height) / 2 + "px", t.style.left = (window.innerWidth - h.width) / 2 + "px"; let c = () => { let t = function (e, t) { let n = Object.create(null), r = 0; for (let o in e) { let i = e[o], s = t[r++], l = i.read(s), a = i.validate(l); if (a) return Jl(s, a), null; n[o] = i.clean(l) } return n }(e.fields, o); t && (r(), e.callback(t)) }; l.addEventListener("submit", e => { e.preventDefault(), c() }), l.addEventListener("keydown", e => { 27 == e.keyCode ? (e.preventDefault(), r()) : 13 != e.keyCode || e.ctrlKey || e.metaKey || e.shiftKey ? 9 == e.keyCode && window.setTimeout(() => { t.contains(document.activeElement) || r() }, 500) : (e.preventDefault(), c()) }); let d = l.elements[0]; d && d.focus() } function Jl(e, t) { let n = e.parentNode, r = n.appendChild(document.createElement("div")); r.style.left = e.offsetLeft + e.offsetWidth + 2 + "px", r.style.top = e.offsetTop - 5 + "px", r.className = "ProseMirror-invalid", r.textContent = t, setTimeout(() => n.removeChild(r), 1500) } class jl { constructor(e) { this.options = e } read(e) { return e.value } validateType(e) { return null } validate(e) { return !e && this.options.required ? "Required field" : this.validateType(e) || (this.options.validate ? this.options.validate(e) : null) } clean(e) { return this.options.clean ? this.options.clean(e) : e } } class Kl extends jl { render() { let e = document.createElement("input"); return e.type = "text", e.placeholder = this.options.label, e.value = this.options.value || "", e.autocomplete = "off", e } } function Hl(e, t) { let n = e.selection.$from; for (let e = n.depth; e >= 0; e--) { let r = n.index(e); if (n.node(e).canReplaceWith(r, r, t)) return !0 } return !1 } function Ul(e, t) { let n = { label: t.title, run: e }; for (let e in t) n[e] = t[e]; return t.enable || t.select || (n[t.enable ? "enable" : "select"] = t => e(t)), new wl(n) } function Gl(e, t) { let { from: n, $from: r, to: o, empty: i } = e.selection; return i ? !!t.isInSet(e.storedMarks || r.marks()) : e.doc.rangeHasMark(n, o, t) } function Yl(e, t) { let n = { active: t => Gl(t, e) }; for (let e in t) n[e] = t[e]; return Ul(bs(e), n) } function Ql(e, t) { return Ul(Us(e, t.attrs), t) } function Xl(e) { let t, n = {}; var r; let o; var i; if ((t = e.marks.strong) && (n.toggleStrong = Yl(t, { title: "Toggle strong style", icon: Tl.strong })), (t = e.marks.em) && (n.toggleEm = Yl(t, { title: "Toggle emphasis", icon: Tl.em })), (t = e.marks.code) && (n.toggleCode = Yl(t, { title: "Toggle code font", icon: Tl.code })), (t = e.marks.link) && (n.toggleLink = (r = t, new wl({ title: "Add or remove link", icon: Tl.link, active: e => Gl(e, r), enable: e => !e.selection.empty, run(e, t, n) { if (Gl(e, r)) return bs(r)(e, t), !0; Wl({ title: "Create a link", fields: { href: new Kl({ label: "Link target", required: !0 }), title: new Kl({ label: "Title" }) }, callback(e) { bs(r, e)(n.state, n.dispatch), n.focus() } }) } }))), (o = e.nodes.image) && (n.insertImage = (i = o, new wl({ title: "Insert image", label: "Image", enable: e => Hl(e, i), run(e, t, n) { let { from: r, to: o } = e.selection, s = null; e.selection instanceof ct && e.selection.node.type == i && (s = e.selection.node.attrs), Wl({ title: "Insert image", fields: { src: new Kl({ label: "Location", required: !0, value: s && s.src }), title: new Kl({ label: "Title", value: s && s.title }), alt: new Kl({ label: "Description", value: s ? s.alt : e.doc.textBetween(r, o, " ") }) }, callback(e) { n.dispatch(n.state.tr.replaceSelectionWith(i.createAndFill(e))), n.focus() } }) } }))), (o = e.nodes.bullet_list) && (n.wrapBulletList = Ql(o, { title: "Wrap in bullet list", icon: Tl.bulletList })), (o = e.nodes.ordered_list) && (n.wrapOrderedList = Ql(o, { title: "Wrap in ordered list", icon: Tl.orderedList })), (o = e.nodes.blockquote) && (n.wrapBlockQuote = Pl(o, { title: "Wrap in block quote", icon: Tl.blockquote })), (o = e.nodes.paragraph) && (n.makeParagraph = Bl(o, { title: "Change to paragraph", label: "Plain" })), (o = e.nodes.code_block) && (n.makeCodeBlock = Bl(o, { title: "Change to code block", label: "Code" })), o = e.nodes.heading) for (let e = 1; e <= 10; e++)n["makeHead" + e] = Bl(o, { title: "Change to heading " + e, label: "Level " + e, attrs: { level: e } }); if (o = e.nodes.horizontal_rule) { let e = o; n.insertHorizontalRule = new wl({ title: "Insert horizontal rule", label: "Horizontal rule", enable: t => Hl(t, e), run(t, n) { n(t.tr.replaceSelectionWith(e.create())) } }) } let s = e => e.filter(e => e); return n.insertMenu = new Sl(s([n.insertImage, n.insertHorizontalRule]), { label: "Insert" }), n.typeMenu = new Sl(s([n.makeParagraph, n.makeCodeBlock, n.makeHead1 && new Ol(s([n.makeHead1, n.makeHead2, n.makeHead3, n.makeHead4, n.makeHead5, n.makeHead6]), { label: "Heading" })]), { label: "Type..." }), n.inlineMenu = [s([n.toggleStrong, n.toggleEm, n.toggleCode, n.toggleLink])], n.blockMenu = [s([n.wrapBulletList, n.wrapOrderedList, n.wrapBlockQuote, El, Al, Rl])], n.fullMenu = n.inlineMenu.concat([[n.insertMenu, n.typeMenu]], [[Il, zl]], n.blockMenu), n } const Zl = "undefined" != typeof navigator && /Mac|iP(hone|[oa]d)/.test(navigator.platform); function ea(e, t) { let n, r = {}; function o(e, n) { if (t) { let n = t[e]; if (!1 === n) return; n && (e = n) } r[e] = n } if (o("Mod-z", Fi), o("Shift-Mod-z", qi), o("Backspace", di), Zl || o("Mod-y", qi), o("Alt-ArrowUp", ts), o("Alt-ArrowDown", ns), o("Mod-BracketLeft", rs), o("Escape", ps), (n = e.marks.strong) && (o("Mod-b", bs(n)), o("Mod-B", bs(n))), (n = e.marks.em) && (o("Mod-i", bs(n)), o("Mod-I", bs(n))), (n = e.marks.code) && o("Mod-`", bs(n)), (n = e.nodes.bullet_list) && o("Shift-Ctrl-8", Us(n)), (n = e.nodes.ordered_list) && o("Shift-Ctrl-9", Us(n)), (n = e.nodes.blockquote) && o("Ctrl->", ws(n)), n = e.nodes.hard_break) { let e = n, t = xs(ls, (t, n) => (n && n(t.tr.replaceSelectionWith(e.create()).scrollIntoView()), !0)); o("Mod-Enter", t), o("Shift-Enter", t), Zl && o("Ctrl-Enter", t) } if ((n = e.nodes.list_item) && (o("Enter", Ys(n)), o("Mod-[", Qs(n)), o("Mod-]", Xs(n))), (n = e.nodes.paragraph) && o("Shift-Ctrl-0", vs(n)), (n = e.nodes.code_block) && o("Shift-Ctrl-\\", vs(n)), n = e.nodes.heading) for (let e = 1; e <= 6; e++)o("Shift-Ctrl-" + e, vs(n, { level: e })); if (n = e.nodes.horizontal_rule) { let e = n; o("Mod-_", (t, n) => (n && n(t.tr.replaceSelectionWith(e.create()).scrollIntoView()), !0)) } return r } function ta(e) { let t, n = wi.concat(ui, pi); return (t = e.nodes.blockquote) && n.push(vi(/^\s*>\s$/, t)), (t = e.nodes.ordered_list) && n.push(function (e) { return vi(/^(\d+)\.\s$/, e, e => ({ order: +e[1] }), (e, t) => t.childCount + t.attrs.order == +e[1]) }(t)), (t = e.nodes.bullet_list) && n.push(function (e) { return vi(/^\s*([-+*])\s$/, e) }(t)), (t = e.nodes.code_block) && n.push(function (e) { return bi(/^```$/, e) }(t)), (t = e.nodes.heading) && n.push(function (e, t) { return bi(new RegExp("^(#{1," + t + "})\\s$"), e, e => ({ level: e[1].length })) }(t, 6)), hi({ rules: n }) } var na = Object.freeze({ __proto__: null, buildInputRules: ta, buildKeymap: ea, buildMenuItems: Xl, exampleSetup: function (e) { let t = [ta(e.schema), ii(ea(e.schema, e.mapKeys)), ii(Ns), el(), il()]; return !1 !== e.menuBar && t.push(Fl({ floating: !1 !== e.floatingMenu, content: e.menuContent || Xl(e.schema).fullMenu })), !1 !== e.history && t.push($i()), t.concat(new St({ props: { attributes: { class: "ProseMirror-example-setup-style" } } })) } }); window.PM = { model: ce, transform: nt, state: Nt, view: Uo, keymap: li, inputrules: ki, history: Wi, commands: Ds, schema_basic: qs, schema_list: Zs, dropcursor: nl, menu: Ll, example_setup: na, gapcursor: dl } }();
