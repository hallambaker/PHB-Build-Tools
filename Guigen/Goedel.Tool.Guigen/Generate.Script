#script 1.0
#license MITLicense
#using Goedel.Utilities
#pclass Goedel.Tool.Guigen Generate

#method GenerateCS Guigen Guigen
#% Guigen._InitChildren();
##region // Copyright 
#% // Boilerplate.Header (_Output, "//  ", GenerateTime);
#foreach (var Item in Guigen.Top)
#switchcast GuigenType Item
#casecast Copyright Copyright
#switchcast GuigenType Copyright.License
#casecast MITLicense null
#% Boilerplate.MITLicense (_Output, "//  ", "Copyright (c) " + Copyright.Date, Copyright.Holder);
#casecast BSD2License null
#% Boilerplate.BSD2License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast BSD3License null
#% Boilerplate.BSD3License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast ISCLicense null
#% Boilerplate.ISCLicense (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast Apache2License null
#% Boilerplate.Apache2License (_Output, "//  ", "Copyright (c) " +  Copyright.Date, Copyright.Holder);
#casecast OtherLicense License
// Copyright (1) #{Copyright.Date} by #{Copyright.Holder}
// #{License.Text}
#end switchcast
#end switchcast
#end foreach

##endregion

using Goedel.Guigen;
using Goedel.Utilities;

namespace #{Guigen.Class.Namespace};



#foreach (var action in Guigen.Actions) 

/// <summary>
/// Callback parameters for action #{action.Id.Label} 
/// </summary>
public partial class #{action.Id.Label} : _#{action.Id.Label} {
    }


/// <summary>
/// Callback parameters for action #{action.Id.Label} 
/// </summary>
public partial class _#{action.Id.Label} : IBindable {

#call DeclareFields action

#call CreateBindings action

    public virtual bool Validate() => true;
    }

#end foreach



/// <summary>
#foreach (var text in Guigen.Class.Description)
/// #{text}
#end foreach
/// </summary>
public partial class #{Guigen.Class.Name} :  _#{Guigen.Class.Name} {



    
    }


/// <summary>
#foreach (var text in Guigen.Class.Description)
/// #{text}
#end foreach
/// </summary>
public class _#{Guigen.Class.Name} : Gui {


    ///<inheritdoc/> 
    public override List<GuiDialog> Dialogs { get; }

    ///<inheritdoc/> 
    public override List<GuiSection> Sections { get; }

    ///<inheritdoc/> 
    public override List<GuiAction> Actions { get; }


	///<inheritdoc/>
	public override List<GuiImage> Icons => icons;
	readonly List<GuiImage> icons = new () { #!
#% var separator = new Separator (",");
#foreach (var icon in Guigen.Icons) 
#{separator} 
		new GuiImage (#{icon.Key.Quoted()}) #!
#end foreach

		};


	// Sections
#foreach (var section in Guigen.Sections) 
	public GuiSection #{section.RecordId} { get; } = new (#{section.QuotedId}, #{section.Prompt.Quoted()}, #{section.Icon.Quoted()}, #{section.Primary.If("true","false")});
#end foreach

	
	// Actions
#foreach (var action in Guigen.Actions) 
	public GuiAction #{action.RecordId} { get; } = new (#{action.QuotedId}, #{action.Prompt.Quoted()}, #{action.Icon.Quoted()}, () => new #{action.Id.Label}());
#end foreach	

	// Dialogs
#foreach (var dialog in Guigen.Dialogs) 
	public GuiDialog #{dialog.RecordId} { get; } = new (#{dialog.QuotedId});
#end foreach	
	

    public _#{Guigen.Class.Name} () {


#foreach (var section in Guigen.Sections) 
	    #{section.RecordId}.Entries =  new List<ISectionEntry>() { #!
#% separator.Reset ();
#foreach (var entry in section.Entries)
#if (entry.Active)
#{separator} 
#call GenerateEntry entry
#end if 
#end foreach
		    
            };

#end foreach

        Sections = new List<GuiSection> () { #!
#% separator.Reset ();
#foreach (var section in Guigen.Sections) 
#{separator} 
		    #{section.RecordId}#!
#end foreach

            };

#foreach (var action in Guigen.Actions) 
    #{action.RecordId}.Callback = #{action.Id.Label};
	#{action.RecordId}.Entries = new List<IActionEntry>() {#!
#% separator.Reset ();
#foreach (var entry in action.Entries)
#{separator} 
#call GenerateEntry entry
#end foreach

		    };

#end foreach

    Actions = new List<GuiAction>() { #!
#% separator.Reset ();
#foreach (var action in Guigen.Actions) 
#{separator} 
		    #{action.RecordId}#!
#end foreach

		    };


#foreach (var dialog in Guigen.Dialogs) 
	#{dialog.RecordId}.Entries = new List<IDialogEntry>() {#!
#% separator.Reset ();
#foreach (var entry in dialog.Entries)
#{separator} 
#call GenerateEntry entry
#end foreach
			
		    };

#end foreach

        Dialogs = new List<GuiDialog>() { #!
#% separator.Reset ();
#foreach (var dialog in Guigen.Dialogs) 
#{separator} 
		    #{dialog.RecordId}#!
#end foreach

		    };

        }

#foreach (var action in Guigen.Actions) 
    /// <summary>
    /// GUI action
    /// </summary>
    public virtual void #{action.Id.Label} (object data) => NotYetImplemented ();

#end foreach
    
    
    /// <summary>
    /// Default action
    /// </summary>    
    void NotYetImplemented () {
        }

	}



#end method


#method DeclareFields IEntries parent
#foreach (var entry in parent.AllEntries)
#switchcast GuigenType entry
#casecast Text text

        ///<summary></summary> 
        public string #{text.Id.Label} {get; set;} 
#end switchcast
#end foreach
#end method

#method CreateBindings IEntries parent
#% var separator = new Separator (",");
#% var index = 0;
    public GuiBinding Binding => new GuiBinding (new GuiBoundProperty[] { #!
#foreach (var entry in parent.AllEntries)
#switchcast GuigenType entry
#casecast Text text
#% text.Index = index++;
#{separator} 
            new GuiBoundPropertyString (() => #{text.Id.Label}, (string value) => #{text.Id.Label} = value)#!
#end switchcast
#end foreach

            });
#end method

#method GenerateEntry _Choice entry
#switchcast GuigenType entry
#casecast Chooser chooser
#call GenerateChooser chooser
#casecast Button button
#call GenerateButton button
#casecast Dialog dialog
#call GenerateDialog dialog
#casecast Text text
#call GenerateText text
#casecast Color color
#call GenerateColor color
#casecast Size size
#call GenerateSize size
#casecast Decimal decimalv
#call GenerateDecimal decimalv
#casecast Icon icon
#call GenerateIcon icon
#end switchcast
#end method

#method GenerateChooser Chooser chooser
#% var separator = new Separator (",");
			new GuiChooser (#{chooser.QuotedId}, #{chooser.Prompt.Quoted()}, #{chooser.Icon.Quoted()}, new List<IChooserEntry>() {#!
#indent
#% separator.Reset ();
#foreach (var entry in chooser.Entries)
#{separator} 
#call GenerateEntry entry
#end foreach

			}) #!
#outdent
#end method

#method GenerateDialog Dialog dialog
#% var separator = new Separator (",");
			new GuiDialog (#{dialog.QuotedId}, new List<IDialogEntry>() {#!
#indent
#% separator.Reset ();
#foreach (var entry in dialog.Entries)
#{separator} 
#call GenerateEntry entry
#end foreach

		    }) #!
#outdent
#end method


#method GenerateButton Button field
			new GuiButton (#{field.QuotedId}, #{field.Target})#!
#end method

#method GenerateText Text field
			new GuiText (#{field.QuotedId}, #{field.Prompt.Quoted()}, #{field.Index})#!
#end method

#method GenerateColor Color field
			new GuiColor (#{field.QuotedId}, #{field.Prompt.Quoted()})#!
#end method

#method GenerateSize Size field
			new GuiSize (#{field.QuotedId}, #{field.Prompt.Quoted()})#!
#end method

#method GenerateDecimal Decimal field
			new GuiDecimal (#{field.QuotedId}, #{field.Prompt.Quoted()})#!
#end method

#method GenerateIcon Icon field
			new GuiIcon (#{field.QuotedId}, #{field.Prompt.Quoted()})#!
#end method





#method GenerateResx Guigen Guigen
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>

#foreach (var prompt in Guigen.Prompts)
  <data name="#{prompt.Value.Key}" xml:space="preserve">
    <value>#{prompt.Value.Text.XMLEscape()}</value>
    <comment>Generated by Guigen</comment>
  </data>
#end foreach

</root>


#end method

#end pclass
