
//  Copyright (c) 1988-2023 by Phill Hallam-Baker
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;




//
// Namespace Goedel.Tool.Guigen
// Class Guigen
//


// Types
//   TopTypeType
//       Copyright
//       Class
//       Section
//       Action
//       Dialog
//       Result
//       Fail
//       Group
//   TypeType
//       MITLicense
//       BSD2License
//       BSD3License
//       ISCLicense
//       Apache2License
//       OtherLicense
//       Chooser
//       Primary
//       Button
//       Decimal
//       Integer
//       Condition
//       Return
//       Color
//       Size
//       QRScan
//       Context
//       TextArea
//       Confirmation
//       List
//       Boolean
//       DataActions
//       Inherit
//       Selection
//       Hidden
//       Exception
//       Default
//       Error
//       Emoji
//       Type
//       Readonly
//       Filter
//       Width
//       DateTime
//       Range
//   IdType
//       SectionT
//       ResultT
//   NamespaceType
//       Goedel.Tool.Guigen
//   ClassType
//       Guigen
//   NameType
//       Date
//       Holder
//       License
//       Text
//       Namespace
//       Name
//       Description
//       Id
//       Prompt
//       Icon
//       Entries
//       Message
//       File
//       Max
//       Min
//       Request
//   TokenType
//       TypeT
//       MessageT
//       GroupT

#pragma warning disable IDE0022, IDE0066, IDE1006, IDE0059
namespace Goedel.Tool.Guigen {


    public enum GuigenType {
        _Top,

        Copyright,
        MITLicense,
        BSD2License,
        BSD3License,
        ISCLicense,
        Apache2License,
        OtherLicense,
        Class,
        Section,
        Action,
        Dialog,
        Result,
        Fail,
        Group,
        Icon,
        DataActions,
        Confirmation,
        Description,
        Exception,
        Default,
        Error,
        Emoji,
        Condition,
        Type,
        Button,
        Selection,
        Context,
        Return,
        Inherit,
        List,
        Chooser,
        Filter,
        Primary,
        Hidden,
        Boolean,
        Text,
        TextArea,
        Color,
        Size,
        Decimal,
        DateTime,
        Integer,
        Readonly,
        Range,
        Width,
        QRScan,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public GuigenType _Tag ();

        public _Choice _Parent;
        public Guigen _Base;

		public abstract void Serialize (StructureWriter Output, bool tag);

    	public virtual void Init (_Choice parent) {
            _Parent = parent;
            _Base ??= parent?._Base;
			}

        

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice parent) {
			Init (parent);
            _Base = parent._Base;
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Copyright : _Choice {
		public string					Date;
		public string					Holder;
        public _Choice					License;

        public override GuigenType _Tag () =>GuigenType.Copyright;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			License._InitChildren (this);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Copyright");
				}

			Output.WriteAttribute ("Date", Date);
			Output.WriteAttribute ("Holder", Holder);
	        License.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Copyright");
				}			
			}
		}

    public partial class MITLicense : _Choice {

        public override GuigenType _Tag () =>GuigenType.MITLicense;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("MITLicense");
				}

			if (tag) {
				Output.EndElement ("MITLicense");
				}			
			}
		}

    public partial class BSD2License : _Choice {

        public override GuigenType _Tag () =>GuigenType.BSD2License;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("BSD2License");
				}

			if (tag) {
				Output.EndElement ("BSD2License");
				}			
			}
		}

    public partial class BSD3License : _Choice {

        public override GuigenType _Tag () =>GuigenType.BSD3License;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("BSD3License");
				}

			if (tag) {
				Output.EndElement ("BSD3License");
				}			
			}
		}

    public partial class ISCLicense : _Choice {

        public override GuigenType _Tag () =>GuigenType.ISCLicense;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("ISCLicense");
				}

			if (tag) {
				Output.EndElement ("ISCLicense");
				}			
			}
		}

    public partial class Apache2License : _Choice {

        public override GuigenType _Tag () =>GuigenType.Apache2License;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Apache2License");
				}

			if (tag) {
				Output.EndElement ("Apache2License");
				}			
			}
		}

    public partial class OtherLicense : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override GuigenType _Tag () =>GuigenType.OtherLicense;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("OtherLicense");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("OtherLicense");
				}			
			}
		}

    public partial class Class : _Choice {
        public TOKEN<_Choice>			Namespace;
        public TOKEN<_Choice>			Name;
		public List <System.String>			Description = new List <System.String> (); 

        public override GuigenType _Tag () =>GuigenType.Class;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Class");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Name", Name.ToString());
			foreach (string _s in Description) {
				Output.WriteAttribute ("Description",_s);
				}
			if (tag) {
				Output.EndElement ("Class");
				}			
			}
		}

    public partial class Section : _Choice {
        public ID<_Choice>				Id; 
		public string					Prompt;
		public string					Icon;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Section;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Section");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Prompt", Prompt);
			Output.WriteAttribute ("Icon", Icon);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Section");
				}			
			}
		}

    public partial class Action : _Choice {
        public ID<_Choice>				Id; 
		public string					Prompt;
		public string					Icon;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Action;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Action");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Prompt", Prompt);
			Output.WriteAttribute ("Icon", Icon);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Action");
				}			
			}
		}

    public partial class Dialog : _Choice {
        public ID<_Choice>				Id; 
		public string					Prompt;
		public string					Icon;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Dialog;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Dialog");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Prompt", Prompt);
			Output.WriteAttribute ("Icon", Icon);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Dialog");
				}			
			}
		}

    public partial class Result : _Choice {
        public ID<_Choice>				Id; 
		public string					Message;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Result;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Result");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Message", Message);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Result");
				}			
			}
		}

    public partial class Fail : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Message;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Fail;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Fail");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Message", Message);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Fail");
				}			
			}
		}

    public partial class Group : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Group;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Group");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Group");
				}			
			}
		}

    public partial class Icon : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
		public string					File;

        public override GuigenType _Tag () =>GuigenType.Icon;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Icon");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.WriteAttribute ("File", File);
			if (tag) {
				Output.EndElement ("Icon");
				}			
			}
		}

    public partial class DataActions : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;

        public override GuigenType _Tag () =>GuigenType.DataActions;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("DataActions");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			if (tag) {
				Output.EndElement ("DataActions");
				}			
			}
		}

    public partial class Confirmation : _Choice {

        public override GuigenType _Tag () =>GuigenType.Confirmation;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Confirmation");
				}

			if (tag) {
				Output.EndElement ("Confirmation");
				}			
			}
		}

    public partial class Description : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override GuigenType _Tag () =>GuigenType.Description;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Description");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("Description");
				}			
			}
		}

    public partial class Exception : _Choice {
        public TOKEN<_Choice>			Id;

        public override GuigenType _Tag () =>GuigenType.Exception;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Exception");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Exception");
				}			
			}
		}

    public partial class Default : _Choice {

        public override GuigenType _Tag () =>GuigenType.Default;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Default");
				}

			if (tag) {
				Output.EndElement ("Default");
				}			
			}
		}

    public partial class Error : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Message;
		public List <System.String>			Condition = new List <System.String> (); 

        public override GuigenType _Tag () =>GuigenType.Error;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Error");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Message", Message);
			foreach (string _s in Condition) {
				Output.WriteAttribute ("Condition",_s);
				}
			if (tag) {
				Output.EndElement ("Error");
				}			
			}
		}

    public partial class Emoji : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Icon;

        public override GuigenType _Tag () =>GuigenType.Emoji;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Emoji");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Icon", Icon);
			if (tag) {
				Output.EndElement ("Emoji");
				}			
			}
		}

    public partial class Condition : _Choice {
        public TOKEN<_Choice>			Id;

        public override GuigenType _Tag () =>GuigenType.Condition;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Condition");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Condition");
				}			
			}
		}

    public partial class Type : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;

        public override GuigenType _Tag () =>GuigenType.Type;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Type");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			if (tag) {
				Output.EndElement ("Type");
				}			
			}
		}

    public partial class Button : _Choice {
        public REF<_Choice>				Id;

        public override GuigenType _Tag () =>GuigenType.Button;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Button");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Button");
				}			
			}
		}

    public partial class Selection : _Choice {
        public REF<_Choice>				Id;
		public string					Prompt;
		public string					Icon;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Selection;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Selection");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.WriteAttribute ("Icon", Icon);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Selection");
				}			
			}
		}

    public partial class Context : _Choice {
        public TOKEN<_Choice>			Id;
        public REF<_Choice>				Type;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Context;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Context");
				}

	        Output.WriteId ("Id", Id.ToString());
	        Output.WriteId ("Type", Type.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Context");
				}			
			}
		}

    public partial class Return : _Choice {
        public REF<_Choice>				Id;

        public override GuigenType _Tag () =>GuigenType.Return;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Return");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Return");
				}			
			}
		}

    public partial class Inherit : _Choice {
        public TOKEN<_Choice>			Id;

        public override GuigenType _Tag () =>GuigenType.Inherit;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Inherit");
				}

	        Output.WriteId ("Id", Id.ToString());
			if (tag) {
				Output.EndElement ("Inherit");
				}			
			}
		}

    public partial class List : _Choice {
        public ID<_Choice>				Id; 
        public TOKEN<_Choice>			Type;
		public string					Prompt;
		public string					Icon;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.List;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("List");
				}

	        Output.WriteId ("Id", Id.ToString()); 
	        Output.WriteId ("Type", Type.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.WriteAttribute ("Icon", Icon);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("List");
				}			
			}
		}

    public partial class Chooser : _Choice {
        public ID<_Choice>				Id; 
		public string					Prompt;
		public string					Icon;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Chooser;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Chooser");
				}

	        Output.WriteId ("Id", Id.ToString()); 
			Output.WriteAttribute ("Prompt", Prompt);
			Output.WriteAttribute ("Icon", Icon);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Chooser");
				}			
			}
		}

    public partial class Filter : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Filter;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Filter");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Filter");
				}			
			}
		}

    public partial class Primary : _Choice {

        public override GuigenType _Tag () =>GuigenType.Primary;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Primary");
				}

			if (tag) {
				Output.EndElement ("Primary");
				}			
			}
		}

    public partial class Hidden : _Choice {
        public TOKEN<_Choice>			Id;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Hidden;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Hidden");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Hidden");
				}			
			}
		}

    public partial class Boolean : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Boolean;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Boolean");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Boolean");
				}			
			}
		}

    public partial class Text : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Text;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Text");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Text");
				}			
			}
		}

    public partial class TextArea : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.TextArea;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("TextArea");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("TextArea");
				}			
			}
		}

    public partial class Color : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Color;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Color");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Color");
				}			
			}
		}

    public partial class Size : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Size;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Size");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Size");
				}			
			}
		}

    public partial class Decimal : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Decimal;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Decimal");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Decimal");
				}			
			}
		}

    public partial class DateTime : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.DateTime;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("DateTime");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("DateTime");
				}			
			}
		}

    public partial class Integer : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Integer;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Integer");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Integer");
				}			
			}
		}

    public partial class Readonly : _Choice {

        public override GuigenType _Tag () =>GuigenType.Readonly;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Readonly");
				}

			if (tag) {
				Output.EndElement ("Readonly");
				}			
			}
		}

    public partial class Range : _Choice {
		public int						Max;
		public int						Min;

        public override GuigenType _Tag () =>GuigenType.Range;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Range");
				}

			Output.WriteAttribute ("Max", Max);
			Output.WriteAttribute ("Min", Min);
			if (tag) {
				Output.EndElement ("Range");
				}			
			}
		}

    public partial class Width : _Choice {
		public int						Request;

        public override GuigenType _Tag () =>GuigenType.Width;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Width");
				}

			Output.WriteAttribute ("Request", Request);
			if (tag) {
				Output.EndElement ("Width");
				}			
			}
		}

    public partial class QRScan : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.QRScan;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("QRScan");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("QRScan");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() =>  Label = null;

        public override GuigenType _Tag () => GuigenType._Label;

		public override void Serialize (StructureWriter Output, bool tag) =>Output.WriteId ("ID", Label.ToString());
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Copyright_Start,
		Copyright__Date,				
		Copyright__Holder,				
		Copyright__License,				
		MITLicense_Start,
		BSD2License_Start,
		BSD3License_Start,
		ISCLicense_Start,
		Apache2License_Start,
		OtherLicense_Start,
		OtherLicense__Text,				
		Class_Start,
		Class__Namespace,				
		Class__Name,				
		Class__Description,				
		Section_Start,
		Section__Id,				
		Section__Prompt,				
		Section__Icon,				
		Section__Entries,				
		Action_Start,
		Action__Id,				
		Action__Prompt,				
		Action__Icon,				
		Action__Entries,				
		Dialog_Start,
		Dialog__Id,				
		Dialog__Prompt,				
		Dialog__Icon,				
		Dialog__Entries,				
		Result_Start,
		Result__Id,				
		Result__Message,				
		Result__Entries,				
		Fail_Start,
		Fail__Id,				
		Fail__Message,				
		Fail__Entries,				
		Group_Start,
		Group__Id,				
		Group__Entries,				
		Icon_Start,
		Icon__Id,				
		Icon__Prompt,				
		Icon__File,				
		DataActions_Start,
		DataActions__Id,				
		DataActions__Prompt,				
		Confirmation_Start,
		Description_Start,
		Description__Text,				
		Exception_Start,
		Exception__Id,				
		Default_Start,
		Error_Start,
		Error__Id,				
		Error__Message,				
		Error__Condition,				
		Emoji_Start,
		Emoji__Id,				
		Emoji__Icon,				
		Condition_Start,
		Condition__Id,				
		Type_Start,
		Type__Id,				
		Type__Prompt,				
		Button_Start,
		Button__Id,				
		Selection_Start,
		Selection__Id,				
		Selection__Prompt,				
		Selection__Icon,				
		Selection__Entries,				
		Context_Start,
		Context__Id,				
		Context__Type,				
		Context__Entries,				
		Return_Start,
		Return__Id,				
		Inherit_Start,
		Inherit__Id,				
		List_Start,
		List__Id,				
		List__Type,				
		List__Prompt,				
		List__Icon,				
		List__Entries,				
		Chooser_Start,
		Chooser__Id,				
		Chooser__Prompt,				
		Chooser__Icon,				
		Chooser__Entries,				
		Filter_Start,
		Filter__Id,				
		Filter__Prompt,				
		Filter__Entries,				
		Primary_Start,
		Hidden_Start,
		Hidden__Id,				
		Hidden__Entries,				
		Boolean_Start,
		Boolean__Id,				
		Boolean__Prompt,				
		Boolean__Entries,				
		Text_Start,
		Text__Id,				
		Text__Prompt,				
		Text__Entries,				
		TextArea_Start,
		TextArea__Id,				
		TextArea__Prompt,				
		TextArea__Entries,				
		Color_Start,
		Color__Id,				
		Color__Prompt,				
		Color__Entries,				
		Size_Start,
		Size__Id,				
		Size__Prompt,				
		Size__Entries,				
		Decimal_Start,
		Decimal__Id,				
		Decimal__Prompt,				
		Decimal__Entries,				
		DateTime_Start,
		DateTime__Id,				
		DateTime__Prompt,				
		DateTime__Entries,				
		Integer_Start,
		Integer__Id,				
		Integer__Prompt,				
		Integer__Entries,				
		Readonly_Start,
		Range_Start,
		Range__Max,				
		Range__Min,				
		Width_Start,
		Width__Request,				
		QRScan_Start,
		QRScan__Id,				
		QRScan__Prompt,				
		QRScan__Entries,				
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Tool.Guigen._Choice     Token;
        }

    public partial class Guigen : Goedel.Registry.Parser{
        public List <Goedel.Tool.Guigen._Choice>        Top;
        public Registry	<Goedel.Tool.Guigen._Choice>	Registry;

        public bool StartOfEntry {get;  private set;}

        StateCode								State;
        Goedel.Tool.Guigen._Choice				Current;
        List <_StackItem>						Stack;


        public static Guigen Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new Guigen() {
				Options = Options
				};

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
            Result.Init ();
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
                Entry._Base = this;
				Entry._InitChildren (null);
				}
			}

        public Guigen() {
            Top = new List<Goedel.Tool.Guigen._Choice> () ;
            Registry = new Registry <Goedel.Tool.Guigen._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            StartOfEntry = true;

			TYPE__SectionT = Registry.TYPE ("SectionT"); 
			TYPE__ResultT = Registry.TYPE ("ResultT"); 
			TYPE__TypeT = Registry.TYPE ("TypeT"); 
			TYPE__MessageT = Registry.TYPE ("MessageT"); 
			TYPE__GroupT = Registry.TYPE ("GroupT"); 



            }



        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__SectionT ;
        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__ResultT ;
        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__TypeT ;
        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__MessageT ;
        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__GroupT ;

        private Goedel.Tool.Guigen._Choice New_Choice(string Label) {
            switch (Label) {

                case "Copyright": return NewCopyright();
                case "MITLicense": return NewMITLicense();
                case "BSD2License": return NewBSD2License();
                case "BSD3License": return NewBSD3License();
                case "ISCLicense": return NewISCLicense();
                case "Apache2License": return NewApache2License();
                case "OtherLicense": return NewOtherLicense();
                case "Class": return NewClass();
                case "Section": return NewSection();
                case "Action": return NewAction();
                case "Dialog": return NewDialog();
                case "Result": return NewResult();
                case "Fail": return NewFail();
                case "Group": return NewGroup();
                case "Icon": return NewIcon();
                case "DataActions": return NewDataActions();
                case "Confirmation": return NewConfirmation();
                case "Description": return NewDescription();
                case "Exception": return NewException();
                case "Default": return NewDefault();
                case "Error": return NewError();
                case "Emoji": return NewEmoji();
                case "Condition": return NewCondition();
                case "Type": return NewType();
                case "Button": return NewButton();
                case "Selection": return NewSelection();
                case "Context": return NewContext();
                case "Return": return NewReturn();
                case "Inherit": return NewInherit();
                case "List": return NewList();
                case "Chooser": return NewChooser();
                case "Filter": return NewFilter();
                case "Primary": return NewPrimary();
                case "Hidden": return NewHidden();
                case "Boolean": return NewBoolean();
                case "Text": return NewText();
                case "TextArea": return NewTextArea();
                case "Color": return NewColor();
                case "Size": return NewSize();
                case "Decimal": return NewDecimal();
                case "DateTime": return NewDateTime();
                case "Integer": return NewInteger();
                case "Readonly": return NewReadonly();
                case "Range": return NewRange();
                case "Width": return NewWidth();
                case "QRScan": return NewQRScan();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Tool.Guigen.Copyright NewCopyright() {
            Goedel.Tool.Guigen.Copyright result = new Goedel.Tool.Guigen.Copyright();
            Push (result);
            State = StateCode.Copyright_Start;
            return result;
            }


        private Goedel.Tool.Guigen.MITLicense NewMITLicense() {
            Goedel.Tool.Guigen.MITLicense result = new Goedel.Tool.Guigen.MITLicense();
            Push (result);
            State = StateCode.MITLicense_Start;
            return result;
            }


        private Goedel.Tool.Guigen.BSD2License NewBSD2License() {
            Goedel.Tool.Guigen.BSD2License result = new Goedel.Tool.Guigen.BSD2License();
            Push (result);
            State = StateCode.BSD2License_Start;
            return result;
            }


        private Goedel.Tool.Guigen.BSD3License NewBSD3License() {
            Goedel.Tool.Guigen.BSD3License result = new Goedel.Tool.Guigen.BSD3License();
            Push (result);
            State = StateCode.BSD3License_Start;
            return result;
            }


        private Goedel.Tool.Guigen.ISCLicense NewISCLicense() {
            Goedel.Tool.Guigen.ISCLicense result = new Goedel.Tool.Guigen.ISCLicense();
            Push (result);
            State = StateCode.ISCLicense_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Apache2License NewApache2License() {
            Goedel.Tool.Guigen.Apache2License result = new Goedel.Tool.Guigen.Apache2License();
            Push (result);
            State = StateCode.Apache2License_Start;
            return result;
            }


        private Goedel.Tool.Guigen.OtherLicense NewOtherLicense() {
            Goedel.Tool.Guigen.OtherLicense result = new Goedel.Tool.Guigen.OtherLicense();
            Push (result);
            State = StateCode.OtherLicense_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Class NewClass() {
            Goedel.Tool.Guigen.Class result = new Goedel.Tool.Guigen.Class();
            Push (result);
            State = StateCode.Class_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Section NewSection() {
            Goedel.Tool.Guigen.Section result = new Goedel.Tool.Guigen.Section();
            Push (result);
            State = StateCode.Section_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Action NewAction() {
            Goedel.Tool.Guigen.Action result = new Goedel.Tool.Guigen.Action();
            Push (result);
            State = StateCode.Action_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Dialog NewDialog() {
            Goedel.Tool.Guigen.Dialog result = new Goedel.Tool.Guigen.Dialog();
            Push (result);
            State = StateCode.Dialog_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Result NewResult() {
            Goedel.Tool.Guigen.Result result = new Goedel.Tool.Guigen.Result();
            Push (result);
            State = StateCode.Result_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Fail NewFail() {
            Goedel.Tool.Guigen.Fail result = new Goedel.Tool.Guigen.Fail();
            Push (result);
            State = StateCode.Fail_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Group NewGroup() {
            Goedel.Tool.Guigen.Group result = new Goedel.Tool.Guigen.Group();
            Push (result);
            State = StateCode.Group_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Icon NewIcon() {
            Goedel.Tool.Guigen.Icon result = new Goedel.Tool.Guigen.Icon();
            Push (result);
            State = StateCode.Icon_Start;
            return result;
            }


        private Goedel.Tool.Guigen.DataActions NewDataActions() {
            Goedel.Tool.Guigen.DataActions result = new Goedel.Tool.Guigen.DataActions();
            Push (result);
            State = StateCode.DataActions_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Confirmation NewConfirmation() {
            Goedel.Tool.Guigen.Confirmation result = new Goedel.Tool.Guigen.Confirmation();
            Push (result);
            State = StateCode.Confirmation_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Description NewDescription() {
            Goedel.Tool.Guigen.Description result = new Goedel.Tool.Guigen.Description();
            Push (result);
            State = StateCode.Description_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Exception NewException() {
            Goedel.Tool.Guigen.Exception result = new Goedel.Tool.Guigen.Exception();
            Push (result);
            State = StateCode.Exception_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Default NewDefault() {
            Goedel.Tool.Guigen.Default result = new Goedel.Tool.Guigen.Default();
            Push (result);
            State = StateCode.Default_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Error NewError() {
            Goedel.Tool.Guigen.Error result = new Goedel.Tool.Guigen.Error();
            Push (result);
            State = StateCode.Error_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Emoji NewEmoji() {
            Goedel.Tool.Guigen.Emoji result = new Goedel.Tool.Guigen.Emoji();
            Push (result);
            State = StateCode.Emoji_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Condition NewCondition() {
            Goedel.Tool.Guigen.Condition result = new Goedel.Tool.Guigen.Condition();
            Push (result);
            State = StateCode.Condition_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Type NewType() {
            Goedel.Tool.Guigen.Type result = new Goedel.Tool.Guigen.Type();
            Push (result);
            State = StateCode.Type_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Button NewButton() {
            Goedel.Tool.Guigen.Button result = new Goedel.Tool.Guigen.Button();
            Push (result);
            State = StateCode.Button_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Selection NewSelection() {
            Goedel.Tool.Guigen.Selection result = new Goedel.Tool.Guigen.Selection();
            Push (result);
            State = StateCode.Selection_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Context NewContext() {
            Goedel.Tool.Guigen.Context result = new Goedel.Tool.Guigen.Context();
            Push (result);
            State = StateCode.Context_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Return NewReturn() {
            Goedel.Tool.Guigen.Return result = new Goedel.Tool.Guigen.Return();
            Push (result);
            State = StateCode.Return_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Inherit NewInherit() {
            Goedel.Tool.Guigen.Inherit result = new Goedel.Tool.Guigen.Inherit();
            Push (result);
            State = StateCode.Inherit_Start;
            return result;
            }


        private Goedel.Tool.Guigen.List NewList() {
            Goedel.Tool.Guigen.List result = new Goedel.Tool.Guigen.List();
            Push (result);
            State = StateCode.List_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Chooser NewChooser() {
            Goedel.Tool.Guigen.Chooser result = new Goedel.Tool.Guigen.Chooser();
            Push (result);
            State = StateCode.Chooser_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Filter NewFilter() {
            Goedel.Tool.Guigen.Filter result = new Goedel.Tool.Guigen.Filter();
            Push (result);
            State = StateCode.Filter_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Primary NewPrimary() {
            Goedel.Tool.Guigen.Primary result = new Goedel.Tool.Guigen.Primary();
            Push (result);
            State = StateCode.Primary_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Hidden NewHidden() {
            Goedel.Tool.Guigen.Hidden result = new Goedel.Tool.Guigen.Hidden();
            Push (result);
            State = StateCode.Hidden_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Boolean NewBoolean() {
            Goedel.Tool.Guigen.Boolean result = new Goedel.Tool.Guigen.Boolean();
            Push (result);
            State = StateCode.Boolean_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Text NewText() {
            Goedel.Tool.Guigen.Text result = new Goedel.Tool.Guigen.Text();
            Push (result);
            State = StateCode.Text_Start;
            return result;
            }


        private Goedel.Tool.Guigen.TextArea NewTextArea() {
            Goedel.Tool.Guigen.TextArea result = new Goedel.Tool.Guigen.TextArea();
            Push (result);
            State = StateCode.TextArea_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Color NewColor() {
            Goedel.Tool.Guigen.Color result = new Goedel.Tool.Guigen.Color();
            Push (result);
            State = StateCode.Color_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Size NewSize() {
            Goedel.Tool.Guigen.Size result = new Goedel.Tool.Guigen.Size();
            Push (result);
            State = StateCode.Size_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Decimal NewDecimal() {
            Goedel.Tool.Guigen.Decimal result = new Goedel.Tool.Guigen.Decimal();
            Push (result);
            State = StateCode.Decimal_Start;
            return result;
            }


        private Goedel.Tool.Guigen.DateTime NewDateTime() {
            Goedel.Tool.Guigen.DateTime result = new Goedel.Tool.Guigen.DateTime();
            Push (result);
            State = StateCode.DateTime_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Integer NewInteger() {
            Goedel.Tool.Guigen.Integer result = new Goedel.Tool.Guigen.Integer();
            Push (result);
            State = StateCode.Integer_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Readonly NewReadonly() {
            Goedel.Tool.Guigen.Readonly result = new Goedel.Tool.Guigen.Readonly();
            Push (result);
            State = StateCode.Readonly_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Range NewRange() {
            Goedel.Tool.Guigen.Range result = new Goedel.Tool.Guigen.Range();
            Push (result);
            State = StateCode.Range_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Width NewWidth() {
            Goedel.Tool.Guigen.Width result = new Goedel.Tool.Guigen.Width();
            Push (result);
            State = StateCode.Width_Start;
            return result;
            }


        private Goedel.Tool.Guigen.QRScan NewQRScan() {
            Goedel.Tool.Guigen.QRScan result = new Goedel.Tool.Guigen.QRScan();
            Push (result);
            State = StateCode.QRScan_Start;
            return result;
            }


        static Goedel.Tool.Guigen.GuigenType _Reserved(string Label) {
            switch (Label) {

                case "Copyright": return Goedel.Tool.Guigen.GuigenType.Copyright;
                case "MITLicense": return Goedel.Tool.Guigen.GuigenType.MITLicense;
                case "BSD2License": return Goedel.Tool.Guigen.GuigenType.BSD2License;
                case "BSD3License": return Goedel.Tool.Guigen.GuigenType.BSD3License;
                case "ISCLicense": return Goedel.Tool.Guigen.GuigenType.ISCLicense;
                case "Apache2License": return Goedel.Tool.Guigen.GuigenType.Apache2License;
                case "OtherLicense": return Goedel.Tool.Guigen.GuigenType.OtherLicense;
                case "Class": return Goedel.Tool.Guigen.GuigenType.Class;
                case "Section": return Goedel.Tool.Guigen.GuigenType.Section;
                case "Action": return Goedel.Tool.Guigen.GuigenType.Action;
                case "Dialog": return Goedel.Tool.Guigen.GuigenType.Dialog;
                case "Result": return Goedel.Tool.Guigen.GuigenType.Result;
                case "Fail": return Goedel.Tool.Guigen.GuigenType.Fail;
                case "Group": return Goedel.Tool.Guigen.GuigenType.Group;
                case "Icon": return Goedel.Tool.Guigen.GuigenType.Icon;
                case "DataActions": return Goedel.Tool.Guigen.GuigenType.DataActions;
                case "Confirmation": return Goedel.Tool.Guigen.GuigenType.Confirmation;
                case "Description": return Goedel.Tool.Guigen.GuigenType.Description;
                case "Exception": return Goedel.Tool.Guigen.GuigenType.Exception;
                case "Default": return Goedel.Tool.Guigen.GuigenType.Default;
                case "Error": return Goedel.Tool.Guigen.GuigenType.Error;
                case "Emoji": return Goedel.Tool.Guigen.GuigenType.Emoji;
                case "Condition": return Goedel.Tool.Guigen.GuigenType.Condition;
                case "Type": return Goedel.Tool.Guigen.GuigenType.Type;
                case "Button": return Goedel.Tool.Guigen.GuigenType.Button;
                case "Selection": return Goedel.Tool.Guigen.GuigenType.Selection;
                case "Context": return Goedel.Tool.Guigen.GuigenType.Context;
                case "Return": return Goedel.Tool.Guigen.GuigenType.Return;
                case "Inherit": return Goedel.Tool.Guigen.GuigenType.Inherit;
                case "List": return Goedel.Tool.Guigen.GuigenType.List;
                case "Chooser": return Goedel.Tool.Guigen.GuigenType.Chooser;
                case "Filter": return Goedel.Tool.Guigen.GuigenType.Filter;
                case "Primary": return Goedel.Tool.Guigen.GuigenType.Primary;
                case "Hidden": return Goedel.Tool.Guigen.GuigenType.Hidden;
                case "Boolean": return Goedel.Tool.Guigen.GuigenType.Boolean;
                case "Text": return Goedel.Tool.Guigen.GuigenType.Text;
                case "TextArea": return Goedel.Tool.Guigen.GuigenType.TextArea;
                case "Color": return Goedel.Tool.Guigen.GuigenType.Color;
                case "Size": return Goedel.Tool.Guigen.GuigenType.Size;
                case "Decimal": return Goedel.Tool.Guigen.GuigenType.Decimal;
                case "DateTime": return Goedel.Tool.Guigen.GuigenType.DateTime;
                case "Integer": return Goedel.Tool.Guigen.GuigenType.Integer;
                case "Readonly": return Goedel.Tool.Guigen.GuigenType.Readonly;
                case "Range": return Goedel.Tool.Guigen.GuigenType.Range;
                case "Width": return Goedel.Tool.Guigen.GuigenType.Width;
                case "QRScan": return Goedel.Tool.Guigen.GuigenType.QRScan;

                }
            return Goedel.Tool.Guigen.GuigenType._Bottom;
            }


		public void Serialize (TextWriter Output)=> Serialize (Output, OutputFormat.Goedel);

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Tool.Guigen._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Tool.Guigen._Choice Token) {
            _StackItem Item = new _StackItem () {
					State = State,
					Token = Current
					};

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.AssertFalse (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.AssertFalse (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Copyright) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Class) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Section) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Action) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Dialog) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Result) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Fail) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Group)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) { 
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Copyright_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Copyright Current_Cast = (Goedel.Tool.Guigen.Copyright)Current;
                            Current_Cast.Date = Text;
                            State = StateCode.Copyright__Date;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Copyright__Date:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Copyright Current_Cast = (Goedel.Tool.Guigen.Copyright)Current;
                            Current_Cast.Holder = Text;
                            State = StateCode.Copyright__Holder;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Copyright__Holder:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Copyright Current_Cast = (Goedel.Tool.Guigen.Copyright)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.MITLicense) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.BSD2License) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.BSD3License) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.ISCLicense) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Apache2License) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.OtherLicense) ) {
                                State = StateCode.Copyright__License;
                                Current_Cast.License = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [MITLicense BSD2License BSD3License ISCLicense Apache2License OtherLicense ]");
                                }
                            break;
                            }
                        else { 
						    throw new Expected("Parser Error Expected [MITLicense BSD2License BSD3License ISCLicense Apache2License OtherLicense ]");
                            }

                    case StateCode.Copyright__License:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.MITLicense_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.BSD2License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.BSD3License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.ISCLicense_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Apache2License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OtherLicense_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.OtherLicense__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.OtherLicense__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Guigen.OtherLicense Current_Cast = (Goedel.Tool.Guigen.OtherLicense)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Class_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Class Current_Cast = (Goedel.Tool.Guigen.Class)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__TypeT, Current_Cast);
                            State = StateCode.Class__Namespace;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Class__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Class Current_Cast = (Goedel.Tool.Guigen.Class)Current;
                            Current_Cast.Name = Registry.TOKEN(Position, Text, TYPE__TypeT, Current_Cast);
                            State = StateCode.Class__Name;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Class__Name:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Class__Description;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Class__Description:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Guigen.Class Current_Cast = (Goedel.Tool.Guigen.Class)Current;
                            Current_Cast.Description.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Section_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Section Current_Cast = (Goedel.Tool.Guigen.Section)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Section__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Section__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Section Current_Cast = (Goedel.Tool.Guigen.Section)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Section__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Section__Prompt:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Section Current_Cast = (Goedel.Tool.Guigen.Section)Current;
                            Current_Cast.Icon = Text;
                            State = StateCode.Section__Icon;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Section__Icon:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Section__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Section__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Section Current_Cast = (Goedel.Tool.Guigen.Section)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Chooser) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Primary) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Button) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Text) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Decimal) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Integer) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Condition) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Return) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Section) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Color) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Size) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.QRScan) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Chooser Primary Button Text Decimal Integer Condition Return Description Section Color Size QRScan ]");
								}
							}
                        break;


                    case StateCode.Action_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Action Current_Cast = (Goedel.Tool.Guigen.Action)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Action__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Action__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Action Current_Cast = (Goedel.Tool.Guigen.Action)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Action__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Action__Prompt:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Action Current_Cast = (Goedel.Tool.Guigen.Action)Current;
                            Current_Cast.Icon = Text;
                            State = StateCode.Action__Icon;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Action__Icon:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Action__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Action__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Action Current_Cast = (Goedel.Tool.Guigen.Action)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Chooser) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Text) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Color) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Size) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Decimal) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Integer) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Context) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Return) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.TextArea) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.QRScan) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Confirmation) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Chooser Text Color Size Decimal Integer Context Return Description TextArea QRScan Confirmation ]");
								}
							}
                        break;


                    case StateCode.Dialog_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Dialog Current_Cast = (Goedel.Tool.Guigen.Dialog)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Dialog__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Dialog__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Dialog Current_Cast = (Goedel.Tool.Guigen.Dialog)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Dialog__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Dialog__Prompt:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Dialog Current_Cast = (Goedel.Tool.Guigen.Dialog)Current;
                            Current_Cast.Icon = Text;
                            State = StateCode.Dialog__Icon;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Dialog__Icon:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Dialog__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Dialog__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Dialog Current_Cast = (Goedel.Tool.Guigen.Dialog)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Button) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Chooser) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.List) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Boolean) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Text) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Color) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Size) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Decimal) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Integer) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Icon) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Condition) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.DataActions) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Inherit) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.TextArea) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.QRScan) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Context) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Selection) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Button Chooser List Boolean Text Color Size Decimal Integer Icon Description Condition DataActions Inherit TextArea QRScan Context Selection ]");
								}
							}
                        break;


                    case StateCode.Result_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Result Current_Cast = (Goedel.Tool.Guigen.Result)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Result__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Result__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Result Current_Cast = (Goedel.Tool.Guigen.Result)Current;
                            Current_Cast.Message = Text;
                            State = StateCode.Result__Message;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Result__Message:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Result__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Result__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Result Current_Cast = (Goedel.Tool.Guigen.Result)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Text) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Decimal) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Integer) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Icon) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Hidden) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Text Decimal Integer Icon Hidden Description ]");
								}
							}
                        break;


                    case StateCode.Fail_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Fail Current_Cast = (Goedel.Tool.Guigen.Fail)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Fail__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Fail__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Fail Current_Cast = (Goedel.Tool.Guigen.Fail)Current;
                            Current_Cast.Message = Text;
                            State = StateCode.Fail__Message;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Fail__Message:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Fail__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Fail__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Fail Current_Cast = (Goedel.Tool.Guigen.Fail)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Exception) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Default) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Integer) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Hidden) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Text) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Exception Default Integer Hidden Text Description ]");
								}
							}
                        break;


                    case StateCode.Group_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Group Current_Cast = (Goedel.Tool.Guigen.Group)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__GroupT, Current_Cast);
                            State = StateCode.Group__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Group__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Group__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Group__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Group Current_Cast = (Goedel.Tool.Guigen.Group)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Icon) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Icon ]");
								}
							}
                        break;


                    case StateCode.Icon_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Icon Current_Cast = (Goedel.Tool.Guigen.Icon)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Icon__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Icon__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Icon Current_Cast = (Goedel.Tool.Guigen.Icon)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Icon__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Icon__Prompt:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Icon Current_Cast = (Goedel.Tool.Guigen.Icon)Current;
                            Current_Cast.File = Text;
                            State = StateCode.Icon__File;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Icon__File:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.DataActions_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.DataActions Current_Cast = (Goedel.Tool.Guigen.DataActions)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.DataActions__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.DataActions__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.DataActions Current_Cast = (Goedel.Tool.Guigen.DataActions)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.DataActions__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.DataActions__Prompt:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Confirmation_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Description_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Description__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Description__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Guigen.Description Current_Cast = (Goedel.Tool.Guigen.Description)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Exception_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Exception Current_Cast = (Goedel.Tool.Guigen.Exception)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Exception__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Exception__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Default_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Error_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Error Current_Cast = (Goedel.Tool.Guigen.Error)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Error__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Error__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Error Current_Cast = (Goedel.Tool.Guigen.Error)Current;
                            Current_Cast.Message = Text;
                            State = StateCode.Error__Message;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Error__Message:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Error__Condition;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Error__Condition:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Guigen.Error Current_Cast = (Goedel.Tool.Guigen.Error)Current;
                            Current_Cast.Condition.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Emoji_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Emoji Current_Cast = (Goedel.Tool.Guigen.Emoji)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__MessageT, Current_Cast);
                            State = StateCode.Emoji__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Emoji__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Emoji Current_Cast = (Goedel.Tool.Guigen.Emoji)Current;
                            Current_Cast.Icon = Text;
                            State = StateCode.Emoji__Icon;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Emoji__Icon:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Condition_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Condition Current_Cast = (Goedel.Tool.Guigen.Condition)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Condition__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Condition__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Type_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Type Current_Cast = (Goedel.Tool.Guigen.Type)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Type__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Type__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Type Current_Cast = (Goedel.Tool.Guigen.Type)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Type__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Type__Prompt:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Button_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Button Current_Cast = (Goedel.Tool.Guigen.Button)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Button__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Button__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Selection_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Selection Current_Cast = (Goedel.Tool.Guigen.Selection)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Selection__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Selection__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Selection Current_Cast = (Goedel.Tool.Guigen.Selection)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Selection__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Selection__Prompt:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Selection Current_Cast = (Goedel.Tool.Guigen.Selection)Current;
                            Current_Cast.Icon = Text;
                            State = StateCode.Selection__Icon;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Selection__Icon:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Selection__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Selection__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Selection Current_Cast = (Goedel.Tool.Guigen.Selection)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Context_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Context Current_Cast = (Goedel.Tool.Guigen.Context)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Context__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Context__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Context Current_Cast = (Goedel.Tool.Guigen.Context)Current;
                            Current_Cast.Type = Registry.REF(Position, Text, TYPE__TypeT, Current_Cast);
                            State = StateCode.Context__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Context__Type:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Context__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Context__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Context Current_Cast = (Goedel.Tool.Guigen.Context)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Return_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Return Current_Cast = (Goedel.Tool.Guigen.Return)Current;
                            Current_Cast.Id = Registry.REF(Position, Text, TYPE__ResultT, Current_Cast);
                            State = StateCode.Return__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Return__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Inherit_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Inherit Current_Cast = (Goedel.Tool.Guigen.Inherit)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Inherit__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Inherit__Id:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.List_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.List Current_Cast = (Goedel.Tool.Guigen.List)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.List__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.List__Id:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.List Current_Cast = (Goedel.Tool.Guigen.List)Current;
                            Current_Cast.Type = Registry.TOKEN(Position, Text, TYPE__TypeT, Current_Cast);
                            State = StateCode.List__Type;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.List__Type:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.List Current_Cast = (Goedel.Tool.Guigen.List)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.List__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.List__Prompt:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.List Current_Cast = (Goedel.Tool.Guigen.List)Current;
                            Current_Cast.Icon = Text;
                            State = StateCode.List__Icon;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.List__Icon:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.List__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.List__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.List Current_Cast = (Goedel.Tool.Guigen.List)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Button) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Button ]");
								}
							}
                        break;


                    case StateCode.Chooser_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Chooser Current_Cast = (Goedel.Tool.Guigen.Chooser)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Chooser__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Chooser__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Chooser Current_Cast = (Goedel.Tool.Guigen.Chooser)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Chooser__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Chooser__Prompt:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Chooser Current_Cast = (Goedel.Tool.Guigen.Chooser)Current;
                            Current_Cast.Icon = Text;
                            State = StateCode.Chooser__Icon;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Chooser__Icon:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Chooser__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Chooser__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Chooser Current_Cast = (Goedel.Tool.Guigen.Chooser)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Button) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Text) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Filter) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Primary) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Button Readonly Text Filter Primary ]");
								}
							}
                        break;


                    case StateCode.Filter_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Filter Current_Cast = (Goedel.Tool.Guigen.Filter)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Filter__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Filter__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Filter Current_Cast = (Goedel.Tool.Guigen.Filter)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Filter__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Filter__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Filter__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Filter__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Filter Current_Cast = (Goedel.Tool.Guigen.Filter)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly ]");
								}
							}
                        break;


                    case StateCode.Primary_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Hidden_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Hidden Current_Cast = (Goedel.Tool.Guigen.Hidden)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Hidden__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Hidden__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Hidden__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Hidden__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Hidden Current_Cast = (Goedel.Tool.Guigen.Hidden)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Description) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Description ]");
								}
							}
                        break;


                    case StateCode.Boolean_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Boolean Current_Cast = (Goedel.Tool.Guigen.Boolean)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Boolean__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Boolean__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Boolean Current_Cast = (Goedel.Tool.Guigen.Boolean)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Boolean__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Boolean__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Boolean__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Boolean__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Boolean Current_Cast = (Goedel.Tool.Guigen.Boolean)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error ]");
								}
							}
                        break;


                    case StateCode.Text_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Text Current_Cast = (Goedel.Tool.Guigen.Text)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Text__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Text__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Text Current_Cast = (Goedel.Tool.Guigen.Text)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Text__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Text__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Text__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Text__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Text Current_Cast = (Goedel.Tool.Guigen.Text)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Primary) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Width) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error Primary Width ]");
								}
							}
                        break;


                    case StateCode.TextArea_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.TextArea Current_Cast = (Goedel.Tool.Guigen.TextArea)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.TextArea__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.TextArea__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.TextArea Current_Cast = (Goedel.Tool.Guigen.TextArea)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.TextArea__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.TextArea__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.TextArea__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.TextArea__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.TextArea Current_Cast = (Goedel.Tool.Guigen.TextArea)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error ]");
								}
							}
                        break;


                    case StateCode.Color_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Color Current_Cast = (Goedel.Tool.Guigen.Color)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Color__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Color__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Color Current_Cast = (Goedel.Tool.Guigen.Color)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Color__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Color__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Color__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Color__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Color Current_Cast = (Goedel.Tool.Guigen.Color)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error ]");
								}
							}
                        break;


                    case StateCode.Size_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Size Current_Cast = (Goedel.Tool.Guigen.Size)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Size__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Size__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Size Current_Cast = (Goedel.Tool.Guigen.Size)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Size__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Size__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Size__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Size__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Size Current_Cast = (Goedel.Tool.Guigen.Size)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error ]");
								}
							}
                        break;


                    case StateCode.Decimal_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Decimal Current_Cast = (Goedel.Tool.Guigen.Decimal)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Decimal__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Decimal__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Decimal Current_Cast = (Goedel.Tool.Guigen.Decimal)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Decimal__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Decimal__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Decimal__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Decimal__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Decimal Current_Cast = (Goedel.Tool.Guigen.Decimal)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error ]");
								}
							}
                        break;


                    case StateCode.DateTime_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.DateTime Current_Cast = (Goedel.Tool.Guigen.DateTime)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.DateTime__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.DateTime__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.DateTime Current_Cast = (Goedel.Tool.Guigen.DateTime)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.DateTime__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.DateTime__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.DateTime__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.DateTime__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.DateTime Current_Cast = (Goedel.Tool.Guigen.DateTime)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error ]");
								}
							}
                        break;


                    case StateCode.Integer_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Integer Current_Cast = (Goedel.Tool.Guigen.Integer)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.Integer__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Integer__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Integer Current_Cast = (Goedel.Tool.Guigen.Integer)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Integer__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Integer__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Integer__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Integer__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Integer Current_Cast = (Goedel.Tool.Guigen.Integer)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Range) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error Range ]");
								}
							}
                        break;


                    case StateCode.Readonly_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Range_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Guigen.Range Current_Cast = (Goedel.Tool.Guigen.Range)Current;
                            Current_Cast.Max = Convert.ToInt32(Text);
                            State = StateCode.Range__Max;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Range__Max:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Guigen.Range Current_Cast = (Goedel.Tool.Guigen.Range)Current;
                            Current_Cast.Min = Convert.ToInt32(Text);
                            State = StateCode.Range__Min;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Range__Min:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Width_Start:
                        if (Token == TokenType.INTEGER) {
                            Goedel.Tool.Guigen.Width Current_Cast = (Goedel.Tool.Guigen.Width)Current;
                            Current_Cast.Request = Convert.ToInt32(Text);
                            State = StateCode.Width__Request;
                            break;
                            }
                        throw new Expected("Expected Integer");

                    case StateCode.Width__Request:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.QRScan_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.QRScan Current_Cast = (Goedel.Tool.Guigen.QRScan)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__SectionT, Current_Cast);
                            State = StateCode.QRScan__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.QRScan__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.QRScan Current_Cast = (Goedel.Tool.Guigen.QRScan)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.QRScan__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.QRScan__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.QRScan__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.QRScan__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.QRScan Current_Cast = (Goedel.Tool.Guigen.QRScan)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Readonly) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Error) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Readonly Error ]");
								}
							}
                        break;



                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}
#pragma warning restore IDE0022	

