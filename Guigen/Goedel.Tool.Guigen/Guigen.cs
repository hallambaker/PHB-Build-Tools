
//  Copyright (c) 1988-2022 by Phill Hallam-Baker
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;




//
// Namespace Goedel.Tool.Guigen
// Class Guigen
//


// Types
//   TopTypeType
//       Copyright
//       Application
//   TypeType
//       MITLicense
//       BSD2License
//       BSD3License
//       ISCLicense
//       Apache2License
//       OtherLicense
//       Declaration
//       Structure
//       Environment
//       Icon
//       Menu
//       Catalog
//       Spool
//       Default
//       Selector
//       Action
//       MenuEntry
//   IdType
//   NamespaceType
//       Goedel.Tool.Guigen
//   ClassType
//       Guigen
//   NameType
//       Date
//       Holder
//       License
//       Text
//       Namespace
//       Id
//       Entries
//       Entry
//       Prompt
//       File
//   TokenType
//       GroupT
//       CatalogItem
//       MenuItem

#pragma warning disable IDE0022, IDE0066, IDE1006, IDE0059
namespace Goedel.Tool.Guigen {


    public enum GuigenType {
        _Top,

        Copyright,
        MITLicense,
        BSD2License,
        BSD3License,
        ISCLicense,
        Apache2License,
        OtherLicense,
        Application,
        Declaration,
        Structure,
        Environment,
        Catalog,
        Spool,
        Menu,
        Default,
        Selector,
        Action,
        MenuEntry,
        Text,
        Icon,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public GuigenType _Tag ();

        public _Choice _Parent;
        public Guigen _Base;

		public abstract void Serialize (StructureWriter Output, bool tag);

    	public virtual void Init (_Choice parent) {
            _Parent = parent;
            _Base ??= parent?._Base;
			}

        

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice parent) {
			Init (parent);
            _Base = parent._Base;
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Copyright : _Choice {
		public string					Date;
		public string					Holder;
        public _Choice					License;

        public override GuigenType _Tag () =>GuigenType.Copyright;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			License._InitChildren (this);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Copyright");
				}

			Output.WriteAttribute ("Date", Date);
			Output.WriteAttribute ("Holder", Holder);
	        License.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Copyright");
				}			
			}
		}

    public partial class MITLicense : _Choice {

        public override GuigenType _Tag () =>GuigenType.MITLicense;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("MITLicense");
				}

			if (tag) {
				Output.EndElement ("MITLicense");
				}			
			}
		}

    public partial class BSD2License : _Choice {

        public override GuigenType _Tag () =>GuigenType.BSD2License;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("BSD2License");
				}

			if (tag) {
				Output.EndElement ("BSD2License");
				}			
			}
		}

    public partial class BSD3License : _Choice {

        public override GuigenType _Tag () =>GuigenType.BSD3License;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("BSD3License");
				}

			if (tag) {
				Output.EndElement ("BSD3License");
				}			
			}
		}

    public partial class ISCLicense : _Choice {

        public override GuigenType _Tag () =>GuigenType.ISCLicense;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("ISCLicense");
				}

			if (tag) {
				Output.EndElement ("ISCLicense");
				}			
			}
		}

    public partial class Apache2License : _Choice {

        public override GuigenType _Tag () =>GuigenType.Apache2License;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Apache2License");
				}

			if (tag) {
				Output.EndElement ("Apache2License");
				}			
			}
		}

    public partial class OtherLicense : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override GuigenType _Tag () =>GuigenType.OtherLicense;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("OtherLicense");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("OtherLicense");
				}			
			}
		}

    public partial class Application : _Choice {
        public TOKEN<_Choice>			Namespace;
        public ID<_Choice>				Id; 
        public List <Declaration>           Entries = new List<Declaration> ();

        public override GuigenType _Tag () =>GuigenType.Application;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Application");
				}

	        Output.WriteId ("Namespace", Namespace.ToString());
	        Output.WriteId ("Id", Id.ToString()); 
			Output.StartList ("");
			foreach (Declaration _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Application");
				}			
			}
		}

    public partial class Declaration : _Choice {
        public ID<_Choice>				Id; 
        public _Choice					Entry;

        public override GuigenType _Tag () =>GuigenType.Declaration;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			Entry._InitChildren (this);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Declaration");
				}

	        Output.WriteId ("Id", Id.ToString()); 
	        Entry.Serialize (Output, true);
			if (tag) {
				Output.EndElement ("Declaration");
				}			
			}
		}

    public partial class Structure : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Structure;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Structure");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Structure");
				}			
			}
		}

    public partial class Environment : _Choice {
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Environment;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Environment");
				}

			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Environment");
				}			
			}
		}

    public partial class Catalog : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Catalog;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Catalog");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Catalog");
				}			
			}
		}

    public partial class Spool : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.Spool;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Spool");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Spool");
				}			
			}
		}

    public partial class Menu : _Choice {
        public List <MenuEntry>           Entries = new List<MenuEntry> ();

        public override GuigenType _Tag () =>GuigenType.Menu;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Menu");
				}

			Output.StartList ("");
			foreach (MenuEntry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Menu");
				}			
			}
		}

    public partial class Default : _Choice {
        public List <MenuEntry>           Entries = new List<MenuEntry> ();

        public override GuigenType _Tag () =>GuigenType.Default;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Default");
				}

			Output.StartList ("");
			foreach (MenuEntry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Default");
				}			
			}
		}

    public partial class Selector : _Choice {
        public List <MenuEntry>           Entries = new List<MenuEntry> ();

        public override GuigenType _Tag () =>GuigenType.Selector;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Selector");
				}

			Output.StartList ("");
			foreach (MenuEntry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Selector");
				}			
			}
		}

    public partial class Action : _Choice {
        public List <MenuEntry>           Entries = new List<MenuEntry> ();

        public override GuigenType _Tag () =>GuigenType.Action;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Action");
				}

			Output.StartList ("");
			foreach (MenuEntry _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Action");
				}			
			}
		}

    public partial class MenuEntry : _Choice {
        public TOKEN<_Choice>			Id;
		public string					Prompt;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override GuigenType _Tag () =>GuigenType.MenuEntry;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("MenuEntry");
				}

	        Output.WriteId ("Id", Id.ToString());
			Output.WriteAttribute ("Prompt", Prompt);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("MenuEntry");
				}			
			}
		}

    public partial class Text : _Choice {
		public string					Prompt;

        public override GuigenType _Tag () =>GuigenType.Text;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Text");
				}

			Output.WriteAttribute ("Prompt", Prompt);
			if (tag) {
				Output.EndElement ("Text");
				}			
			}
		}

    public partial class Icon : _Choice {
		public string					File;

        public override GuigenType _Tag () =>GuigenType.Icon;


		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Icon");
				}

			Output.WriteAttribute ("File", File);
			if (tag) {
				Output.EndElement ("Icon");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() =>  Label = null;

        public override GuigenType _Tag () => GuigenType._Label;

		public override void Serialize (StructureWriter Output, bool tag) =>Output.WriteId ("ID", Label.ToString());
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Copyright_Start,
		Copyright__Date,				
		Copyright__Holder,				
		Copyright__License,				
		MITLicense_Start,
		BSD2License_Start,
		BSD3License_Start,
		ISCLicense_Start,
		Apache2License_Start,
		OtherLicense_Start,
		OtherLicense__Text,				
		Application_Start,
		Application__Namespace,				
		Application__Id,				
		Application__Entries,				
		Declaration_Start,
		Declaration__Id,				
		Declaration__Entry,				
		Structure_Start,
		Structure__Entries,				
		Environment_Start,
		Environment__Entries,				
		Catalog_Start,
		Catalog__Id,				
		Catalog__Prompt,				
		Catalog__Entries,				
		Spool_Start,
		Spool__Id,				
		Spool__Prompt,				
		Spool__Entries,				
		Menu_Start,
		Menu__Entries,				
		Default_Start,
		Default__Entries,				
		Selector_Start,
		Selector__Entries,				
		Action_Start,
		Action__Entries,				
		MenuEntry_Start,
		MenuEntry__Id,				
		MenuEntry__Prompt,				
		MenuEntry__Entries,				
		Text_Start,
		Text__Prompt,				
		Icon_Start,
		Icon__File,				
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Tool.Guigen._Choice     Token;
        }

    public partial class Guigen : Goedel.Registry.Parser{
        public List <Goedel.Tool.Guigen._Choice>        Top;
        public Registry	<Goedel.Tool.Guigen._Choice>	Registry;

        public bool StartOfEntry {get;  private set;}

        StateCode								State;
        Goedel.Tool.Guigen._Choice				Current;
        List <_StackItem>						Stack;


        public static Guigen Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new Guigen() {
				Options = Options
				};

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
            Result.Init ();
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
                Entry._Base = this;
				Entry._InitChildren (null);
				}
			}

        public Guigen() {
            Top = new List<Goedel.Tool.Guigen._Choice> () ;
            Registry = new Registry <Goedel.Tool.Guigen._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            StartOfEntry = true;

			TYPE__GroupT = Registry.TYPE ("GroupT"); 
			TYPE__CatalogItem = Registry.TYPE ("CatalogItem"); 
			TYPE__MenuItem = Registry.TYPE ("MenuItem"); 



            }



        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__GroupT ;
        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__CatalogItem ;
        public TYPE<Goedel.Tool.Guigen._Choice> TYPE__MenuItem ;

        private Goedel.Tool.Guigen._Choice New_Choice(string Label) {
            switch (Label) {

                case "Copyright": return NewCopyright();
                case "MITLicense": return NewMITLicense();
                case "BSD2License": return NewBSD2License();
                case "BSD3License": return NewBSD3License();
                case "ISCLicense": return NewISCLicense();
                case "Apache2License": return NewApache2License();
                case "OtherLicense": return NewOtherLicense();
                case "Application": return NewApplication();
                case "Declaration": return NewDeclaration();
                case "Structure": return NewStructure();
                case "Environment": return NewEnvironment();
                case "Catalog": return NewCatalog();
                case "Spool": return NewSpool();
                case "Menu": return NewMenu();
                case "Default": return NewDefault();
                case "Selector": return NewSelector();
                case "Action": return NewAction();
                case "MenuEntry": return NewMenuEntry();
                case "Text": return NewText();
                case "Icon": return NewIcon();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Tool.Guigen.Copyright NewCopyright() {
            Goedel.Tool.Guigen.Copyright result = new Goedel.Tool.Guigen.Copyright();
            Push (result);
            State = StateCode.Copyright_Start;
            return result;
            }


        private Goedel.Tool.Guigen.MITLicense NewMITLicense() {
            Goedel.Tool.Guigen.MITLicense result = new Goedel.Tool.Guigen.MITLicense();
            Push (result);
            State = StateCode.MITLicense_Start;
            return result;
            }


        private Goedel.Tool.Guigen.BSD2License NewBSD2License() {
            Goedel.Tool.Guigen.BSD2License result = new Goedel.Tool.Guigen.BSD2License();
            Push (result);
            State = StateCode.BSD2License_Start;
            return result;
            }


        private Goedel.Tool.Guigen.BSD3License NewBSD3License() {
            Goedel.Tool.Guigen.BSD3License result = new Goedel.Tool.Guigen.BSD3License();
            Push (result);
            State = StateCode.BSD3License_Start;
            return result;
            }


        private Goedel.Tool.Guigen.ISCLicense NewISCLicense() {
            Goedel.Tool.Guigen.ISCLicense result = new Goedel.Tool.Guigen.ISCLicense();
            Push (result);
            State = StateCode.ISCLicense_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Apache2License NewApache2License() {
            Goedel.Tool.Guigen.Apache2License result = new Goedel.Tool.Guigen.Apache2License();
            Push (result);
            State = StateCode.Apache2License_Start;
            return result;
            }


        private Goedel.Tool.Guigen.OtherLicense NewOtherLicense() {
            Goedel.Tool.Guigen.OtherLicense result = new Goedel.Tool.Guigen.OtherLicense();
            Push (result);
            State = StateCode.OtherLicense_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Application NewApplication() {
            Goedel.Tool.Guigen.Application result = new Goedel.Tool.Guigen.Application();
            Push (result);
            State = StateCode.Application_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Declaration NewDeclaration() {
            Goedel.Tool.Guigen.Declaration result = new Goedel.Tool.Guigen.Declaration();
            Push (result);
            State = StateCode.Declaration_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Structure NewStructure() {
            Goedel.Tool.Guigen.Structure result = new Goedel.Tool.Guigen.Structure();
            Push (result);
            State = StateCode.Structure_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Environment NewEnvironment() {
            Goedel.Tool.Guigen.Environment result = new Goedel.Tool.Guigen.Environment();
            Push (result);
            State = StateCode.Environment_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Catalog NewCatalog() {
            Goedel.Tool.Guigen.Catalog result = new Goedel.Tool.Guigen.Catalog();
            Push (result);
            State = StateCode.Catalog_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Spool NewSpool() {
            Goedel.Tool.Guigen.Spool result = new Goedel.Tool.Guigen.Spool();
            Push (result);
            State = StateCode.Spool_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Menu NewMenu() {
            Goedel.Tool.Guigen.Menu result = new Goedel.Tool.Guigen.Menu();
            Push (result);
            State = StateCode.Menu_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Default NewDefault() {
            Goedel.Tool.Guigen.Default result = new Goedel.Tool.Guigen.Default();
            Push (result);
            State = StateCode.Default_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Selector NewSelector() {
            Goedel.Tool.Guigen.Selector result = new Goedel.Tool.Guigen.Selector();
            Push (result);
            State = StateCode.Selector_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Action NewAction() {
            Goedel.Tool.Guigen.Action result = new Goedel.Tool.Guigen.Action();
            Push (result);
            State = StateCode.Action_Start;
            return result;
            }


        private Goedel.Tool.Guigen.MenuEntry NewMenuEntry() {
            Goedel.Tool.Guigen.MenuEntry result = new Goedel.Tool.Guigen.MenuEntry();
            Push (result);
            State = StateCode.MenuEntry_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Text NewText() {
            Goedel.Tool.Guigen.Text result = new Goedel.Tool.Guigen.Text();
            Push (result);
            State = StateCode.Text_Start;
            return result;
            }


        private Goedel.Tool.Guigen.Icon NewIcon() {
            Goedel.Tool.Guigen.Icon result = new Goedel.Tool.Guigen.Icon();
            Push (result);
            State = StateCode.Icon_Start;
            return result;
            }


        static Goedel.Tool.Guigen.GuigenType _Reserved(string Label) {
            switch (Label) {

                case "Copyright": return Goedel.Tool.Guigen.GuigenType.Copyright;
                case "MITLicense": return Goedel.Tool.Guigen.GuigenType.MITLicense;
                case "BSD2License": return Goedel.Tool.Guigen.GuigenType.BSD2License;
                case "BSD3License": return Goedel.Tool.Guigen.GuigenType.BSD3License;
                case "ISCLicense": return Goedel.Tool.Guigen.GuigenType.ISCLicense;
                case "Apache2License": return Goedel.Tool.Guigen.GuigenType.Apache2License;
                case "OtherLicense": return Goedel.Tool.Guigen.GuigenType.OtherLicense;
                case "Application": return Goedel.Tool.Guigen.GuigenType.Application;
                case "Declaration": return Goedel.Tool.Guigen.GuigenType.Declaration;
                case "Structure": return Goedel.Tool.Guigen.GuigenType.Structure;
                case "Environment": return Goedel.Tool.Guigen.GuigenType.Environment;
                case "Catalog": return Goedel.Tool.Guigen.GuigenType.Catalog;
                case "Spool": return Goedel.Tool.Guigen.GuigenType.Spool;
                case "Menu": return Goedel.Tool.Guigen.GuigenType.Menu;
                case "Default": return Goedel.Tool.Guigen.GuigenType.Default;
                case "Selector": return Goedel.Tool.Guigen.GuigenType.Selector;
                case "Action": return Goedel.Tool.Guigen.GuigenType.Action;
                case "MenuEntry": return Goedel.Tool.Guigen.GuigenType.MenuEntry;
                case "Text": return Goedel.Tool.Guigen.GuigenType.Text;
                case "Icon": return Goedel.Tool.Guigen.GuigenType.Icon;

                }
            return Goedel.Tool.Guigen.GuigenType._Bottom;
            }


		public void Serialize (TextWriter Output)=> Serialize (Output, OutputFormat.Goedel);

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Tool.Guigen._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Tool.Guigen._Choice Token) {
            _StackItem Item = new _StackItem () {
					State = State,
					Token = Current
					};

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.AssertFalse (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.AssertFalse (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Copyright) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Application) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Declaration)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) { 
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Copyright_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Copyright Current_Cast = (Goedel.Tool.Guigen.Copyright)Current;
                            Current_Cast.Date = Text;
                            State = StateCode.Copyright__Date;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Copyright__Date:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Copyright Current_Cast = (Goedel.Tool.Guigen.Copyright)Current;
                            Current_Cast.Holder = Text;
                            State = StateCode.Copyright__Holder;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Copyright__Holder:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Copyright Current_Cast = (Goedel.Tool.Guigen.Copyright)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.MITLicense) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.BSD2License) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.BSD3License) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.ISCLicense) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Apache2License) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.OtherLicense) ) {
                                State = StateCode.Copyright__License;
                                Current_Cast.License = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [MITLicense BSD2License BSD3License ISCLicense Apache2License OtherLicense ]");
                                }
                            break;
                            }
                        else { 
						    throw new Expected("Parser Error Expected [MITLicense BSD2License BSD3License ISCLicense Apache2License OtherLicense ]");
                            }

                    case StateCode.Copyright__License:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.MITLicense_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.BSD2License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.BSD3License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.ISCLicense_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Apache2License_Start:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.OtherLicense_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.OtherLicense__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.OtherLicense__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Guigen.OtherLicense Current_Cast = (Goedel.Tool.Guigen.OtherLicense)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Application_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Application Current_Cast = (Goedel.Tool.Guigen.Application)Current;
                            Current_Cast.Namespace = Registry.TOKEN(Position, Text, TYPE__GroupT, Current_Cast);
                            State = StateCode.Application__Namespace;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Application__Namespace:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Application Current_Cast = (Goedel.Tool.Guigen.Application)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__GroupT, Current_Cast);
                            State = StateCode.Application__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Application__Id:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Application__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Application__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.Guigen.Application Current_Cast = (Goedel.Tool.Guigen.Application)Current;
                            Current_Cast.Entries.Add (NewDeclaration ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Declaration_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Declaration Current_Cast = (Goedel.Tool.Guigen.Declaration)Current;
                            Current_Cast.Id = Registry.ID(Position, Text, TYPE__GroupT, Current_Cast);
                            State = StateCode.Declaration__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Declaration__Id:
                        if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Declaration Current_Cast = (Goedel.Tool.Guigen.Declaration)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Structure) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Environment) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Icon) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Menu) ) {
                                State = StateCode.Declaration__Entry;
                                Current_Cast.Entry = New_Choice(Text);
                                }
                            else {
                               throw new Expected ("Parser Error Expected [Structure Environment Icon Menu ]");
                                }
                            break;
                            }
                        else { 
						    throw new Expected("Parser Error Expected [Structure Environment Icon Menu ]");
                            }

                    case StateCode.Declaration__Entry:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Structure_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Structure__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Structure__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Structure Current_Cast = (Goedel.Tool.Guigen.Structure)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Icon) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Icon ]");
								}
							}
                        break;


                    case StateCode.Environment_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Environment__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Environment__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Environment Current_Cast = (Goedel.Tool.Guigen.Environment)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Catalog) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Spool) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Icon) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Menu) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Catalog Spool Icon Menu ]");
								}
							}
                        break;


                    case StateCode.Catalog_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Catalog Current_Cast = (Goedel.Tool.Guigen.Catalog)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__CatalogItem, Current_Cast);
                            State = StateCode.Catalog__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Catalog__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Catalog Current_Cast = (Goedel.Tool.Guigen.Catalog)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Catalog__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Catalog__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Catalog__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Catalog__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Catalog Current_Cast = (Goedel.Tool.Guigen.Catalog)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Default) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Selector) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Action) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Default Selector Action ]");
								}
							}
                        break;


                    case StateCode.Spool_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.Spool Current_Cast = (Goedel.Tool.Guigen.Spool)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__CatalogItem, Current_Cast);
                            State = StateCode.Spool__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.Spool__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Spool Current_Cast = (Goedel.Tool.Guigen.Spool)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Spool__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Spool__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Spool__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Spool__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.Spool Current_Cast = (Goedel.Tool.Guigen.Spool)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Default) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Selector) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Action) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Default Selector Action ]");
								}
							}
                        break;


                    case StateCode.Menu_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Menu__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Menu__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.Guigen.Menu Current_Cast = (Goedel.Tool.Guigen.Menu)Current;
                            Current_Cast.Entries.Add (NewMenuEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Default_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Default__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Default__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.Guigen.Default Current_Cast = (Goedel.Tool.Guigen.Default)Current;
                            Current_Cast.Entries.Add (NewMenuEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Selector_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Selector__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Selector__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.Guigen.Selector Current_Cast = (Goedel.Tool.Guigen.Selector)Current;
                            Current_Cast.Entries.Add (NewMenuEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.Action_Start:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Action__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Action__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$


						/// Label
                        else {
                            Goedel.Tool.Guigen.Action Current_Cast = (Goedel.Tool.Guigen.Action)Current;
                            Current_Cast.Entries.Add (NewMenuEntry ());
                            Represent = true;
                            }

                        break;


                    case StateCode.MenuEntry_Start:
                        if ((Token == TokenType.LABEL) | (Token == TokenType.LITERAL)) {
                            Goedel.Tool.Guigen.MenuEntry Current_Cast = (Goedel.Tool.Guigen.MenuEntry)Current;
                            Current_Cast.Id = Registry.TOKEN(Position, Text, TYPE__MenuItem, Current_Cast);
                            State = StateCode.MenuEntry__Id;
                            break;
                            }
                        throw new Expected("Expected LABEL or LITERAL");

                    case StateCode.MenuEntry__Id:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.MenuEntry Current_Cast = (Goedel.Tool.Guigen.MenuEntry)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.MenuEntry__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.MenuEntry__Prompt:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.MenuEntry__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.MenuEntry__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Guigen.MenuEntry Current_Cast = (Goedel.Tool.Guigen.MenuEntry)Current;
                            Goedel.Tool.Guigen.GuigenType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Icon) |
									(LabelType == Goedel.Tool.Guigen.GuigenType.Text) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Icon Text ]");
								}
							}
                        break;


                    case StateCode.Text_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Text Current_Cast = (Goedel.Tool.Guigen.Text)Current;
                            Current_Cast.Prompt = Text;
                            State = StateCode.Text__Prompt;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Text__Prompt:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Icon_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Guigen.Icon Current_Cast = (Goedel.Tool.Guigen.Icon)Current;
                            Current_Cast.File = Text;
                            State = StateCode.Icon__File;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Icon__File:
                        Pop ();
                        Represent = true; 
                        break;

                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}
#pragma warning restore IDE0022	

